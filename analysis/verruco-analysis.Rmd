---
title: "Freshwater Verrucocmicrobia"
author: "Edna Chiang"
date: "July 6, 2015"
output: html_document
---


### Load Libraries
```{r}
library(phyloseq)
packageVersion("phyloseq")
library(ggplot2)
library(ape)
library(vegan)
library(plyr)
library(dplyr)
library(scales)
library(grid)
library(reshape2)
library(phangorn)
library(phytools)
library(DESeq)
library(DESeq2)
library(pander)
library(ade4)
library(labdsv)
library(geiger)
library(sciplot)
library(picante)
library(leaps)
theme_set(theme_bw())
set.seed(1)
```

### Import Data
```{r}
load("VerrucoData.RData")
```


### Visualize overall phyloseq object
```{r}
# Check the sequencing depth of each sample 
sums_verruco <- data.frame(colSums(otu_table(verruco)))
colnames(sums_verruco) <- "Sample_TotalSeqs"
sums_verruco$sample <- row.names(sums_verruco)
sums_verruco <- arrange(sums_verruco, Sample_TotalSeqs)

# Create a plot of the number of sequences per sample
ggplot(sums_verruco, aes(x=reorder(sample,Sample_TotalSeqs),
                         y = Sample_TotalSeqs)) + 
  ylab("Number of Sequences per Sample") +
  geom_bar(stat = "identity", colour="black",fill="cornflowerblue") +
  xlab("Sample Name") + 
  ggtitle("Total Number of Sequences per Sample") + 
  theme(axis.text.x = element_text(colour = "black", size=6, angle=45, hjust = 1,
                                   vjust = 1))

# Look at # of reads
ggplot(data.frame(sum = sample_sums(verruco)), aes(sum)) + 
  geom_histogram(colour = "white", fill = "blue") + 
  ggtitle("Sample read counts") + 
  xlab("total sequences")

# Min, Mean, Max of sample read counts
min(sample_sums(verruco))
mean(sample_sums(verruco))
max(sample_sums(verruco))
```


### Merge Duplicates & create new phyloseq object
```{r}
# Merges duplicates & calculates mean
verr.dupmerge <- merge_samples(verruco, "Duplicates")

## Fix metadata of merged duplicates 
# Grab unique lines (first entry) from verruco phyloseq object metadata
unique.idx <- !(duplicated(sample_data(verruco)$Duplicates))
duplicate.metadata <- sample_data(verruco)[unique.idx, ]

# Fix SampleID and rownames
duplicate.metadata$SampleID <- duplicate.metadata$Duplicates
rownames(duplicate.metadata) <- duplicate.metadata$Duplicates

# Assign new metadata to phyloseq object
sample_data(verr.dupmerge) <- duplicate.metadata

```

### Visualize merged dataset
```{r}
# Check the sequencing depth of each sample 
sums_dupmerge <- data.frame(rowSums(otu_table(verr.dupmerge)))
colnames(sums_dupmerge) <- "Sample_TotalSeqs"
sums_dupmerge$sample <- row.names(sums_dupmerge)
sums_dupmerge <- arrange(sums_dupmerge, Sample_TotalSeqs)

# Create a plot of the number of sequences per sample
ggplot(sums_dupmerge, aes(x=reorder(sample, Sample_TotalSeqs),
                          y = Sample_TotalSeqs)) + 
  ylab("Number of Sequences per Sample") +
  geom_bar(stat = "identity", colour="black",fill="cornflowerblue") +
  xlab("Sample Name") + 
  ggtitle("Total Number of Sequences per Sample") + 
  theme(axis.text.x = element_text(colour = "black", size=6, angle=45, hjust = 1,
                                   vjust = 1))

# Look at # of reads
ggplot(data.frame(sum = sample_sums(verr.dupmerge)), aes(sum)) + 
  geom_histogram(colour = "white", fill = "blue") +
  ggtitle("Sample read counts") + 
  xlab("total sequences")

# Mean, max and min of sample read counts
min(sample_sums(verr.dupmerge))
mean(sample_sums(verr.dupmerge))
max(sample_sums(verr.dupmerge))
```


### Trim & normalize data based on # of reads/sequence depth
```{r}
# Function to normalize data
scale_reads <- function(physeq,n){
  physeq.scale <- transform_sample_counts(physeq, function(x) {round((n*x/sum(x)))})
  #otu_table(physeq.scale) = round(otu_table(physeq.scale))
  physeq.scale = prune_taxa(taxa_sums(physeq.scale) > 0, physeq.scale)
  return(physeq.scale)
}

# Remove North Hypo samples because their reads are seriously too low (8 & 18, respectively)
dupmerge.subset <- subset_samples(physeq = verr.dupmerge, SampleID != "Z14.051.P")
dupmerge.subset <- subset_samples(physeq = dupmerge.subset, SampleID != "Z14.051.F")

# The samples below are roughly <10k reads; however, removing or keeping them makes no significant difference in my downstream analyses so I chose to keep them
#dupmerge.subset <- subset_samples(physeq = dupmerge.subset, SampleID != "Z14.016.P")
#dupmerge.subset <- subset_samples(physeq = dupmerge.subset, SampleID != "MINE.P.514")
#dupmerge.subset <- subset_samples(physeq = dupmerge.subset, SampleID != "Z14.047.P")
#dupmerge.subset <- subset_samples(physeq = dupmerge.subset, SampleID != "Sp13.ED.MM110.DD")
#dupmerge.subset <- subset_samples(physeq = dupmerge.subset, SampleID != "Z14.048.P")
#dupmerge.subset <- subset_samples(physeq = dupmerge.subset, SampleID != "Sp13.ED.MM110.SN")
#dupmerge.subset <- subset_samples(physeq = dupmerge.subset, SampleID != "Sp13.ED.MM110.SD")


# Normalize our dataset!
scaled <- scale_reads(dupmerge.subset,min(sample_sums(dupmerge.subset)))
  ### Scaled to 2,072 (min sample)
    # 5593 taxa
    # 226 samples

# Order the factors
sample_data(scaled)$Lake_Type <- ordered(sample_data(scaled)$Lake_Type,
                                     levels=c("Laurentian","Estuary","Inland"))
sample_data(scaled)$Fraction <- ordered(sample_data(scaled)$Fraction,
                                     levels = c("Particle","Free","Sediment"))
sample_data(scaled)$Depth <- ordered(sample_data(scaled)$Depth,
                                  levels = c("Top", "Bottom","Sediment"))
sample_data(scaled)$Season <- ordered(sample_data(scaled)$Season,
                                   levels = c("Spring","Summer","Fall"))

# Check the sequencing depth of each sample 
sums_scaled <- data.frame(rowSums(otu_table(scaled)))
colnames(sums_scaled) <- "Sample_TotalSeqs"
sums_scaled$SampleID <- row.names(sums_scaled)
sums_scaled <- arrange(sums_scaled, Sample_TotalSeqs)

# Create a plot of the number of sequences per sample
ggplot(sums_scaled, aes(x=SampleID, y = Sample_TotalSeqs)) + 
  ylab("Number of Sequences per Sample") +
  geom_bar(stat = "identity", colour="black",fill="cornflowerblue") +
  xlab("Sample Name") + 
  ggtitle("Total Number of Sequences per Sample") + 
  theme(axis.text.x = element_text(colour = "black", size=6, angle=45, hjust = 1,
                                   vjust = 1))

# Let's visualized our normalized dataset
ggplot(data.frame(sum = sample_sums(scaled)), aes(sum)) + 
  geom_histogram(colour = "black", fill = "deeppink") +
  ggtitle("Sample read counts") + 
  xlab("total sequences")
```


### Rank abundance curve of top 300 OTUs
```{r}
### Get top 300 most abundant OTUs
top300.taxa <- sort(taxa_sums(scaled), TRUE)[1:300]
top300.OTUs <- prune_taxa(names(top300.taxa), scaled)
top300.sums <- data.frame(taxa_sums(top300.OTUs))

ggplot(top300.sums,aes(x=row.names(top300.sums), y=taxa_sums.top300.OTUs.)) + 
  ylab("Number of Sequences per OTU") + scale_x_discrete(expand = c(0,0)) + 
  scale_y_continuous(expand = c(0,0)) + theme_classic() +
  geom_bar(stat="identity",colour="black",fill="darkturquoise") +
  xlab("OTU Rank") +
  ggtitle("Rank Abundance Curve of the Top 300 OTUs") + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```



### Examine Phyla
```{r}
# Merge samples with the same taxonomic rank
good_phylum <- tax_glom(scaled, taxrank = "Phylum")

# Transform each merged phylum count to rel abun
phylum.99 = transform_sample_counts(good_phylum, function(x){(x/sum(x))*100})

# If a phylum has <1% rel abun, change that to 0%
otu_table(phylum.99)[otu_table(phylum.99) < 1] <- 0

# Remove anything with 0% rel abun
phylum.99 = prune_taxa(taxa_sums(phylum.99) > 0, phylum.99)

# Create rank abundance of OTUs
top5phyla.barplot <-barplot(sort(taxa_sums(phylum.99),TRUE)[1:5]/nsamples(phylum.99),
  las = 2,
  cex.axis = 0.7, 
  space = F, 
  names.arg = c("Proteobacteria", "Bacteroidetes","Actinobacteria", "Verrucomicrobia", "Cyanobacteria"), 
  col = c("khaki1", "mediumorchid3", "firebrick3", "lightslateblue", "chartreuse3"), 
  main = "Top 5 Bacterial Phyla", 
  xlab = "Phylum", 
  ylab = "Relative Abundance (%)", 
  ylim = c(0, 35), 
  las = 0
)

```

### Phyla-level bar plot
```{r}
# Summarize data by Lake_Type
phy.df <- psmelt(phylum.99)
phy.sum <- phy.df %>%
  group_by(Lake_Type, Phylum, Fraction, Season) %>%
  summarize(Mean = mean(Abundance),
            Median = median(Abundance),
            SD = sd(Abundance),
            SE = se(Abundance),
            iqr = IQR(Abundance))

# Calculate IQR limits
phy.sum$iqr.min <- phy.sum$Median - 0.5*phy.sum$iqr
phy.sum[which(phy.sum$iqr.min < 0),10] <- 0
  # Any IQR min < 0, change to 0 (otherwise error bar won't plot)
phy.sum$iqr.max <- phy.sum$Median + 0.5*phy.sum$iqr


# Remove phyla that are <1% rel abun (median) in all 3 Lake Types
phy.trim <- phy.sum[-which(phy.sum$Phylum== "BD1-5"),]
phy.trim <- phy.trim[-which(phy.trim$Phylum== "Candidate_division_OD1"),]
phy.trim <- phy.trim[-which(phy.trim$Phylum== "Candidate_division_OP3"),] 
phy.trim <- phy.trim[-which(phy.trim$Phylum== "Candidate_division_OP8"),] 
phy.trim <- phy.trim[-which(phy.trim$Phylum== "Candidate_division_SR1"),]
#phy.trim <- phy.trim[-which(phy.trim$Phylum== "Candidate_division_WS3"),]
phy.trim <- phy.trim[-which(phy.trim$Phylum== "Fibrobacteres"),]
phy.trim <- phy.trim[-which(phy.trim$Phylum== "Firmicutes"),] 
phy.trim <- phy.trim[-which(phy.trim$Phylum== "Gemmatimonadetes"),] 
phy.trim <- phy.trim[-which(phy.trim$Phylum== "Lentisphaerae"),] 
phy.trim <- phy.trim[-which(phy.trim$Phylum== "NPL-UPA2"),] 
#phy.trim <- phy.trim[-which(phy.trim$Phylum== "Spirochaetae"),]
phy.trim <- phy.trim[-which(phy.trim$Phylum== "TM6"),] 
#phy.trim <- phy.trim[-which(phy.trim$Phylum== "Nitrospirae"),]
#phy.trim <- phy.trim[-which(phy.trim$Phylum== "unclassified"),]
#phy.trim <- phy.trim[-which(phy.trim$Phylum== "Acidobacteria"),]
#phy.trim <- phy.trim[-which(phy.trim$Phylum== "Chloroflexi"),]
phy.trim$Phylum <- ordered(phy.trim$Phylum, levels=c("Acidobacteria", "Actinobacteria", "Armatimonadetes", "Bacteroidetes", "Candidate_division_WS3", "Chlorobi", "Chloroflexi", "Cyanobacteria", "Nitrospirae", "Planctomycetes", "Proteobacteria", "Spirochaetae", "unclassified", "Verrucomicrobia"))

phy.trim$Phylum <- ordered(phy.trim$Phylum, levels=c("Verrucomicrobia", "unclassified", "Spirochaetae", "Proteobacteria", "Planctomycetes", "Nitrospirae", "Cyanobacteria", "Chloroflexi", "Chlorobi", "Candidate_division_WS3", "Bacteroidetes", "Armatimonadetes", "Actinobacteria", "Acidobacteria"))

# Set phylum plotting colors for 14 taxa
phylum.colors <- c(Acidobacteria = "cornsilk3",
                   Actinobacteria="firebrick3",
                   Armatimonadetes="lightsalmon",
                   Bacteroidetes="lightblue1",
                   Candidate_division_WS3 = "lightgreen",
                   Chlorobi="goldenrod1",
                   Chloroflexi="plum1",
                   Cyanobacteria="#33a02c",
                   Nitrospirae = "deepskyblue",
                   Planctomycetes="tomato4",
                   Proteobacteria="khaki1",
                   Spirochaetae = "indianred3",
                   unclassified = "dimgray",
                   Verrucomicrobia="lightslateblue")

##### PLOT #####

label_rev <- function(labels) {
  label_value(rev(labels))
}


png("phy.relabund.png", width = 17.8, height = 23, units = "cm", res = 600)
ggplot(phy.trim, aes(x=Phylum, y=Median, fill=Phylum)) +
          geom_bar(stat="identity", color="black") +
          scale_fill_manual(values = phylum.colors, name="Phylum") +
  geom_errorbar(aes(ymax=iqr.max, ymin=iqr.min), width=0.25) + 
  xlab("Phyla") + ylab("Median Relative Abundance (Taxa > 1%)") +
  facet_grid(Fraction + Season ~ Lake_Type, space="free", scales = "free_x",
             labeller = label_rev) +
  coord_flip() +
  scale_y_continuous(breaks = c(0,5,10,15,20,25,30,35,40), limits = c(0,51)) +
          theme(axis.title.x = element_text(size=10, face="bold"),
                axis.text.x = element_text(size=8),
                axis.text.y = element_blank(),
                axis.ticks.y = element_blank(),
                axis.title.y = element_text(size=10, face="bold"),
                plot.title = element_text(size = 12, face="bold"),
                legend.title = element_text(size=10, face="bold"),
                legend.text = element_text(size =8),
                strip.text.x = element_text(size=10, face="bold"),
                strip.text.y = element_text(size=10, face="bold"),
                plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
                strip.background = element_blank(),
                legend.position="right") +
  guides(fill = guide_legend(reverse=TRUE, keywidth = 0.75, keyheight = 0.75))
dev.off()


```

### Separate out Verrucos
```{r}
# Pull out all verruco OTUs
Ver <- subset_taxa(scaled, Phylum == "Verrucomicrobia")
  # taxa = 329

# Check the sequencing depth of Verrucos each sample 
sums_Ver <- data.frame(rowSums(otu_table(Ver)))
colnames(sums_Ver) <- "Sample_TotalSeqs"
sums_Ver$sample <- row.names(sums_Ver)
sums_Ver <- arrange(sums_Ver, Sample_TotalSeqs)
summary(sums_Ver)

####  Create a plot of the number of Verruco sequences per sample
ggplot(sums_Ver, aes(x=reorder(sample, Sample_TotalSeqs), y = Sample_TotalSeqs)) + 
  ylab("Number of Sequences per Sample") +
  geom_bar(stat = "identity", colour="black",fill="cornflowerblue")  + xlab("Sample Name") + 
  ggtitle("Total Number of Sequences per Sample") + 
  theme(axis.text.x = element_text(colour = "black", size=6, angle=45, hjust = 1, vjust = 1))

```

### Verruco Relative Abundance to test normality
```{r}
# Transforms each merged phylum count to rel abun
Ver.rel <- transform_sample_counts(Ver, function(x){x/sum(x)})

# If a phylum has <1% rel abun, change that to 0%
otu_table(Ver.rel)[otu_table(Ver.rel)<.01] <- 0

# Remove anything with 0% rel abun
Ver.rel = prune_taxa(taxa_sums(Ver.rel)>0,Ver.rel)
  # Remove taxa = 135
  # Remain taxa = 208

# Create rank abundance of OTUs
barplot(sort(taxa_sums(Ver.rel),TRUE)[1:20]/nsamples(Ver.rel),las=2,cex.axis=.7)
    ## 1 = OPB35_soil_group
    ## 2 = OPB35_soil_group
    ## 3 = Opitutae - vadinHA64
    ## 4 = Spartobacteria - Chthoniobacterales - FukuN18_freshwater_Lake_Type
    ## 5 = Verrucomicrobiae - Verrucomicrobiales - Verrucomicrobiaceae

Ver.otu <- as.numeric(otu_table(Ver.rel))
hist(Ver.otu)
    ## So skewed that I can't even get a legit histogram from it
qqnorm(Ver.otu)
qqline(Ver.otu)
    ## Looks exponentially distributed

# Test for normality
shapiro.test(Ver.otu)
    ## Too many samples
ks.test(Ver.otu, "pnorm", mean=mean(Ver.otu), sd=sd(Ver.otu))
    # p-value = 0
    # Not normal
ks.test(Ver.otu, "pexp")
    ## p-value = 9
    ## not exponentially distributed
Ver.otu <- Ver.otu + 1

#### Log Transformation ####
Ver.log <- log(Ver.otu)
hist(Ver.log)
    ## Still not normal
    ## Skewed to the right
qqnorm(Ver.log)
qqline(Ver.log)
ks.test(Ver.log, "pnorm", mean=mean(Ver.otu), sd=sd(Ver.otu))
    ## p=value = 0
    ## Not normal

### Verruco Intra-Phylum Rel Abun is NOT NORMAL

```


### Intra-Verruco Rel Abund
```{r}
# Merge all Verruco OTUs by Class
classVer <- tax_glom(Ver, taxrank = "Class")

# Calculate relative abundance
classVer.rel = transform_sample_counts(classVer, function(x){x/sum(x)})

# If a phylum has <1% rel abun, change that to 0%
otu_table(classVer.rel)[otu_table(classVer.rel)<.01] <- 0

# Remove anything with 0% rel abun
classVer.rel = prune_taxa(taxa_sums(classVer.rel)>0,classVer.rel)

# Create rank abundance of OTUs
barplot(sort(taxa_sums(classVer.rel),TRUE)[1:20]/nsamples(classVer.rel),las=2,cex.axis=.7)



# Create dataframe to use in ggplot
classVer.df <- psmelt(classVer.rel)
classVer.df$Abundance <- classVer.df$Abundance * 100
classVer.df$Class <- ordered(classVer.df$Class, levels=c("unclassified","Verrucomicrobiae","Verrucomicrobia_Incertae_Sedis","Spartobacteria","S-BQ2-57_soil_group","Opitutae","OPB35_soil_group"))

# Colors that will be used in ggplot
Ver.colors <- c("OPB35_soil_group" = "#e41a1c", Opitutae = "#377eb8", "S-BQ2-57_soil_group" = "#984ea3", Spartobacteria = "#4daf4a", "Verrucomicrobia_Incertae_Sedis" = "#ff7f00", Verrucomicrobiae = "#ffd92f", unclassified="#f1a3a9")


##### Lake Type & Fraction facet #####

# # Pull out the factors that I'll use
# sub.classVer.df <- subset(classVer.df, select = c("Sample","Class", "Abundance","Lake_Type","Fraction"))
# 
# # Calculate stat summaries
# lakefrac <- ddply(sub.classVer.df, c("Lake_Type","Fraction", "Class"), summarise,
#                    Mean = mean(Abundance),
#                    Median = median(Abundance),
#                    SD = sd(Abundance),
#                    SE = se(Abundance),
#                    iqr = IQR(Abundance))
# 
# ### GGPLOT IT!
# ggplot(lakefrac, aes(y=Mean, x = Class, fill = Class)) +
#   facet_grid(Fraction ~ Lake_Type) +
#   geom_bar(stat="identity", position=position_dodge()) +
#   scale_fill_manual(values = Ver.colors, name = "Class") +
#   theme_bw() + ggtitle("Verrucomicrobia Classes Above 0.1%") + coord_flip() +
#   geom_errorbar(aes(ymin = Mean - SE, ymax = Mean + SE), width = 0.25) + 
#   xlab("Class") + ylab("Mean Relative Abundance (%)") +
#   theme(axis.title.x = element_text(face="bold", size=16),
#         axis.text.x = element_text(angle=0, colour="black", size=12),
#         axis.text.y = element_text(colour="black", size=12),
#         axis.title.y = element_text(face="bold", size=16),
#         plot.title = element_text(face="bold", size=20),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size = 12),
#         legend.position="none") 
# 
# 
# 
# 
# 
# 
# 
# ##### Season & Fraction facet #####
# 
# # Pull out the factors that I'll be using to make my graph
# sub.classVer.df <- subset(classVer.df, select = c("Sample","Class", "Abundance","Season", "Fraction"))
# 
# # Calculate stat summaries
# seasfrac <- ddply(sub.classVer.df, c("Season", "Class", "Fraction"), summarise,
#                    Mean= mean(Abundance),
#                    Median = median(Abundance),
#                    SD = sd(Abundance),
#                    SE = se(Abundance),
#                    iqr = IQR(Abundance))
# 
# 
# ### GGPLOT IT!
# ggplot(seasfrac, aes(y=Mean, x = Class, fill = Class)) +
#   facet_grid(Fraction ~ Season) +
#   geom_bar(stat="identity", position=position_dodge()) +
#   scale_fill_manual(values = Ver.colors, name = "Class") +
#   theme_bw() + ggtitle("Verrucomicrobia Classes Above 0.1%") + coord_flip() +
#   geom_errorbar(aes(ymin = Mean - SE, ymax = Mean + SE), width = 0.25) + 
#   xlab("Class") + ylab("Mean Relative Abundance (%)") +
#   theme(axis.title.x = element_text(face="bold", size=16),
#         axis.text.x = element_text(angle=0, colour="black", size=12),
#         axis.text.y = element_text(colour="black", size=12),
#         axis.title.y = element_text(face="bold", size=16),
#         plot.title = element_text(face="bold", size=20),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size = 12),
#         legend.position="none")
# 
# 
# 
# 
# ##### Lake_Type & Season facet #####
# 
# # Pull out the factors that I'll be using to make my graph
# sub.classVer.df <- subset(classVer.df, select = c("Sample","Class", "Abundance","Season", "Lake_Type"))
# 
# # Calculate stat summaries
# lakeseas <- ddply(sub.classVer.df, c("Season", "Class", "Lake_Type"), summarise,
#                    Mean = mean(Abundance),
#                    Median = median(Abundance),
#                    SD = sd(Abundance),
#                    SE = se(Abundance),
#                    iqr = IQR(Abundance))
# 
# 
# 
# ### GGPLOT IT!
# ggplot(lakeseas, aes(y=Mean, x = Class, fill = Class)) +
#   facet_grid(Season ~ Lake_Type) +
#   geom_bar(stat="identity", position=position_dodge()) +
#   scale_fill_manual(values = Ver.colors, name = "Class") +
#   theme_bw() + ggtitle("Verrucomicrobia Classes Above 0.1%") + coord_flip() +
#   geom_errorbar(aes(ymin = Mean - SE, ymax = Mean + SE), width = 0.25) + 
#   xlab("Class") + ylab("Mean Relative Abundance (%)") +
#   theme(axis.title.x = element_text(face="bold", size=16),
#         axis.text.x = element_text(angle=0, colour="black", size=12),
#         axis.text.y = element_text(colour="black", size=12),
#         axis.title.y = element_text(face="bold", size=16),
#         plot.title = element_text(face="bold", size=20),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size = 12),
#         legend.position="none")
# 
# 
# 
# 
# 
# 
##### Fraction & Depth facet #####

# Pull out the factors that I'll be using to make my graph
sub.classVer.df <- subset(classVer.df, select = c("Sample","Class", "Abundance","Depth", "Fraction"))

# Calculate stat summaries
depthfrac <- ddply(sub.classVer.df, c("Depth", "Class", "Fraction"), summarise,
                   Mean = mean(Abundance),
                   Median = median(Abundance),
                   SD = sd(Abundance),
                   SE = se(Abundance),
                   iqr = IQR(Abundance))


### GGPLOT IT!
ggplot(depthfrac, aes(y=Mean, x = Class, fill = Class)) +
  facet_grid(Fraction ~ Depth) +
  geom_bar(stat="identity", position=position_dodge()) +
  scale_fill_manual(values = Ver.colors, name = "Class") +
  theme_bw() + ggtitle("Verrucomicrobia Classes Above 0.1%") + coord_flip() +
  geom_errorbar(aes(ymin = Mean - SE, ymax = Mean + SE), width = 0.25) +
  xlab("Class") + ylab("Mean Relative Abundance (%)") +
  theme(axis.title.x = element_text(face="bold", size=16),
        axis.text.x = element_text(angle=0, colour="black", size=12),
        axis.text.y = element_text(colour="black", size=12),
        axis.title.y = element_text(face="bold", size=16),
        plot.title = element_text(face="bold", size=20),
        legend.title = element_text(size=12, face="bold"),
        legend.text = element_text(size = 12),
        legend.position="none")




##### Fraction + Season & Lake_Type facet #####

# Pull out the factors that I'll be using to make my graph
sub.classVer.df <- subset(classVer.df, select = c("Sample","Lake_Type", "Class", "Abundance","Fraction", "Season"))

# Calculate stat summaries
lakefracseas <- ddply(sub.classVer.df, c("Lake_Type", "Class", "Fraction", "Season"), summarise,
                   Mean = mean(Abundance),
                   Median = median(Abundance),
                   SD = sd(Abundance),
                   SE = se(Abundance),
                   iqr = IQR(Abundance))

# Calculate IQR limits
lakefracseas$iqr.min <- lakefracseas$Median - 0.5*lakefracseas$iqr
lakefracseas[which(lakefracseas$iqr.min < 0), 10] <- 0
  # Any IQR min < 0, change to 0 (otherwise error bar won't plot)
lakefracseas$iqr.max <- lakefracseas$Median + 0.5*lakefracseas$iqr


###### THIS ONE! ######

# This command is used to rearrange the vertical facet labels so that Fraction is on the outside & Season is on the inside
label_rev <- function(labels) {
  label_value(rev(labels))
}

#png("intraver.png", width = 17.8, height = 18, units = "cm", res = 600)
ggplot(lakefracseas, aes(y=Median, x = Class, fill = Class)) +
  facet_grid(Fraction + Season ~ Lake_Type, labeller= label_rev)   +
  geom_bar(stat="identity", position=position_dodge()) +
  scale_fill_manual(values = Ver.colors, name = "Class") +
  theme_bw() + ggtitle("Verrucomicrobia Classes Above 1%") + coord_flip() +
  geom_errorbar(aes(ymin = iqr.min, ymax = iqr.max), width = 0.25) + 
  xlab("Class") + ylab("Median Relative Abundance (%)") +
  theme(axis.title.x = element_text(face="bold", size=10),
        axis.text.x = element_text(colour = "black", size=8),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.y = element_text(face="bold", size=10),
        plot.title = element_text(face="bold", size = 12),
        strip.text.x = element_text(size=10, face="bold"),
        strip.text.y = element_text(size=10, face="bold"),
        legend.title = element_text(size=10, face="bold"),
        legend.text = element_text(size=8),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        strip.background = element_blank(),
        legend.position="right") +
  guides(fill = guide_legend(reverse=TRUE))
#dev.off()





##### ERRYTHING #####

# Pull out the factors that I'll be using to make my graph
sub.classVer.df <- subset(classVer.df, select = c("Sample","Lake_Type", "Class", "Abundance","Fraction", "Season", "Depth"))

# Calculate stat summaries
lakefracseasdepth <- ddply(sub.classVer.df, c("Lake_Type", "Class", "Fraction", "Season", "Depth"), summarise,
                   Mean = mean(Abundance),
                   Median = median(Abundance),
                   SD = sd(Abundance),
                   SE = se(Abundance),
                   iqr = IQR(Abundance))

# Calculate IQR limits
lakefracseasdepth$iqr.min <- lakefracseasdepth$Median - 0.5*lakefracseasdepth$iqr
lakefracseasdepth[which(lakefracseasdepth$iqr.min < 0), 10] <- 0
  # Any IQR min < 0, change to 0 (otherwise error bar won't plot)
lakefracseasdepth$iqr.max <- lakefracseasdepth$Median + 0.5*lakefracseasdepth$iqr


# This command is used to rearrange the vertical facet labels so that Fraction is on the outside & Season is on the inside
label_rev <- function(labels) {
  label_value(rev(labels))
}

png("intraver.all.png", width = 17.8, height = 18, units = "cm", res = 600)
ggplot(lakefracseasdepth, aes(y=Median, x = Class, fill = Class)) +
  facet_grid(Fraction + Season ~ Lake_Type + Depth, labeller= label_rev)   +
  geom_bar(stat="identity", position=position_dodge()) +
  scale_fill_manual(values = Ver.colors, name = "Class") +
  theme_bw() + ggtitle("Verrucomicrobia Classes Above 1%") + coord_flip() +
  geom_errorbar(aes(ymin = iqr.min, ymax = iqr.max), width = 0.25) + 
  xlab("Class") + ylab("Median Relative Abundance (%)") +
  theme(axis.title.x = element_text(face="bold", size=10),
        axis.text.x = element_text(colour = "black", size=8),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.y = element_text(face="bold", size=10),
        plot.title = element_text(face="bold", size = 12),
        strip.text.x = element_text(size=10, face="bold"),
        strip.text.y = element_text(size=10, face="bold"),
        legend.title = element_text(size=10, face="bold"),
        legend.text = element_text(size=8),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        strip.background = element_blank(),
        legend.position="right") +
  guides(fill = guide_legend(reverse=TRUE))
dev.off()


```



### Box-And-Whisker Plots
```{r}
# From the phyloseq object of merged Phyla, subset out just Verrucos
Ver.box.phy <- subset_taxa(phylum.99, Phylum == "Verrucomicrobia")

# Create dataframe of sample data
Ver.box <- data.frame(sample_data(Ver))

# Add in rel abun of Verruco phylum
Ver.box$Relative_Abundance <- otu_table(Ver.box.phy)


##### Test for Normality #####
# Visualize
hist(Ver.box$Relative_Abundance)
    ## So skewed that I can't even get a legit histogram from it
qqnorm(Ver.box$Relative_Abundance)
qqline(Ver.box$Relative_Abundance)

# Test for normality
shapiro.test(Ver.box$Relative_Abundance)
    # Not Normal
ks.test(Ver.box$Relative_Abundance, "pnorm",
        mean=mean(Ver.box$Relative_Abundance),
        sd=sd(Ver.box$Relative_Abundance))
    # p-value = 0.015
    # Not normal

# Visualize Log
hist(log(Ver.box$Relative_Abundance))
    # Yay! Looks so pretty!
qqnorm(log(Ver.box$Relative_Abundance))
qqline(log(Ver.box$Relative_Abundance))


# Test for normality
shapiro.test(log(Ver.box$Relative_Abundance))
    # p-value = 0.04068
    # Not Normal
ks.test(log(Ver.box$Relative_Abundance), "pnorm",
        mean=mean(log(Ver.box$Relative_Abundance)),
        sd=sd(log(Ver.box$Relative_Abundance)))
    # p-value = 0.4067
    # Not exponentially distributed


### Plotting Time!

### Fraction ###

#tiff("boxplot.tiff", width = 8.7, height = 8.7, units = "cm", res = 600)
frac.box <- ggplot(Ver.box, aes(x=Lake_Type, y=Relative_Abundance, fill=Fraction)) +
  geom_boxplot(position=position_dodge(1)) +
  scale_fill_manual(values = c("rosybrown","gold","saddlebrown")) +
  xlab("Lake Type") + ylab("Relative Abundance (%)") +
  facet_grid(~ Lake_Type, space = "free_x", scale="free") +
  theme(axis.title.x = element_text(face="bold", size=10),
        axis.text.x = element_text(angle=0, colour="black", size=8),
        axis.text.y = element_text(colour="black", size=8),
        axis.title.y = element_text(face="bold", size=10),
        plot.title = element_text(face="bold", size=10),
        legend.title = element_text(size=10, face="bold"),
        legend.text = element_text(size = 9),
        strip.text.x = element_blank(),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm")) + # top, right, bottom, left
  annotate("text", x= 1, y=41, label = "*", size=6, colour="red")
#dev.off()


### Season ###

# This is the annotation text for the plot below (seas.box)
# Since the plot is facetted and you have different text in each facet, you have to use geom_text and call on the dataframe made below (ann_text)
ann_text <- data.frame(lab=c(" ", " ", "+"),
                       Lake_Type = factor(c("Laurentian", "Estuary", "Inland"),
                                          levels = c("Laurentian", "Estuary",
                                                     "Inland")),
                       Season = factor(c("Spring", "Summer", "Fall")))

seas.box <- ggplot(Ver.box, aes(x=Lake_Type, y=Relative_Abundance, fill=Season)) +
  geom_boxplot(position=position_dodge(1)) +
  #scale_fill_manual(values = c("indianred1","skyblue2","mediumpurple2")) +
  xlab("Lake Type") + ylab("Relative Abundance (%)") +
  facet_grid(~ Lake_Type, space = "free_x", scale="free") +
  theme(axis.title.x = element_text(face="bold", size=10),
        axis.text.x = element_text(angle=0, colour="black", size=8),
        axis.text.y = element_text(colour="black", size=8),
        axis.title.y = element_text(face="bold", size=10),
        plot.title = element_text(face="bold", size=10),
        legend.title = element_text(size=10, face="bold"),
        legend.text = element_text(size = 9),
        strip.text.x = element_blank(),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm")) + # top, right, bottom, left
  geom_text(data = ann_text, aes(label=lab), x=c(1,1,1.33), y=c(42,42,42), size=4, color="red")




# tiff("boxplot.tiff", width = 8.7, height = 10, units = "cm", res = 600)
# grid.newpage()
# pushViewport(viewport(layout=(grid.layout(1,2, widths=c(7,2.15), heights=c(1)))))
# print(plot, vp=viewport(layout.pos.row=1, layout.pos.col=1))
# legend$vp <- viewport(layout.pos.row = 1, layout.pos.col = 2)
# grid.draw(legend)
# dev.off()


##### Kruskal-Wallis #####

### Test between lake types ###
kruskal.test(formula = Relative_Abundance ~ Lake_Type, data = Ver.box, subset=Lake_Type=="Laurentian" | Lake_Type=="Estuary")
  # Laurentian vs Estuary
  # p-value = 4.219e-8
kruskal.test(formula = Relative_Abundance ~ Lake_Type, data = Ver.box, subset=Lake_Type=="Laurentian" | Lake_Type=="Inland")
  # Laurentian vs Inland
  # p-value = 1.206e-10
kruskal.test(formula = Relative_Abundance ~ Lake_Type, data = Ver.box, subset=Lake_Type=="Estuary" | Lake_Type=="Inland")
  # Estuary vs Inland
  # p-value = 0.8792


### Test Fraction  ###
kruskal.test(formula = Relative_Abundance ~ Fraction, data = Ver.box)
  # All Fraction
  # p-value = 0.0003097
kruskal.test(formula = Relative_Abundance ~ Source, data = Ver.box)
  # All Source
  # p-value = 0.0001692
kruskal.test(formula = Relative_Abundance ~ Fraction, data = Ver.box, subset = Fraction != "Sediment")
  # All Free vs Part
  # p-value = 0.1491
kruskal.test(formula = Relative_Abundance ~ Fraction, data = Ver.box, subset = Fraction != "Free")
  # All Part vs Sed
  # p-value = 0.0005459
kruskal.test(formula = Relative_Abundance ~ Fraction, data = Ver.box, subset = Fraction != "Particle")
  # All Free vs Sed
  # p-value = 0.0001081

# Laurentian
kruskal.test(formula = Relative_Abundance ~ Fraction, data = Ver.box, subset=Lake_Type=="Laurentian")
  # Fraction
  # p-value = 0.01748

# Estuary
kruskal.test(formula = Relative_Abundance ~ Source, data = Ver.box, subset=Lake_Type=="Estuary")
  # Source
  # p-value = 6.914e-06
kruskal.test(formula = Relative_Abundance ~ Fraction, data = Ver.box, subset=Lake_Type=="Estuary" & Fraction != "Sediment")
  # Free vs Part
  # p-value = 0.02291
kruskal.test(formula = Relative_Abundance ~ Fraction, data = Ver.box, subset=Lake_Type=="Estuary" & Fraction != "Free")
  # Part vs Sed
  # p-value = 3.859e-06
kruskal.test(formula = Relative_Abundance ~ Fraction, data = Ver.box, subset=Lake_Type=="Estuary" & Fraction != "Particle")
  # Free vs Sed
  # p-value = 0.000259

# Inland
kruskal.test(formula = Relative_Abundance ~ Fraction, data = Ver.box, subset=Lake_Type=="Inland")
  # Fraction
  # p-value = 3.624e-05


### Test Season ###
kruskal.test(formula = Relative_Abundance ~ Season, data = Ver.box)
  # All Season
  # p-value = 0.6103

# Laurentian
kruskal.test(formula = Relative_Abundance ~ Season, data = Ver.box, subset=Lake_Type=="Laurentian")
  # Season
  # p-value = 0.241

# Estuary
kruskal.test(formula = Relative_Abundance ~ Season, data = Ver.box, subset=Lake_Type=="Estuary")
  # Season
  # p-value = 0.2177

# Inland
kruskal.test(formula = Relative_Abundance ~ Season, data = Ver.box, subset=Lake_Type=="Inland")
  # Season
  # p-value = 0.0009751
kruskal.test(formula = Relative_Abundance ~ Season, data = Ver.box, subset=Lake_Type=="Inland" & Season != "Spring")
  # Summer vs Fall
  # p-value = 0.0005545
kruskal.test(formula = Relative_Abundance ~ Season, data = Ver.box, subset=Lake_Type=="Inland" & Season != "Summer")
  # Spring vs Fall
  # p-value = 0.0007583
kruskal.test(formula = Relative_Abundance ~ Season, data = Ver.box, subset=Lake_Type=="Inland" & Season != "Fall")
  # Spring vs Summer
  # p-value = 0.3826

### Test Depth ###
kruskal.test(formula = Relative_Abundance ~ Depth, data = Ver.box)
  # All Depth
  # p-value = 0.004995
kruskal.test(formula = Relative_Abundance ~ Depth, data = Ver.box, subset = Depth !="Sediment")
  # All Top vs Bot
  # p-value = 0.3348

# Laurentian
kruskal.test(formula = Relative_Abundance ~ Depth, data = Ver.box, subset=Lake_Type=="Laurentian")
  # Deptb
  # p-value = 0.07562

# Estuary
kruskal.test(formula = Relative_Abundance ~ Depth, data = Ver.box, subset=Lake_Type=="Estuary")
  # Depth
  # p-value = 1.348e-05
kruskal.test(formula = Relative_Abundance ~ Source, data = Ver.box, subset=Lake_Type=="Estuary")
  # Water vs Sediment
  # p-value = 6.914e-06
kruskal.test(formula = Relative_Abundance ~ Depth, data = Ver.box, subset=Lake_Type=="Estuary" & Source == "Water")
  # Top vs Bot
  # p-value = 0.1037
kruskal.test(formula = Relative_Abundance ~ Depth, data = Ver.box, subset=Lake_Type=="Estuary" & Depth != "Top")
  # Bot vs Sed
  # p-value = 9.896e-06
kruskal.test(formula = Relative_Abundance ~ Depth, data = Ver.box, subset=Lake_Type=="Estuary" & Depth != "Bottom")
  # Top vs Sed
  # p-value = 0.0001089

# Inland
kruskal.test(formula = Relative_Abundance ~ Depth, data = Ver.box, subset=Lake_Type=="Inland")
  # Depth
  # p-value = 0.1201

```


### Linear Model
```{r}
# Read in metadata files
lau.env <- read.table("metadata_laurentian.csv", header=T, sep=",",
                      row.names=1, as.is=T)
est.env <- read.table("metadata_estuary.csv", header=T, sep=",",
                      row.names=1, as.is=T)
est.env <- est.env[,-27]
  # Remove DO %
inl.env <- read.table("metadata_inland.csv", header=T, sep=",",
                      row.names=1, as.is=T)

# Subset out Verrucos
Ver.phy <- subset_taxa(phylum.99, Phylum == "Verrucomicrobia")

# Remove samples that have NAs in the metadata
trim.otus <- subset_samples(Ver.phy, SampleID != "Su13.ED.MM15.DN")
trim.otus <- subset_samples(trim.otus, SampleID != "Su13.BD.MM15.DN")
trim.otus <- subset_samples(trim.otus, SampleID != "Sp13.ED.MM15.SN")
trim.otus <- subset_samples(trim.otus, SampleID != "Sp13.ED.MM15.DD")
trim.otus <- subset_samples(trim.otus, SampleID != "Sp13.ED.MM110.DD")
trim.otus <- subset_samples(trim.otus, SampleID != "Sp13.BD.MM15.DD")
trim.otus <- subset_samples(trim.otus, SampleID != "Sp13.BD.MM110.DD")
trim.otus <- subset_samples(trim.otus, SampleID != "Fa13.BD.MM110.SD")
trim.otus <- subset_samples(trim.otus, SampleID != "Fa13.BD.MM110.SN")
trim.otus <- subset_samples(trim.otus, SampleID != "Fa13.BD.MM15.DN")
trim.otus <- subset_samples(trim.otus, SampleID != "Fa13.ED.MM15.DN")
trim.otus <- subset_samples(trim.otus, Station != "Buoy")
trim.otus <- subset_samples(trim.otus, Source != "Sediment")
trim.otus <- subset_samples(trim.otus, SampleID != "Z14.060.P")
trim.otus <- subset_samples(trim.otus, SampleID != "Z14.060.F")

# Categorize samples by lake
Ver.lau <- subset_samples(trim.otus, Lake_Type == "Laurentian")
Ver.est <- subset_samples(trim.otus, Lake_Type == "Estuary")
Ver.inl <- subset_samples(trim.otus, Lake_Type == "Inland")

# Prepare metadata
lau.samp <- sample_data(lau.env)
est.samp <- sample_data(est.env)
inl.samp <- sample_data(inl.env)

# Make new phyloseq object with metadata
lau.phy <- merge_phyloseq(Ver.lau, lau.samp)
est.phy <- merge_phyloseq(Ver.est, est.samp)
inl.phy <- merge_phyloseq(Ver.inl, inl.samp)

# Convert pyloseq to dataframe
lau.df <- psmelt(lau.phy)
est.df <- psmelt(est.phy)
inl.df <- psmelt(inl.phy)

### Look for correlations between environmental factors
pairs(lau.df[21:35])
  # Using DO, Temp. & SiO2
pairs(est.df[21:37])
  # Using ORP, Temp, TDS, Chl, & SO4
pairs(inl.df[21:26])
  # Using SRP, Chl, & NH4


####### Fit data to linear model #######
# http://www.r-bloggers.com/simple-linear-regression-2/

##### Laurentian #####
xyplot(log(Abundance) ~ DO.Probe..mg.L., lau.df)
lau.DO <- lm(DO.Probe..mg.L.~ log(Abundance), lau.df)
summary(lau.DO)
confint(lau.DO, level=0.95)
  # Linear

xyplot(log(Abundance) ~ Temperature..C., lau.df)
lau.temp <- lm(Temperature..C.~log(Abundance), lau.df)
summary(lau.temp)
confint(lau.temp, level=0.95)
  # Says linear, but R2 is essentially 0

xyplot(log(Abundance) ~ SiO2.mg.L, lau.df)
lau.Si <- lm(SiO2.mg.L~log(Abundance), lau.df)
summary(lau.Si)
confint(lau.Si, level=0.95)
  # Linear


### Unused environmental factors
xyplot(log(Abundance) ~ DOC.mg.L, lau.df)
lau.DOC <- lm(DOC.mg.L~log(Abundance), lau.df)
summary(lau.DOC)
confint(lau.DOC, level=0.95)
  # Negative R2

xyplot(log(Abundance) ~ TP.ug.L, lau.df)
lau.TP <- lm(TP.ug.L~log(Abundance), lau.df)
summary(lau.TP)
confint(lau.TP, level=0.95)
  # Not linear

xyplot(log(Abundance) ~ PON.mg.L, lau.df)
lau.PON <- lm(PON.mg.L~log(Abundance), lau.df)
summary(lau.PON)
confint(lau.PON, level=0.95)
  # Not linear

xyplot(log(Abundance) ~ PAR, lau.df)
lau.PAR <- lm(PAR~log(Abundance), lau.df)
summary(lau.PAR)
confint(lau.PAR, level=0.95)
  # Negative R2

xyplot(log(Abundance) ~ Chl.Probe...g.L., lau.df)
lau.Chl.p <- lm(Chl.Probe...g.L.~log(Abundance), lau.df)
summary(lau.Chl.p)
confint(lau.Chl.p, level=0.95)
  # Not linear

xyplot(log(Abundance) ~ Chl.Lab..ug.L., lau.df)
lau.Chl.l <- lm(Chl.Lab..ug.L.~log(Abundance), lau.df)
summary(lau.Chl.l)
confint(lau.Chl.l, level=0.95)
  # Not linear

xyplot(log(Abundance) ~ PP.ug.L, lau.df)
lau.PP <- lm(PP.ug.L~log(Abundance), lau.df)
summary(lau.PP)
confint(lau.PP, level=0.95)
  # Not linear

xyplot(log(Abundance) ~ TDP.ug.L, lau.df)
lau.TDP <- lm(TDP.ug.L~log(Abundance), lau.df)
summary(lau.TDP)
confint(lau.TDP, level=0.95)
  # Not linear

xyplot(log(Abundance) ~ TDP.SRP, lau.df)
lau.TDP.SRP <- lm(TDP.SRP~log(Abundance), lau.df)
summary(lau.TDP.SRP)
confint(lau.TDP.SRP, level=0.95)
  # Negative R2

xyplot(log(Abundance) ~ POC.mg.L, lau.df)
lau.POC <- lm(POC.mg.L~log(Abundance), lau.df)
summary(lau.POC)
confint(lau.POC, level=0.95)
  # Not linear

xyplot(log(Abundance) ~ TSS.mg.L, lau.df)
lau.TSS <- lm(TSS.mg.L~log(Abundance), lau.df)
summary(lau.TSS)
confint(lau.TSS, level=0.95)
  # Not linear

xyplot(log(Abundance) ~ Fluorescence.mg.m3., lau.df)
lau.fluor <- lm(Fluorescence.mg.m3.~log(Abundance), lau.df)
summary(lau.fluor)
confint(lau.fluor, level=0.95)
  # Not linear



##### Estuary #####
xyplot(log(Abundance) ~ ORP..mV., est.df)
est.ORP <- lm(ORP..mV.~log(Abundance), est.df)
summary(est.ORP)
confint(est.ORP, level=0.95)
  # Linear

xyplot(log(Abundance) ~ Temperature..C., est.df)
est.temp <- lm(Temperature..C.~log(Abundance), est.df)
summary(est.temp)
confint(est.temp, level=0.95)
  # LINEARRRRR

xyplot(log(Abundance) ~ TDS..mg.L., est.df)
est.TDS <- lm(TDS..mg.L.~log(Abundance), est.df)
summary(est.TDS)
confint(est.TDS, level=0.95)
  # LINEARRRRRR

xyplot(log(Abundance) ~ NO3.mg.L, est.df)
est.NO3 <- lm(NO3.mg.L~log(Abundance), est.df)
summary(est.NO3)
confint(est.NO3, level=0.95)
  # LINEARRRRRR


### Unused environmental factors
xyplot(log(Abundance) ~ pH, est.df)
est.pH <- lm(pH~log(Abundance), est.df)
summary(est.pH)
confint(est.pH, level=0.95)
  # LINEARRRRRR

xyplot(log(Abundance) ~ Cl.mg.L, est.df)
est.Cl <- lm(Cl.mg.L~log(Abundance), est.df)
summary(est.Cl)
confint(est.Cl, level=0.95)
  # LINEARRRRRR

xyplot(log(Abundance) ~ SRP.ug.L, est.df)
est.SRP <- lm(SRP.ug.L~log(Abundance), est.df)
summary(est.SRP)
confint(est.SRP, level=0.95)
  # Not linear

xyplot(log(Abundance) ~ Alk.mg.L, est.df)
est.Alk <- lm(Alk.mg.L~log(Abundance), est.df)
summary(est.Alk)
confint(est.Alk, level=0.95)
  # LINEARRRRR

xyplot(log(Abundance) ~ Turb.NTU, est.df)
est.Turb <- lm(Turb.NTU~log(Abundance), est.df)
summary(est.Turb)
confint(est.Turb, level=0.95)
  # Negative R2

xyplot(log(Abundance) ~ SpCond...S.cm., est.df)
est.SpCond <- lm(SpCond...S.cm.~log(Abundance), est.df)
summary(est.SpCond)
confint(est.SpCond, level=0.95)
  # LINEARRRRR

xyplot(log(Abundance) ~ Chl.Lab..ug.L., est.df)
est.Chl <- lm(Chl.Lab..ug.L.~log(Abundance), est.df)
summary(est.Chl)
confint(est.Chl, level=0.95)
  # Linear

xyplot(log(Abundance) ~ BGA.cells.mL, est.df)
est.BGA <- lm(BGA.cells.mL~log(Abundance), est.df)
summary(est.BGA)
confint(est.BGA, level=0.95)
  # Not linear

xyplot(log(Abundance) ~ SO4.mg.L, est.df)
est.SO4 <- lm(SO4.mg.L~log(Abundance), est.df)
summary(est.SO4)
confint(est.SO4, level=0.95)
  # Linear

xyplot(log(Abundance) ~ NH3.mg.L, est.df)
est.NH3 <- lm(NH3.mg.L~log(Abundance), est.df)
summary(est.NH3)
confint(est.NH3, level=0.95)
  # Not linear

xyplot(log(Abundance) ~ TKN.mg.L, est.df)
est.TKN <- lm(TKN.mg.L~log(Abundance), est.df)
summary(est.TKN)
confint(est.TKN, level=0.95)
  # Negative R2

xyplot(log(Abundance) ~ TP.ug.L, est.df)
est.TP <- lm(TP.ug.L~log(Abundance), est.df)
summary(est.TP)
confint(est.TP, level=0.95)
  # Negative R2

xyplot(log(Abundance) ~ DO.probe.mg.L, est.df)
est.DO <- lm(DO.probe.mg.L~log(Abundance), est.df)
summary(est.DO)
confint(est.DO, level=0.95)
  # Negative R2



##### Inland #####
xyplot(log(Abundance) ~ SRP.ug.L, inl.df)
inl.SRP <- lm(SRP.ug.L~log(Abundance), inl.df)
summary(inl.SRP)
confint(inl.SRP, level=0.95)
  # Linear, but super low R2

xyplot(log(Abundance) ~ Chl.Lab..ug.L., inl.df)
inl.Chl <- lm(Chl.Lab..ug.L.~log(Abundance), inl.df)
summary(inl.Chl)
confint(inl.Chl, level=0.95)
  # Linear, but R2 is essentially 0

xyplot(log(Abundance) ~ TP.ug.L, inl.df)
inl.TP <- lm(TP.ug.L~log(Abundance), inl.df)
summary(inl.TP)
confint(inl.TP, level=0.95)
  # Linear

xyplot(log(Abundance) ~ NH4.ug.L, inl.df)
inl.NH4 <- lm(NH4.ug.L~log(Abundance), inl.df)
summary(inl.NH4)
confint(inl.NH4, level=0.95)
  # Linear

### Unused environmental factors
xyplot(log(Abundance) ~ NO3.mg.L, inl.df)
inl.NO3 <- lm(NO3.mg.L~log(Abundance), inl.df)
summary(inl.NO3)
confint(inl.NO3, level=0.95)
  # Negative R2

xyplot(log(Abundance) ~ TDP.ug.L, inl.df)
inl.TDP <- lm(TDP.ug.L~log(Abundance), inl.df)
summary(inl.TDP)
confint(inl.TDP, level=0.95)
  # Imma say no because too many points are near 0 for TDP



##### MODELLING TIME #####  

# Function to extract the best subset multiple linear regression model 
# Arguments:
#   vars: vectors of all variables to consider in the model
#   response: response variable of the model (must be in quotes!)
#   dat: dataframe with vars and response
# Returns: a list with the variables in the best model, bic, cp, and adjusted r2
get_bestsub_summary <- function(vars, response, dat) {
  formula = reformulate(termlabels = vars, response = response)
  lm_model <- regsubsets(formula, method = "exhaustive", dat)
  bic <- summary(lm_model)$bic
  cp <- summary(lm_model)$cp
  adjr2 <- summary(lm_model)$adjr2
  best_model <- summary(lm_model)$which[which.min(bic), ]
  return(list(model = best_model, bic = bic, cp = cp, adjr2 = adjr2))
}


# Variables to include in models
lau.vars <- c("Temperature..C.", "DO.Probe..mg.L.", "SiO2.mg.L")
est.vars <- c("ORP..mV.", "Temperature..C.", "TDS..mg.L.", "Chl.Lab..ug.L.", "SO4.mg.L")
inl.vars <- c("SRP.ug.L", "Chl.Lab..ug.L.", "NH4.ug.L")

# Get the best variable subset model 
# Then fit the model to extract coefficients and p-values
lau.best.model <- lapply(lau.df, 
  function(x) {
    best_model <- get_bestsub_summary(lau.vars, "Abundance", lau.df)
    model <- lm(
      formula = reformulate(lau.vars[best_model$model[-1]], "Abundance"), 
      data = lau.df)
    return(model)
  })
summary(lau.best.model)
  # SiO2 coefficient = 1.190
  # Intercept = 2.443


est.best.model <- lapply(est.df, 
  function(x) {
    best_model <- get_bestsub_summary(est.vars, "Abundance", est.df)
    model <- lm(
      formula = reformulate(est.vars[best_model$model[-1]], "Abundance"), 
      data = est.df)
    return(model)
  })
  # ORP coefficient = 0.03577
  # Temp coefficient = -0.56380
  # TDS coefficient = -0.11094
  # Intercept = 36.16245

inl.best.model <- lapply(inl.df, 
  function(x) {
    best_model <- get_bestsub_summary(inl.vars, "Abundance", inl.df)
    model <- lm(
      formula = reformulate(inl.vars[best_model$model[-1]], "Abundance"), 
      data = inl.df)
    return(model)
  })
  # NH4.ug.L coefficient = -0.007094
  # Intercept = 11.894036

#### Pull out p-value
## Laurentian
lau.best.model <- get_bestsub_summary(lau.vars, "Abundance", lau.df)
lau.model <- lm(Abundance ~ SiO2.mg.L, lau.df)
summary(lau.model)
  # SiO2 p-value = 0.1262
  # Adjusted R2 = 0.06225

## Estuary
est.best.model <- get_bestsub_summary(est.vars, "Abundance", est.df)
est.model <- lm(Abundance ~ ORP..mV. + Temperature..C. + TDS..mg.L., est.df)
summary(est.model)
  # ORP p-value = 0.012133
  # Temp p-value = 0.008675
  # TDS = 0.000118
  # Adjusted R2 = 0.5989

## Inland
inl.best.model <- get_bestsub_summary(inl.vars, "Abundance", inl.df)
inl.model <- lm(Abundance ~ NH4.ug.L, inl.df)
summary(inl.model)
  # p-value = 2e-16
  # Adjusted R2 = 0.06124
```





### Alpha Diversity
```{r}
# Min # of reads
min_lib <- min(sample_sums(Ver))

# We will subsample to 35, the minimum number of reads. We will repeat this 100 times and average the diversity estimates from each trial.

# Initialize matrices to store richness and evenness estimates
nsamp = nsamples(Ver)
trials = 100

richness <- matrix(nrow = nsamp, ncol = trials)
row.names(richness) <- sample_names(Ver)
evenness <- matrix(nrow = nsamp, ncol = trials)
row.names(evenness) <- sample_names(Ver)

for (i in 1:100) {
  # Subsample
  r <- rarefy_even_depth(Ver, sample.size = min_lib, verbose = FALSE, replace = TRUE)
  
  # Calculate richness
  rich <- as.numeric(as.matrix(estimate_richness(r, measures = "Observed")))
  richness[ ,i] <- rich
  
  # Calculate evenness
  even <- as.numeric(as.matrix(estimate_richness(r, measures = "InvSimpson")))
  evenness[ ,i] <- even
}


# Create a new dataframe to hold the means and standard deviations of richness estimates
SampleID <- row.names(richness)
mean <- apply(richness, 1, mean)
sd <- apply(richness, 1, sd)
measure <- rep("Observed Richness", nsamp)
rich_stats <- data.frame(SampleID, mean, sd, measure)

# Create a new dataframe to hold the means and standard deviations of evenness estimates
SampleID <- row.names(evenness)
mean <- apply(evenness, 1, mean)
sd <- apply(evenness, 1, sd)
measure <- rep("Inverse Simpson", nsamp)
even_stats <- data.frame(SampleID, mean, sd, measure)

# Calculate Simpson's Evenness
simps_stats<- data.frame(matrix(nrow = nrow(even_stats), ncol = 4))
colnames(simps_stats) = c("SampleID", "mean", "sd", "measure")
simps_stats$SampleID <- even_stats$SampleID
simps_stats$mean <- even_stats$mean/rich_stats$mean
simps_stats$sd <- even_stats$sd/rich_stats$sd
simps_stats$measure <- "Simpson's Evenness"

# Combine the estimates into one dataframe
alpha <- rbind(rich_stats, even_stats, simps_stats)

# Add the sample metadata into this dataframe using the merge() command
s <- data.frame(sample_data(Ver))
alphadiv <- merge(alpha, s, by = "SampleID") 

# Group samples together by Lake_Type and Fraction & summarize stats
sum.stats <- alphadiv %>%
  group_by(Lake_Type, Fraction, measure) %>%
  summarize(Mean = mean(mean), 
            SE = se(mean), 
            SD = sd(mean), 
            Median = median(mean))

# Combine stats summary & sample metadata
final.stats <- left_join(alphadiv, sum.stats, by=c("Lake_Type", "Fraction", "measure"))
final.stats$measure <- factor(final.stats$measure, levels=c("Inverse Simpson", "Simpson's Evenness", "Observed Richness"))


##### PLOT #####
# png("alphadiv.png", width = 8.7, height = 13, units = "cm", res = 600)
# ggplot(final.stats, aes(x = Fraction, y = mean)) +
#   geom_errorbar(aes(ymin= Mean-SD, ymax=Mean+SD), color = "black", width=.1,
#                 position=position_dodge(1)) +
#   geom_point(data=final.stats, aes(x=Fraction, y=Median), pch=95, size=7) +
#   geom_point(data=final.stats, aes(x=Fraction, y=Mean), pch=126, size=7) +
#   facet_grid(measure ~ Lake_Type, scales = "free", space = "free_x") +
#   ylab("Mean") + 
#   theme(axis.title.x = element_text(face="bold", size=10),
#         axis.text.x = element_text(colour = "black", size=7),
#         axis.text.y = element_text(colour = "black", size=10),
#         axis.title.y = element_text(face="bold", size=10),
#         plot.title = element_text(face="bold", size = 10),
#         strip.text.x = element_text(size=10, face="bold"),
#         strip.text.y = element_text(size=10, face="bold"),
#         #legend.title = element_text(size=8, face="bold"),
#         #legend.text = element_text(size = 8),
#         plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         strip.background = element_blank(),
#         legend.position="none")
# dev.off()


##### Isolate Inverse Simpson #####

# Pull out just Inverse Simpson
inv.simp <- final.stats[which(final.stats$measure == "Inverse Simpson"),]

### Boxplot ###

### Fraction ###

# This is the annotation text for the plot below (seas.box)
# Since the plot is facetted and you have different text in each facet, you have to use geom_text and call on the dataframe made below (ann_text)
ann.frac <- data.frame(lab=c(" ", "*", ""),
                       Lake_Type = factor(c("Laurentian", "Estuary", "Inland"),
                                          levels = c("Laurentian", "Estuary",
                                                     "Inland")),
                       Fraction = factor(c("Particle", "Free", "Sediment")))

inv.simp.frac.plot <- ggplot(inv.simp, aes(x=Lake_Type, y=mean, fill=Fraction)) +
  geom_boxplot(position=position_dodge(1)) +
  scale_fill_manual(values = c("rosybrown","gold","saddlebrown")) +
  xlab("Lake Type") + ylab("Mean Inverse Simpson") +
  facet_grid(~ Lake_Type, space = "free_x", scale="free") +
  theme(axis.title.x = element_text(face="bold", size=10),
        axis.text.x = element_text(angle=0, colour="black", size=8),
        axis.text.y = element_text(colour="black", size=8),
        axis.title.y = element_text(face="bold", size=10),
        plot.title = element_text(face="bold", size=10),
        legend.title = element_text(size=10, face="bold"),
        legend.text = element_text(size = 9),
        strip.text.x = element_blank(),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm")) + # top, right, bottom, left
  geom_text(data = ann.frac, aes(x = c(1,1,1), y=c(16.5, 16.2, 16.5), label = lab), size = 6, color="red")
 

### Season ###

# This is the annotation text for the plot below (seas.box)
# Since the plot is facetted and you have different text in each facet, you have to use geom_text and call on the dataframe made below (ann_text)
ann.seas <- data.frame(lab=c(" ", "+", ""),
                       Lake_Type = factor(c("Laurentian", "Estuary", "Inland"),
                                          levels = c("Laurentian", "Estuary",
                                                     "Inland")),
                       Season = factor(c("Spring", "Summer", "Fall")))

inv.simp.seas.plot <- ggplot(inv.simp, aes(x=Lake_Type, y=mean, fill=Season)) +
  geom_boxplot(position=position_dodge(1)) +
  #scale_fill_manual(values = c("indianred1","skyblue2","mediumpurple2")) +
  xlab("Lake Type") + ylab("Mean Inverse Simpson") +
  facet_grid(~ Lake_Type, space = "free_x", scale="free") +
  theme(axis.title.x = element_text(face="bold", size=10),
        axis.text.x = element_text(angle=0, colour="black", size=8),
        axis.text.y = element_text(colour="black", size=8),
        axis.title.y = element_text(face="bold", size=10),
        plot.title = element_text(face="bold", size=10),
        legend.title = element_text(size=10, face="bold"),
        legend.text = element_text(size = 9),
        strip.text.x = element_blank(),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm")) + # top, right, bottom, left
  geom_text( data = ann.seas, aes(x=c(1,1,1), y=c(16.5,16.5,16.5), label=lab), size=4, color="red")



### Plot ###
#png("inv.simp.png", width = 8.7, height = 13, units = "cm", res = 600)
# inv.simp.plot <- ggplot(inv.simp, aes(x = Fraction, y = mean)) +
#   geom_errorbar(aes(ymin= Mean-SD, ymax=Mean+SD), color = "black", width=.1,
#                 position=position_dodge(1)) +
#   geom_point(data=inv.simp, aes(x=Fraction, y=Median), pch=95, size=7) +
#   geom_point(data=inv.simp, aes(x=Fraction, y=Mean), pch=126, size=7) +
#   facet_grid(~Lake_Type, scales = "free", space = "free_x") +
#   ylab("Mean Inverse Simpson") + ylim(0,12.5) +
#   theme(axis.title.x = element_text(face="bold", size=10),
#         axis.text.x = element_text(colour = "black", size=8),
#         axis.text.y = element_text(colour = "black", size=8),
#         axis.title.y = element_text(face="bold", size=10),
#         plot.title = element_text(face="bold", size = 10),
#         strip.text.x = element_text(size=10, face="bold"),
#         strip.text.y = element_text(size=10, face="bold"),
#         #legend.title = element_text(size=8, face="bold"),
#         #legend.text = element_text(size = 8),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         strip.background = element_blank(),
#         legend.position="none")
#dev.off()


##### Kruskal-Wallis #####
# For Inverse Simpson values

# Lake Type
kruskal.test(formula = mean ~ Lake_Type, data = inv.simp)
  # p-value = 0.1772

# Source
kruskal.test(formula = mean ~ Source, data = inv.simp)
  # p-value = 0.0005339

# Free vs Part
kruskal.test(formula = mean ~ Fraction, data = inv.simp, subset=Fraction != "Sediment")
  # p-value = 0.6899

### Fraction

# Laurentian
kruskal.test(formula = mean ~ Fraction, data = inv.simp, subset=Lake_Type=="Laurentian")
  # Fraction
  # p-value = 0.1208

# Estuary
kruskal.test(formula = mean ~ Fraction, data = inv.simp, subset=Lake_Type=="Estuary")
  # Fraction
  # p-value = 0.002485
kruskal.test(formula = mean ~ Source, data = inv.simp, subset=Lake_Type=="Estuary")
  # Sed vs Water
  # p-value = 0.0007338
kruskal.test(formula = mean ~ Fraction, data = inv.simp, subset=Lake_Type=="Estuary" & Fraction != "Sediment")
  # Free vs Part
  # p-value = 0.002485
kruskal.test(formula = mean ~ Fraction, data = inv.simp, subset=Lake_Type=="Estuary" & Fraction != "Free")
  # Part vs Sed
  # p-value = 0.002353
kruskal.test(formula = mean ~ Fraction, data = inv.simp, subset=Lake_Type=="Estuary" & Fraction != "Particle")
  # Free vs Sed
  # p-value = 0.001522

# Inland
kruskal.test(formula = mean ~ Fraction, data = inv.simp, subset=Lake_Type=="Inland")
  # Fraction
  # p-value = 0.7604

### Season
kruskal.test(formula = mean ~ Season, data = inv.simp)
  # All Season
  # p-value = 0.4207

# Laurentian
kruskal.test(formula = mean ~ Season, data = inv.simp, subset=Lake_Type=="Laurentian")
  # Season  
  # p-value = 0.1345

# Estuary
kruskal.test(formula = mean ~ Season, data = inv.simp, subset=Lake_Type=="Estuary")
  # Season
  # p-value = 0.01171
kruskal.test(formula = mean ~ Season, data = inv.simp, subset=Lake_Type=="Estuary" & Season != "Spring")
  # Summer vs Fall
  # p-value = 0.02461
kruskal.test(formula = mean ~ Season, data = inv.simp, subset=Lake_Type=="Estuary" & Season != "Summer")
  # Spring vs Fall
  # p-value = 0.4749
kruskal.test(formula = mean ~ Season, data = inv.simp, subset=Lake_Type=="Estuary" & Season != "Fall")
  # Spring vs Summer
  # p-value = 0.005921

# Inland
kruskal.test(formula = mean ~ Season, data = inv.simp, subset=Lake_Type=="Inland")
  # Season
  # p-value = 0.364


### Depth
kruskal.test(formula = mean ~ Depth, data = inv.simp)
  # All Depth
  # p-value = 0.0006259
kruskal.test(formula = mean ~ Depth, data = inv.simp, subset= Depth != "Sediment")
  # All Water
  # p-value = 0.09118

# Laurentian
kruskal.test(formula = mean ~ Depth, data = inv.simp, subset = Lake_Type == "Laurentian")
  # Depth 
  # p-value = 0.03019

# Estuary
kruskal.test(formula = mean ~ Depth, data = inv.simp, subset = Lake_Type == "Estuary")
  # Depth
  # p-value = 0.00213
kruskal.test(formula = mean ~ Depth, data = inv.simp, subset = Lake_Type == "Estuary" & Depth != "Sediment" )
  # Top vs Bottom
  # p-value = 0.3071
kruskal.test(formula = mean ~ Depth, data = inv.simp, subset = Lake_Type == "Estuary" & Depth != "Top" )
  # Bottom vs Sediment
  # p-value = 0.004267
kruskal.test(formula = mean ~ Depth, data = inv.simp, subset = Lake_Type == "Estuary" & Depth != "Bottom" )
  # Top vs Sediment 
  # p-value = 0.0008396

# Inland
kruskal.test(formula = mean ~ Depth, data = inv.simp, subset = Lake_Type == "Inland")
  # p-value = 0.9106

```

### RelAbun + Inverse Simpson Plot
```{r}
# Combine Verruco Rel Abun Boxplot & Inverse Simpson Plot
tiff("boxplot.invsimp.tiff", width = 17.8, height = 15, units = "cm", res = 600)
grid.newpage()
pushViewport(viewport(layout=(grid.layout(2,2, widths=c(1,1), heights=c(1.5,1.5)))))
print(frac.box, vp=viewport(layout.pos.row=1, layout.pos.col=1))
print(seas.box, vp=viewport(layout.pos.row=1, layout.pos.col=2))
print(inv.simp.frac.plot, vp=viewport(layout.pos.row=2, layout.pos.col=1))
print(inv.simp.seas.plot, vp=viewport(layout.pos.row=2, layout.pos.col=2))
dev.off()

```



### Phylogenetic Diversity
```{r}
#http://picante.r-forge.r-project.org/picante-intro.pdf

### Unweighted Calculations ###

# Create objects that you'll use with the picante package
ver.tree <- read.newick(file="ver.tre")
pre.picante <- merge_phyloseq(Ver.rel, ver.tree)
picante.phy <- phy_tree(pre.picante)
  # Phylogenetic tree to be used
picante.com <- data.frame(otu_table(pre.picante))
  # Community data (otu table) to be used

# Calculate Faith's Phylogenetic Diversity
pd.result <- pd(picante.com, picante.phy, include.root=T)
pd <- data.frame(pd.result)

## Convert Verruco tree to a distance matrix
# This distance matrix is used to calculate MDP & MNTD
# phydist <- cophenetic(picante.phy)
#
## Calculate MDP (Mean Pairwise Distance)
# ses.mpd.result <- ses.mpd(picante.com, phydist, null.model = "taxa.labels", abundance.weighted=F, runs=100)
#
## Calculate MNTD (Mean Nearest Taxon Distance)
# ses.mntd.result <- ses.mntd(picante.com, phydist, null.model = "taxa.labels", abundance.weighted=F, runs=100)
# 
## Pull out MDP and MNTD results
# mpd <- data.frame(ses.mpd.result)
# mntd <- data.frame (ses.mntd.result)


### Weighted ###
#ver.tree <- read.newick(file="ver.tre")

# Create objects that you'll use with the picante package
pre.picante <- merge_phyloseq(Ver, ver.tree)
phy <- phy_tree(pre.picante)
  # Phylogenetic tree to be used
com <- data.frame(otu_table(pre.picante))
  # Community data (otu table) to be used

# Calculate Faith's Phylogenetic Diversity
pd.result.weigh <- pd(com, phy, include.root=T)

## Convert Verruco tree to a distance matrix
# phydist.weigh <- cophenetic(phy)
#
## Calculate MDP (Mean Pairwise Distance)
# ses.mpd.result.weigh <- ses.mpd(com, phydist.weigh, null.model = "taxa.labels", abundance.weighted=T, runs=100)
#
## Calculate MNTD (Mean Nearest Taxon Distance)
# ses.mntd.result.weigh <- ses.mntd(com, phydist.weigh, null.model = "taxa.labels", abundance.weighted=T, runs=100)
# 
## Pull out MDP and MNTD results
# mpd.weigh <- data.frame(ses.mpd.result.weigh)
# mntd.weigh <- data.frame (ses.mntd.result.weigh)


##### Unweigh: Preparing to plot #####

# mpd$SampleID <- row.names(mpd)
# mntd$SampleID <- row.names(mntd)
pd$SampleID <- row.names(pd)
  # Make sure all SampleID's match!

# Let's pull out the first Stat in each of the 3 tests I ran
# PD test = PD
# MPD test = SES (Standardized Effect Size)
# MNTD test = SES (Standardized Effect Size)
pd.stats <- data.frame(pd$SampleID, pd$PD)
pd.stats$Measure <- rep("PD", 226)
colnames(pd.stats) <- c("SampleID", "Stat", "Measure")
# mpd.stats <- data.frame(mpd$SampleID, mpd$mpd.obs.z)
# mpd.stats$Measure <- rep("MPD SES",226)
# colnames(mpd.stats) <- c("SampleID", "Stat", "Measure")
# mntd.stats <- data.frame(mntd$SampleID, mntd$mntd.obs.z)
# mntd.stats$Measure <- rep("MNTD SES", 226)
# colnames(mntd.stats) <- c("SampleID", "Stat", "Measure")

## Let's combine those initial stats into one big dataframe
# unweigh.stats <- rbind(pd.stats, mpd.stats, mntd.stats)

## Now let's pull out the second stat in the mpd and mntd stats test
## MDP test = p-value
## MNTD test = p-value
# mpd.stats <- data.frame(mpd$SampleID, mpd$mpd.obs.p)
# mpd.stats$Measure <- rep("MPD p-value",226)
# colnames(mpd.stats) <- c("SampleID", "Stat", "Measure")
# mntd.stats <- data.frame(mntd$SampleID, mntd$mntd.obs.p)
# mntd.stats$Measure <- rep("MNTD p-value", 226)
# colnames(mntd.stats) <- c("SampleID", "Stat", "Measure")

## Making the final dataframe to use!
# unweigh.stats <- rbind(unweigh.stats, mpd.stats, mntd.stats)

## Pull out sample data
s <- data.frame(sample_data(Ver))
## Combine sample data with unweighted stats data
# unweigh.stats <- merge(unweigh.stats, s, by="SampleID")


## Group samples together by Lake_Type and Fraction & calculate stats summaries
# sum.unweigh <- unweigh.stats %>%
#   group_by(Lake_Type, Fraction, Measure) %>%
#   summarize(Mean = mean(Stat),
#             SE = se(Stat),
#             SD = sd(Stat),
#             Median = median(Stat))

## Combine the raw stats with the summarized stats
#final.unweigh <- left_join(unweigh.stats, sum.unweigh, by=c("Lake_Type", "Fraction", "Measure"))
#final.unweigh$Measure <- factor(final.unweigh$Measure, levels=c("PD", "MPD SES", "MPD p-value", "MNTD SES", "MNTD p-value"))



##### UNWEIGH: PLOT IT! #####
#png("alphadiv.png", width = 8.7, height = 13, units = "cm", res = 600)
# unweigh.plot <- ggplot(final.unweigh, aes(x = Fraction, y = Stat)) +
#   geom_errorbar(aes(ymin= Mean-SD, ymax=Mean+SD), color = "black", width=.1,
#                 position=position_dodge(1)) +
#   geom_point(data=final.unweigh, aes(x=Fraction, y=Median), pch=95, size=7) +
#   geom_point(data=final.unweigh, aes(x=Fraction, y=Mean), pch=126, size=7) +
#   facet_grid(Measure ~ Lake_Type, scales = "free", space = "free_x") +
#   ylab("Mean") + ggtitle("Unweighted") +
#   theme(axis.title.x = element_text(face="bold", size=10),
#         axis.text.x = element_text(colour = "black", size=7),
#         axis.text.y = element_text(colour = "black", size=10),
#         axis.title.y = element_text(face="bold", size=10),
#         plot.title = element_text(face="bold", size = 10),
#         strip.text.x = element_text(size=10, face="bold"),
#         strip.text.y = element_text(size=10, face="bold"),
#         #legend.title = element_text(size=8, face="bold"),
#         #legend.text = element_text(size = 8),
#         plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         strip.background = element_blank(),
#         legend.position="none")
#dev.off()





##### Weigh: Preparing to plot #####

# mpd.weigh$SampleID <- row.names(mpd.weigh)
# mntd.weigh$SampleID <- row.names(mntd.weigh)
pd.result.weigh$SampleID <- row.names(pd.result.weigh)
  # Make sure all SampleID's match!

# Let's pull out the first Stat in each of the 3 tests I ran
# PD test = PD
# MPD test = SES (Standardized Effect Size)
# MNTD test = SES (Standardized Effect Size)
pd.w.stats <- data.frame(pd.result.weigh$SampleID, pd.result.weigh$PD)
pd.w.stats$Measure <- rep("PD", 226)
colnames(pd.w.stats) <- c("SampleID", "Stat", "Measure")
# mpd.w.stats <- data.frame(mpd.weigh$SampleID, mpd.weigh$mpd.obs.z)
# mpd.w.stats$Measure <- rep("MPD SES",226)
# colnames(mpd.w.stats) <- c("SampleID", "Stat", "Measure")
# mntd.w.stats <- data.frame(mntd.weigh$SampleID, mntd.weigh$mntd.obs.z)
# mntd.w.stats$Measure <- rep("MNTD SES", 226)
# colnames(mntd.w.stats) <- c("SampleID", "Stat", "Measure")

## Let's combine those initial stats into one big dataframe
# weigh.stats <- rbind(pd.w.stats, mpd.w.stats, mntd.w.stats)

## Now let's pull out the second stat in the mpd and mntd stats test
## MDP test = p-value
## MNTD test = p-value
# mpd.w.stats <- data.frame(mpd.weigh$SampleID, mpd.weigh$mpd.obs.p)
# mpd.w.stats$Measure <- rep("MPD p-value",226)
# colnames(mpd.w.stats) <- c("SampleID", "Stat", "Measure")
# mntd.w.stats <- data.frame(mntd.weigh$SampleID, mntd.weigh$mntd.obs.p)
# mntd.w.stats$Measure <- rep("MNTD p-value", 226)
# colnames(mntd.w.stats) <- c("SampleID", "Stat", "Measure")

## Making the final dataframe to use!
# weigh.stats <- rbind(weigh.stats, mpd.w.stats, mntd.w.stats)

## Pull out sample data
# s <- data.frame(sample_data(Ver))
## Combine sample data with unweighted stats data
# weigh.stats <- merge(weigh.stats, s, by="SampleID")



## Group samples together by Lake_Type and Fraction
# sum.weigh <- weigh.stats %>%
#   group_by(Lake_Type, Fraction, Measure) %>%
#   summarize(Mean = mean(Stat),
#             SE = se(Stat),
#             SD = sd(Stat),
#             Median = median(Stat))

## Combine the raw stats with the summarized stats
#final.weigh <- left_join(weigh.stats, sum.weigh, by=c("Lake_Type", "Fraction", "Measure"))
#final.weigh$Measure <- factor(final.weigh$Measure, levels=c("PD", "MPD SES", "MPD p-value", "MNTD SES", "MNTD p-value"))



##### WEIGH: PLOT IT! #####
#png("alphadiv.png", width = 8.7, height = 13, units = "cm", res = 600)
# weigh.plot <- ggplot(final.weigh, aes(x = Fraction, y = Stat)) +
#   geom_errorbar(aes(ymin= Mean-SD, ymax=Mean+SD), color = "black", width=.1,
#                 position=position_dodge(1)) +
#   geom_point(data=final.weigh, aes(x=Fraction, y=Median), pch=95, size=7) +
#   geom_point(data=final.weigh, aes(x=Fraction, y=Mean), pch=126, size=7) +
#   facet_grid(Measure ~ Lake_Type, scales = "free", space = "free_x") +
#   ylab("Mean") + ggtitle("Weighted") +
#   theme(axis.title.x = element_text(face="bold", size=10),
#         axis.text.x = element_text(colour = "black", size=7),
#         axis.text.y = element_text(colour = "black", size=10),
#         axis.title.y = element_text(face="bold", size=10),
#         plot.title = element_text(face="bold", size = 10),
#         strip.text.x = element_text(size=10, face="bold"),
#         strip.text.y = element_text(size=10, face="bold"),
#         #legend.title = element_text(size=8, face="bold"),
#         #legend.text = element_text(size = 8),
#         plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         strip.background = element_blank(),
#         legend.position="none")
#dev.off()


##### COMBINE PLOTS #####
# tiff("phylodiv.tiff", width = 17, height = 17, units = "cm", res = 600)
# grid.newpage()
# pushViewport(viewport(layout=(grid.layout(1,2, widths=c(1,1), heights=c(1.5,1.5)))))
# print(unweigh.plot, vp=viewport(layout.pos.row=1, layout.pos.col=1))
# print(weigh.plot, vp=viewport(layout.pos.row=1, layout.pos.col=2))
# dev.off()








##### Isolate PD #####
pd.all <- rbind(pd.stats, pd.w.stats)
s <- data.frame(sample_data(Ver)) 
pd.ready <- merge(pd.all, s, by="SampleID")

# Group samples together by Lake_Type and Fraction
sum.pd <- pd.ready %>%
  group_by(Lake_Type, Fraction, Measure) %>%
  summarize(Mean = mean(Stat),
            SE = se(Stat),
            SD = sd(Stat),
            Median = median(Stat))


# Combine the raw stats with the summarized stats
final.pd <- left_join (pd.ready, sum.pd, by=c("Lake_Type", "Fraction", "Measure"))

### PLOT PD ONLY ###


### Fraction ###
ann.pd.frac <- data.frame(lab=c("*", "*", ""),
                       Lake_Type = factor(c("Laurentian", "Estuary", "Inland"),
                                          levels = c("Laurentian", "Estuary",
                                                     "Inland")),
                       Fraction = factor(c("Particle", "Free", "Sediment")))

pd.frac.plot <- ggplot(final.pd, aes(x=Lake_Type, y=Stat, fill=Fraction)) +
  geom_boxplot(position=position_dodge(1)) +
  scale_fill_manual(values = c("rosybrown","gold","saddlebrown")) +
  xlab("Lake Type") + ylab("Mean") +
  ggtitle("Faith's Index of Phylogenetic Diversity") +
  facet_grid(~ Lake_Type, space = "free_x", scale="free") +
  theme(axis.title.x = element_text(face="bold", size=10),
        axis.text.x = element_text(angle=0, colour="black", size=8),
        axis.text.y = element_text(colour="black", size=8),
        axis.title.y = element_text(face="bold", size=10),
        plot.title = element_text(face="bold", size=10),
        legend.title = element_text(size=10, face="bold"),
        legend.text = element_text(size = 9),
        strip.text.x = element_blank(),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm")) + # top, right, bottom, left
  geom_text(data = ann.pd.frac, aes(x = c(1,1,1), y=c(5, 5, 5), label = lab), size = 6, color="red")



### Season ###
ann.pd.seas <- data.frame(lab=c("+", " ", "a", "a"),
                       Lake_Type = factor(c("Laurentian", "Estuary", "Inland",
                                            "Inland"),
                                          levels = c("Laurentian", "Estuary",
                                                     "Inland")),
                       Season = factor(c("Spring", "Summer", "Fall", "Spring"),
                                         levels = c("Spring", "Summer", "Fall")))
    
pd.seas.plot <- ggplot(final.pd, aes(x=Lake_Type, y=Stat, fill=Season)) +
  geom_boxplot(position=position_dodge(1)) +
  xlab("Lake Type") + ylab("Mean") +
  ggtitle("Faith's Index of Phylogenetic Diversity") +
  facet_grid(~ Lake_Type, space = "free_x", scale="free") +
  theme(axis.title.x = element_text(face="bold", size=10),
        axis.text.x = element_text(angle=0, colour="black", size=8),
        axis.text.y = element_text(colour="black", size=8),
        axis.title.y = element_text(face="bold", size=10),
        plot.title = element_text(face="bold", size=10),
        legend.title = element_text(size=10, face="bold"),
        legend.text = element_text(size = 9),
        strip.text.x = element_blank(),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm")) + # top, right, bottom, left
  geom_text(data = ann.pd.seas, aes(x = c(1.33,1,0.67,1), y=c(5.15,5.15,5.15,5.15), label = lab), size = 4, color="red")


##### Combine PD Plots #####
tiff("pd.tiff", width = 17.8, height = 7, units = "cm", res = 600)
grid.newpage()
pushViewport(viewport(layout=(grid.layout(1,2, widths=c(1,1), heights=c(0.5,5))))) 
print(pd.frac.plot, vp=viewport(layout.pos.row=1, layout.pos.col=1))
print(pd.seas.plot, vp=viewport(layout.pos.row=1, layout.pos.col=2))
dev.off()


### Plot using Mean & Median
# png("pd.png", width = 8.7, height = 8, units = "cm", res = 600)
# ggplot(final.pd, aes(x = Fraction, y = Stat)) +
#   geom_errorbar(aes(ymin= Mean-SD, ymax=Mean+SD), color = "black", width=.1,
#                 position=position_dodge(1)) +
#   geom_point(data=final.pd, aes(x=Fraction, y=Median), pch=95, size=7) +
#   geom_point(data=final.pd, aes(x=Fraction, y=Mean), pch=126, size=7) +
#   facet_grid(~Lake_Type, scales = "free", space = "free_x") +
#   ylab("Mean") + ggtitle("Faith's Index of Phylogenetic Diversity") +
#   ylim(0,2.5) +
#   theme(axis.title.x = element_text(face="bold", size=10),
#         axis.text.x = element_text(colour = "black", size=7),
#         axis.text.y = element_text(colour = "black", size=10),
#         axis.title.y = element_text(face="bold", size=10),
#         plot.title = element_text(face="bold", size = 10),
#         strip.text.x = element_text(size=10, face="bold"),
#         strip.text.y = element_text(size=10, face="bold"),
#         #legend.title = element_text(size=8, face="bold"),
#         #legend.text = element_text(size = 8),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         strip.background = element_blank(),
#         legend.position="none")
# dev.off()

##### Kruskal-Wallis #####

### Lake Type
kruskal.test(formula = Stat ~ Lake_Type, data = final.pd)
  # All Lake Types
  # p-value = 2.616e-05
kruskal.test(formula = Stat ~ Lake_Type, data = final.pd, subset = Lake_Type != "Laurentian")
  # Estuary vs Inland
  # p-value = 0.9906
kruskal.test(formula = Stat ~ Lake_Type, data = final.pd, subset = Lake_Type != "Estuary")
  # Laurentian vs. Inland
  # p-value = 2.539e-06
kruskal.test(formula = Stat ~ Lake_Type, data = final.pd, subset = Lake_Type != "Inland")
  # Laurentian vs. Estuary
  # p-value = 0.0004496



### Fraction
kruskal.test(formula = Stat ~ Fraction, data = final.pd)
  # All Fraction
  # p-value = 3.932e-09
kruskal.test(formula = Stat ~ Fraction, data = final.pd, subset = Fraction != "Sediment")
  # All Part vs Free
  # p-value = 2.558e-05

# Laurentian
kruskal.test(formula = Stat ~ Fraction, data = final.pd, subset = Lake_Type == "Laurentian")
  # Fraction
  # p-value = 0.0001398

# Estuary
kruskal.test(formula = Stat ~ Fraction, data = final.pd, subset = Lake_Type == "Estuary")
  # Fraction
  # p-value = 1.231e-06
kruskal.test(formula = Stat ~ Fraction, data = final.pd, subset = Lake_Type == "Estuary" & Fraction != "Sediment")
  # Free vs Part
  # p-value = 0.002038
kruskal.test(formula = Stat ~ Fraction, data = final.pd, subset = Lake_Type == "Estuary" & Fraction != "Particle")
  # Free vs Sediment
  # p-value = 1.067e-07
kruskal.test(formula = Stat ~ Fraction, data = final.pd, subset = Lake_Type == "Estuary" & Fraction != "Free")
  # Particle vs Sediment
  # p-value = 0.02786

# Inland
kruskal.test(formula = Stat ~ Fraction, data = final.pd, subset = Lake_Type == "Inland")
  # Fraction
  # p-value = 0.06875



### Season
kruskal.test(formula = Stat ~ Season, data = final.pd)
  # All Season
  # p-value = 0.3741

# Laurentian
kruskal.test(formula = Stat ~ Season, data = final.pd, subset = Lake_Type == "Laurentian")
  # Season
  # p-value = 6.1e-05
kruskal.test(formula = Stat ~ Season, data = final.pd, subset = Lake_Type == "Laurentian" & Season != "Spring")
  # Summer vs Fall
  # p-value = 2.389e-05
kruskal.test(formula = Stat ~ Season, data = final.pd, subset = Lake_Type == "Laurentian" & Season != "Summer")
  # Spring vs Fall
  # p-value = 0.0007715
kruskal.test(formula = Stat ~ Season, data = final.pd, subset = Lake_Type == "Laurentian" & Season != "Fall")
  # Spring vs Summer
  # p-value = 1

# Estuary
kruskal.test(formula = Stat ~ Season, data = final.pd, subset = Lake_Type == "Estuary")
  # Season
  # p-value = 0.9316

# Inland
kruskal.test(formula = Stat ~ Season, data = final.pd, subset = Lake_Type == "Inland")
  # Season
  # p-value = 0.06256
kruskal.test(formula = Stat ~ Season, data = final.pd, subset = Lake_Type == "Inland" & Season != "Spring")
  # Summer vs Fall
  # p-value = 0.5188
kruskal.test(formula = Stat ~ Season, data = final.pd, subset = Lake_Type == "Inland" & Season != "Summer")
  # Spring vs Fall
  # p-value = 0.2539
kruskal.test(formula = Stat ~ Season, data = final.pd, subset = Lake_Type == "Inland" & Season != "Fall")
  # Spring vs Summer
  # p-value = 0.01932



### Depth
kruskal.test(formula = Stat ~ Depth, data = final.pd)
  # All Depth
  # p-value = 2.579e-06
kruskal.test(formula = Stat ~ Depth, data = final.pd, subset = Depth != "Sediment")
  # All Top vs Bottom
  # p-value = 0.02536

# Laurentian
kruskal.test(formula = Stat ~ Depth, data = final.pd, subset = Lake_Type == "Laurentian")
  # Depth
  # p-value = 0.1273

# Estuary
kruskal.test(formula = Stat ~ Depth, data = final.pd, subset = Lake_Type == "Estuary")
  # Depth
  # p-value = 0.0001166
kruskal.test(formula = Stat ~ Depth, data = final.pd, subset = Lake_Type == "Estuary" & Depth != "Sediment")
  # Top vs Bottom
  # p-value = 0.2154
kruskal.test(formula = Stat ~ Depth, data = final.pd, subset = Lake_Type == "Estuary" & Depth != "Top")
  # Bottom vs Sediment
  # p-value = 0.001097
kruskal.test(formula = Stat ~ Depth, data = final.pd, subset = Lake_Type == "Estuary" & Depth != "Bottom")
  # Top vs Sediment
  # p-value =2.445e-05

# Inland
kruskal.test(formula = Stat ~ Depth, data = final.pd, subset = Lake_Type == "Inland")
  # Depth
  # p-value = 0.4849
```


### NMDS (Bray-Curtis)
```{r}
# After comparing NMDS/PCoA & Bray-Curtis/Sorensen, I went with PCoA Bray-Curtis, so this code is now commented out

# # Create ordination from phyloseq object
# nmds.bray <- ordinate(
#   physeq = Ver.rel, 
#   method = "NMDS", 
#   distance = "bray"
# )
#     # Stress = 0.2112829

### Plot
## Color = Depth, Shape = Lake_Type
# plot_ordination(
#   physeq = Ver.rel,
#   ordination = nmds.bray,
#   color = "Depth",
#   shape = "Lake_Type") + 
#   scale_color_manual(values = c("indianred1","green3","mediumpurple2", "skyblue")) +
#   scale_shape_manual(values = c(15,17,16)) +
#   theme(axis.text.x = element_blank(), 
#         axis.text.y = element_blank(),
#         axis.title.x = element_text(face="bold", size=14),
#         axis.title.y = element_text(face="bold", size=14),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size=12),
#         axis.ticks = element_blank(),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         plot.title = element_text(size = 16, face="bold")) +
#   guides(color = guide_legend(order=1, override.aes=list(size=3)),
#          shape = guide_legend(order=2, override.aes=list(size=3))) 


### Plot
## Color = Lake_Type, Shape = Depth
# bray.nmds.Lake_Type.depth <- plot_ordination(
#   physeq = Ver.rel,
#   ordination = nmds.bray,
#   color = "Lake_Type",
#   shape = "Depth") + 
#   scale_color_manual(values = c("indianred1","deepskyblue","mediumpurple2")) +
#   ggtitle("Bray-Curtis Dissimilarity") +
#   theme(axis.text.x = element_blank(), 
#         axis.text.y = element_blank(),
#         axis.title.x = element_text(face="bold", size=14),
#         axis.title.y = element_text(face="bold", size=14),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size=12),
#         axis.ticks = element_blank(),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         plot.title = element_text(size = 16, face="bold")) +
#   guides(color = guide_legend(order=1, override.aes=list(size=3)),
#          shape = guide_legend(order=2, override.aes=list(size=3))) 


### Plot
## Color = Fraction, Shape = Lake_Type
# plot_ordination(
#   physeq = Ver.rel,
#   ordination = nmds.bray,
#   color = "Fraction",
#   shape = "Depth") + 
#   scale_color_manual(values = c("indianred1","deepskyblue","mediumpurple2")) +
#   theme(axis.text.x = element_blank(), 
#         axis.text.y = element_blank(),
#         axis.title.x = element_text(face="bold", size=14),
#         axis.title.y = element_text(face="bold", size=14),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size=12),
#         axis.ticks = element_blank(),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         plot.title = element_text(size = 16, face="bold")) +
#   guides(color = guide_legend(order=1, override.aes=list(size=3)),
#          shape = guide_legend(order=2, override.aes=list(size=3))) 


### Plot
## Color = Season, Shape = Lake_Type
# plot_ordination(
#   physeq = Ver.rel,
#   ordination = nmds.bray,
#   color = "Season",
#   shape = "Lake_Type") + 
#   scale_color_manual(values = c("indianred1","deepskyblue","mediumpurple2")) +
#   scale_shape_manual(values = c(15,17,16)) +
#   theme(axis.text.x = element_blank(), 
#         axis.text.y = element_blank(),
#         axis.title.x = element_text(face="bold", size=14),
#         axis.title.y = element_text(face="bold", size=14),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size=12),
#         axis.ticks = element_blank(),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         plot.title = element_text(size = 16, face="bold")) +
#   guides(color = guide_legend(order=1, override.aes=list(size=3)),
#          shape = guide_legend(order=2, override.aes=list(size=3))) 


### Plot 
## Facet = Lake_Type, Color = Fraction, Shape = Season
# plot_ordination(
#   physeq = Ver.rel,
#   ordination = nmds.bray,
#   color = "Fraction",
#   shape = "Season") + 
#   scale_color_manual(values = c("blue3","gold","tan3")) +
#   facet_wrap(facets = ~Lake_Type) +
#   theme(axis.text.x = element_blank(), 
#         axis.text.y = element_blank(),
#         axis.title.x = element_text(face="bold", size=14),
#         axis.title.y = element_text(face="bold", size=14),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size=12),
#         axis.ticks = element_blank(),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         plot.title = element_text(size = 16, face="bold")) +
#   guides(color = guide_legend(order=1, override.aes=list(size=3)),
#          shape = guide_legend(order=2, override.aes=list(size=3))) 
  

### Plot
## Facet = Lake_Type, Color = Season, Shape = Fraction
# bray.nmds.facet <- plot_ordination(
#   physeq = Ver.rel,
#   ordination = nmds.bray,
#   color = "Season",
#   shape = "Fraction") + 
#   scale_color_manual(values = c("indianred1","deepskyblue","mediumpurple2")) +
#   facet_wrap(facets = ~Lake_Type) +
#   ggtitle("Bray-Curtis Dissimilarity") +
#   theme(axis.text.x = element_blank(), 
#         axis.text.y = element_blank(),
#         axis.title.x = element_text(face="bold", size=14),
#         axis.title.y = element_text(face="bold", size=14),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size=12),
#         axis.ticks = element_blank(),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         plot.title = element_text(size = 16, face="bold")) +
#   guides(color = guide_legend(order=1, override.aes=list(size=3)),
#          shape = guide_legend(order=2, override.aes=list(size=3))) 

```



### NMDS (Sorensen)
``` {r}
# After comparing NMDS/PCoA & Bray-Curtis/Sorensen, I went with PCoA Bray-Curtis, so this code is now commented out
# nowinOTU.df <- data.frame(otu_table(Ver.rel))
# 
# # Create Sorensen ordination
# nmds.soren <- metaMDS(nowinOTU.df, distance="bray", binary=TRUE)
#   # stress = 0.1934691 
# nmds.soren <- data.frame(nmds.soren$points)
# nmds.soren$names <- row.names(nmds.soren)
# 
# # Add sample data to sorensen object
# nowinSamp <- data.frame(sample_data(Ver.rel))
# nmds.soren$Lake_Type <- nowinSamp$Lake_Type
# nmds.soren$Lake <- nowinSamp$Lake
# nmds.soren$Date <- nowinSamp$Date
# nmds.soren$Site <- nowinSamp$Site
# nmds.soren$Depth <- nowinSamp$Depth
# nmds.soren$Fraction <- nowinSamp$Fraction
# nmds.soren$Season <- nowinSamp$Season
# 
# 
# ### Plot
# ## Color = Depth, Shape = Lake_Type
# ggplot(nmds.soren, aes(MDS1*10, MDS2*10, color=Depth, shape = Lake_Type,)) +
#   xlab("NMDS1") + ylab("NMDS2") + ggtitle("Sorensen Dissimilarity") +
#   geom_point(size = 2, alpha = 1) + theme_bw() +
#   scale_color_manual(name = "Depth", breaks = c("Top", "DCM", "Bottom", "Sediment"),
#                      labels = c("Top", "DCM", "Bottom", "Sediment"),
#                      values = c("indianred1","green3","mediumpurple2", "skyblue")) +
#   scale_shape_manual(name = "Lake_Type", breaks = c("Laurentian","Estuary","Inland"),
#                      labels = c("Laurentian","Estuary","Inland"),
#                      values = c(15,17,16)) +
#   theme(axis.text.x = element_blank(), 
#         axis.text.y = element_blank(),
#         axis.title.x = element_text(face="bold", size=14),
#         axis.title.y = element_text(face="bold", size=14),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size=12),
#         axis.ticks = element_blank(),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         plot.title = element_text(size = 16, face="bold")) +
#   guides(color = guide_legend(order=1, override.aes=list(size=3)),
#          shape = guide_legend(order=2, override.aes=list(size=3))) 
# 
# 
# ### Plot
# ## Color = Lake_Type, Shape = Depth
# soren.nmds.Lake_Type.depth <- ggplot(nmds.soren, aes(MDS1*10, MDS2*10, color=Lake_Type, shape = Depth,)) +
#   xlab("NMDS1") + ylab("NMDS2") + ggtitle("Sorensen Dissimilarity") +
#   geom_point(size = 2, alpha = 1) + theme_bw() +
#   scale_color_manual(values = c("indianred1","deepskyblue","mediumpurple2")) +
#   theme(axis.text.x = element_blank(), 
#         axis.text.y = element_blank(),
#         axis.title.x = element_text(face="bold", size=14),
#         axis.title.y = element_text(face="bold", size=14),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size=12),
#         axis.ticks = element_blank(),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         plot.title = element_text(size = 16, face="bold")) +
#   guides(color = guide_legend(order=1, override.aes=list(size=3)),
#          shape = guide_legend(order=2, override.aes=list(size=3))) 
# 
# 
# 
# ### Plot
# ## Color = Fraction, Shape = Depth
# ggplot(nmds.soren, aes(MDS1*10, MDS2*10, color=Fraction, shape = Depth,)) +
#   xlab("NMDS1") + ylab("NMDS2") + ggtitle("Sorensen Dissimilarity") +
#   geom_point(size = 2, alpha = 1) + theme_bw() +
#   scale_color_manual(values = c("indianred1","deepskyblue","mediumpurple2")) +
#   scale_shape_manual(values = c(17, 5, 16, 4)) +
#   theme(axis.text.x = element_blank(), 
#         axis.text.y = element_blank(),
#         axis.title.x = element_text(face="bold", size=14),
#         axis.title.y = element_text(face="bold", size=14),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size=12),
#         axis.ticks = element_blank(),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         plot.title = element_text(size = 16, face="bold")) +
#   guides(color = guide_legend(order=1, override.aes=list(size=3)),
#          shape = guide_legend(order=2, override.aes=list(size=3))) 
# 
# # Plot
# ## Facet = Lake_Type, Color = Fraction, Shape = Season
# ggplot(nmds.soren, aes(MDS1*10, MDS2*10, color=Fraction, shape = Season,)) +
#   xlab("NMDS1") + ylab("NMDS2") + ggtitle("Sorensen Dissimilarity") +
#   geom_point(size = 2, alpha = 1) + theme_bw() +
#   facet_grid(.~Lake_Type) +
#   scale_color_manual(values = c("blue3","gold", "tan3")) +
#   scale_shape_manual(values = c(17, 16, 15)) +
#   theme(axis.text.x = element_blank(), 
#         axis.text.y = element_blank(),
#         axis.title.x = element_text(face="bold", size=14),
#         axis.title.y = element_text(face="bold", size=14),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size=12),
#         axis.ticks = element_blank(),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         plot.title = element_text(size = 16, face="bold")) +
#   guides(color = guide_legend(order=1, override.aes=list(size=3)),
#          shape = guide_legend(order=2, override.aes=list(size=3)))
# 
# 
# ### Plot
# ## Facet = Lake_Type, Color = Season, Shape = Fraction
# soren.nmds.facet <- ggplot(nmds.soren, aes(MDS1*10, MDS2*10, color=Season, shape = Fraction,)) +
#   xlab("NMDS1") + ylab("NMDS2") + ggtitle("Sorensen Dissimilarity") +
#   geom_point(size = 2, alpha = 1) + theme_bw() +
#   facet_grid(.~Lake_Type) +
#   scale_color_manual(values = c("indianred1","deepskyblue","mediumpurple2")) +
#   scale_shape_manual(values = c(16, 17, 15)) +
#   theme(axis.text.x = element_blank(), 
#         axis.text.y = element_blank(),
#         axis.title.x = element_text(face="bold", size=14),
#         axis.title.y = element_text(face="bold", size=14),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size=12),
#         axis.ticks = element_blank(),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         plot.title = element_text(size = 16, face="bold")) +
#   guides(color = guide_legend(order=1, override.aes=list(size=3)),
#          shape = guide_legend(order=2, override.aes=list(size=3)))

```



### Create NMDS comparison plots
```{r}
# After comparing NMDS/PCoA & Bray-Curtis/Sorensen, I went with PCoA Bray-Curtis, so this code is now commented out
#tiff("nmds.compare.tiff", width = 14, height = 10, units = "in", res = 500)
# grid.newpage()
# pushViewport(viewport(layout=(grid.layout(2,2, widths=c(1,1), heights=c(1.5,1.5)))))
# print(bray.nmds.Lake_Type.depth, vp=viewport(layout.pos.row=1, layout.pos.col=1))
# print(bray.nmds.facet, vp=viewport(layout.pos.row=1, layout.pos.col=2))
# print(soren.nmds.Lake_Type.depth, vp=viewport(layout.pos.row=2, layout.pos.col=1))
# print(soren.nmds.facet, vp=viewport(layout.pos.row=2, layout.pos.col=2))
#dev.off()

### Bray-Curtis seems to cluster a bit more clearly than Sorensen

```







### PCoA (Bray-Curtis)
```{r}
# Calculate bray-curtis dissimilarity from phyloseq object
Ver.bray <- phyloseq::distance(physeq = Ver.rel, method = "bray")

# Performs ordination on phyloseq object
Ver.pcoa <- ordinate(physeq = Ver.rel, method = "PCoA", distance = "bray")


#To determine approximately how much variation the axes should explain:
#Ver.pcoa$values
#look for broken stick value

### Plot
## Depth
# plot_ordination(
#   physeq = Ver.rel, 
#   ordination = Ver.pcoa, 
#   color = "Depth",
#   axes = c(1, 2),
#   title = "Bray-Curtis Dissimilarity") +
#   scale_color_manual(values = c("indianred1","deepskyblue","mediumpurple2")) +
#   theme(axis.text.x = element_blank(), 
#         axis.text.y = element_blank(),
#         axis.title.x = element_text(face="bold", size=14),
#         axis.title.y = element_text(face="bold", size=14),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size=12),
#         axis.ticks = element_blank(),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         plot.title = element_text(size = 16, face="bold")) +
#   guides(color = guide_legend(order=1, override.aes=list(size=3)),
#          shape = guide_legend(order=2, override.aes=list(size=3)))

### Plot
## Lake_Type
# plot_ordination(
#   physeq = Ver.rel, 
#   ordination = Ver.pcoa, 
#   color = "Lake_Type",
#   axes = c(2,3),
#   title = "Bray-Curtis Dissimilarity") +
#   scale_color_manual(values = c("indianred1","deepskyblue","mediumpurple2")) +
#   theme(axis.text.x = element_blank(), 
#         axis.text.y = element_blank(),
#         axis.title.x = element_text(face="bold", size=14),
#         axis.title.y = element_text(face="bold", size=14),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size=12),
#         axis.ticks = element_blank(),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         plot.title = element_text(size = 16, face="bold")) +
#   guides(color = guide_legend(order=1, override.aes=list(size=3)),
#          shape = guide_legend(order=2, override.aes=list(size=3)))

### Plot
## Color = Lake_Type, Shape = Depth
bray.pcoa.Lake_Type.depth <- plot_ordination(
  physeq = Ver.rel, 
  ordination = Ver.pcoa, 
  color = "Lake_Type",
  shape = "Depth",
  axes = c(2,3),
  title = "Bray-Curtis Dissimilarity") +
  scale_color_manual(values = c("indianred1","deepskyblue","mediumpurple2")) +
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_text(face="bold", size=14),
        axis.title.y = element_text(face="bold", size=14),
        legend.title = element_text(size=12, face="bold"),
        legend.text = element_text(size=12),
        axis.ticks = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        plot.title = element_text(size = 16, face="bold")) +
  guides(color = guide_legend(order=1, override.aes=list(size=3)),
         shape = guide_legend(order=2, override.aes=list(size=3)))

# Fraction PCoA
# plot_ordination(
#   physeq = Ver.rel, 
#   ordination = Ver.pcoa, 
#   color = "Fraction",
#   shape = "Season",
#   axes = c(1, 3),
#   title = "Bray-Curtis Dissimilarity") +
#   facet_wrap(facets = ~Lake_Type) +
#   theme(axis.text.x = element_blank(), 
#         axis.text.y = element_blank(),
#         axis.title.x = element_text(face="bold", size=14),
#         axis.title.y = element_text(face="bold", size=14),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size=12),
#         axis.ticks = element_blank(),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         plot.title = element_text(size = 16, face="bold")) +
#   guides(color = guide_legend(order=1, override.aes=list(size=3)),
#          shape = guide_legend(order=2, override.aes=list(size=3)))

# Season PCoA
bray.pcoa.facet <- plot_ordination(
  physeq = Ver.rel, 
  ordination = Ver.pcoa, 
  color = "Season",
  shape = "Fraction",
  axes = c(1,2),
  title = "Bray-Curtis Dissimilarity") +
  facet_wrap(facets = ~Lake_Type) +
  scale_color_manual(values = c("indianred1","deepskyblue","mediumpurple2")) +
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_text(face="bold", size=14),
        axis.title.y = element_text(face="bold", size=14),
        legend.title = element_text(size=12, face="bold"),
        legend.text = element_text(size=12),
        axis.ticks = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        plot.title = element_text(size = 16, face="bold")) +
  guides(color = guide_legend(order=1, override.aes=list(size=3)),
         shape = guide_legend(order=2, override.aes=list(size=3)))
```



### PCoA (Sorensen)
``` {r}
# After comparing NMDS/PCoA & Bray-Curtis/Sorensen, I went with PCoA Bray-Curtis, so this code is now commented out

# # Calculates sorensen dissimilarity matrix
# test <- dsvdis(nowinOTU.df, index="sorensen")
# # Performs ordination on phyloseq object
# soren.pcoa<- ordinate(physeq = Ver.rel, method = "PCoA", distance = test)
# 
# ### Plot
# ## Depth
# plot_ordination(
#   physeq = Ver.rel, 
#   ordination = soren.pcoa, 
#   color = "Depth",
#   axes = c(1,2),
#   title = "Sorensen Dissimilarity") +
#   theme(axis.text.x = element_blank(), 
#         axis.text.y = element_blank(),
#         axis.title.x = element_text(face="bold", size=14),
#         axis.title.y = element_text(face="bold", size=14),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size=12),
#         axis.ticks = element_blank(),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         plot.title = element_text(size = 16, face="bold"))
# 
# ### Plot
# ## Lake_Type
# plot_ordination(
#   physeq = Ver.rel, 
#   ordination = soren.pcoa, 
#   color = "Lake_Type",
#   axes = c(2,3),
#   title = "Sorensen Dissimilarity") +
#   theme(axis.text.x = element_blank(), 
#         axis.text.y = element_blank(),
#         axis.title.x = element_text(face="bold", size=14),
#         axis.title.y = element_text(face="bold", size=14),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size=12),
#         axis.ticks = element_blank(),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         plot.title = element_text(size = 16, face="bold"))
# 
# 
# ### Plot
# ## Color = Lake_Type, Shape = Depth
# soren.pcoa.Lake_Type.depth <- plot_ordination(
#   physeq = Ver.rel, 
#   ordination = soren.pcoa, 
#   color = "Lake_Type",
#   shape = "Depth",
#   axes = c(2,3),
#   title = "Sorensen Dissimilarity") +
#   scale_color_manual(values = c("indianred1","deepskyblue","mediumpurple2")) +
#   theme(axis.text.x = element_blank(), 
#         axis.text.y = element_blank(),
#         axis.title.x = element_text(face="bold", size=14),
#         axis.title.y = element_text(face="bold", size=14),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size=12),
#         axis.ticks = element_blank(),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         plot.title = element_text(size = 16, face="bold")) +
#   guides(color = guide_legend(order=1, override.aes=list(size=3)),
#          shape = guide_legend(order=2, override.aes=list(size=3)))
# 
# ### Plot
# ## Facet = Lake_Type, Color = Fraction, Shape = Season
# plot_ordination(
#   physeq = Ver.rel, 
#   ordination = soren.pcoa, 
#   color = "Fraction",
#   shape = "Season",
#   axes = c(1, 3),
#   title = "Sorensen Dissimilarity") +
#   facet_wrap(facets = ~Lake_Type) +
#   theme(axis.text.x = element_blank(), 
#         axis.text.y = element_blank(),
#         axis.title.x = element_text(face="bold", size=14),
#         axis.title.y = element_text(face="bold", size=14),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size=12),
#         axis.ticks = element_blank(),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         plot.title = element_text(size = 16, face="bold")) +
#   guides(color = guide_legend(order=1, override.aes=list(size=3)),
#          shape = guide_legend(order=2, override.aes=list(size=3)))
# 
# 
# ### Plot
# ## Facet = Lake_Type, Color = Season, Shape = Fraction
# soren.pcoa.facet <- plot_ordination(
#   physeq = Ver.rel, 
#   ordination = Ver.pcoa, 
#   color = "Season",
#   shape = "Fraction",
#   axes = c(1,2),
#   title = "Sorensen Dissimilarity") +
#   facet_wrap(facets = ~Lake_Type) +
#   scale_color_manual(values = c("indianred1","deepskyblue","mediumpurple2")) +
#   theme(axis.text.x = element_blank(), 
#         axis.text.y = element_blank(),
#         axis.title.x = element_text(face="bold", size=14),
#         axis.title.y = element_text(face="bold", size=14),
#         legend.title = element_text(size=12, face="bold"),
#         legend.text = element_text(size=12),
#         axis.ticks = element_blank(),
#         plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
#         plot.title = element_text(size = 16, face="bold")) +
#   guides(color = guide_legend(order=1, override.aes=list(size=3)),
#          shape = guide_legend(order=2, override.aes=list(size=3)))

```


### Ver PERMANOVA
```{r}
sampledf <- data.frame(sample_data(Ver.rel))

##### Depth #####
adonis(Ver.bray ~ Depth, data=sampledf)
  ## R2 = 0.08797
  ## p-value = 0.001
beta.tax = betadisper(d=Ver.bray, group=sampledf$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 28.00798

# Top vs. Bottom
adonis.tb <- subset_samples(physeq = Ver.rel, Depth != "DCM")
adonis.tb <- subset_samples(physeq = adonis.tb, Depth != "Sediment")
adonis.tb.bray <- phyloseq::distance(physeq = adonis.tb, method = "bray")
adonis.tb <- data.frame(sample_data(adonis.tb))
adonis(adonis.tb.bray ~ Depth, data=adonis.tb)
  # p-value = 0.004
  # R2 = 0.01411
beta.tax = betadisper(d=adonis.tb.bray, group=adonis.tb$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.498
  # F = 0.5144987

# Top vs. Sediment
adonis.ts <- subset_samples(physeq = Ver.rel, Depth != "DCM")
adonis.ts <- subset_samples(physeq = adonis.ts, Depth != "Bottom")
adonis.ts.bray <- phyloseq::distance(physeq = adonis.ts, method = "bray")
adonis.ts <- data.frame(sample_data(adonis.ts))
adonis(adonis.ts.bray ~ Depth, data=adonis.ts)
  # p-value = 0.001
  # R2 = 0.13396
beta.tax = betadisper(d=adonis.ts.bray, group=adonis.ts$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 58.66768

# Bottom vs. Sediment
adonis.bs <- subset_samples(physeq = Ver.rel, Depth != "DCM")
adonis.bs <- subset_samples(physeq = adonis.bs, Depth != "Top")
adonis.bs.bray <- phyloseq::distance(physeq = adonis.bs, method = "bray")
adonis.bs <- data.frame(sample_data(adonis.bs))
adonis(adonis.bs.bray ~ Depth, data=adonis.bs)
  # p-value = 0.001
  # R2 = 0.13453
beta.tax = betadisper(d=adonis.bs.bray, group=adonis.bs$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 47.73623


##### Lake_Type #####
adonis(Ver.bray ~ Lake_Type, data=sampledf)
  ## R2 = 0.10932
  ## p-value = 0.001
beta.tax = betadisper(Ver.bray, sampledf$Lake_Type)
p <- permutest(beta.tax)
p$tab
  ## p-value = 0.77
  ## F = 0.2776733

# Laurentian vs. Estuary
adonis.scaled.le <- subset_samples(physeq = scaled, Lake_Type != "Inland")
adonis.scaled.le.bray <- phyloseq::distance(physeq = adonis.scaled.le, method = "bray")
adonis.scaled.le <- data.frame(sample_data(adonis.scaled.le))
adonis(adonis.scaled.le.bray ~ Lake_Type, data=adonis.scaled.le)
  # p-value = 0.001
  # R2 = 0.09594 
beta.tax = betadisper(d=adonis.scaled.le.bray, group=adonis.scaled.le$Lake_Type)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.092
  # F = 3.061581

# Laurentian vs. Inland
adonis.scaled.li <- subset_samples(physeq = scaled, Lake_Type != "Estuary")
adonis.scaled.li.bray <- phyloseq::distance(physeq = adonis.scaled.li, method = "bray")
adonis.scaled.li <- data.frame(sample_data(adonis.scaled.li))
adonis(adonis.scaled.li.bray ~ Lake_Type, data=adonis.scaled.li)
  # p-value = 0.001
  # R2 = 0.0732
beta.tax = betadisper(d=adonis.scaled.li.bray, group=adonis.scaled.li$Lake_Type)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 13.455

# Estuary vs. Inland
adonis.scaled.ei <- subset_samples(physeq = scaled, Lake_Type != "Laurentian")
adonis.scaled.ei.bray <- phyloseq::distance(physeq = adonis.scaled.ei, method = "bray")
adonis.scaled.ei <- data.frame(sample_data(adonis.scaled.ei))
adonis(adonis.scaled.ei.bray ~ Lake_Type, data=adonis.scaled.ei)
  # p-value = 0.001
  # R2 = 0.06387
beta.tax = betadisper(d=adonis.scaled.ei.bray, group=adonis.scaled.ei$Lake_Type)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.256
  # F = 1.280102





##### Fraction #####
adonis(Ver.bray ~ Fraction, data=sampledf)
  ## p-value = 0.001
  ## R2 = 0.16121
beta.tax = betadisper(Ver.bray, sampledf$Fraction)
p <- permutest(beta.tax)
p$tab
  ## P-value = 0.001
  ## F = 29.83702

# Particle vs. Free
adonis.pf <- subset_samples(physeq = Ver.rel, Fraction != "Sediment")
adonis.pf.bray <- phyloseq::distance(physeq = adonis.pf, method = "bray")
adonis.pf <- data.frame(sample_data(adonis.pf))
adonis(adonis.pf.bray ~ Fraction, data=adonis.pf)
  # p-value = 0.001
  # R2 = 0.09474
beta.tax = betadisper(d=adonis.pf.bray, group=adonis.pf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 23.66752

# Particle vs. Sediment
adonis.ps <- subset_samples(physeq = Ver.rel, Fraction != "Free")
adonis.ps.bray <- phyloseq::distance(physeq = adonis.ps, method = "bray")
adonis.ps <- data.frame(sample_data(adonis.ps))
adonis(adonis.ps.bray ~ Fraction, data=adonis.ps)
  # p-value = 0.001
  # R2 = 0.12536
beta.tax = betadisper(d=adonis.ps.bray, group=adonis.ps$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 58.6663

# Free vs. Sediment
adonis.fs <- subset_samples(physeq = Ver.rel, Fraction != "Particle")
adonis.fs.bray <- phyloseq::distance(physeq = adonis.fs, method = "bray")
adonis.fs <- data.frame(sample_data(adonis.fs))
adonis(adonis.fs.bray ~ Fraction, data=adonis.fs)
  # p-value = 0.001
  # R2 = 0.17969
beta.tax = betadisper(d=adonis.fs.bray, group=adonis.fs$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 19.22966



##### Season #####
adonis(Ver.bray ~ Season, data=sampledf)
  ## p-value = 0.001
  ## R2 = 0.0952
beta.tax = betadisper(Ver.bray, sampledf$Season)
p <- permutest(beta.tax)
p$tab
  ## P-value = 0.008
  ## F = 4.999286

# Spring vs. Summer
adonis.ss <- subset_samples(physeq = Ver.rel, Season != "Fall")
adonis.ss.bray <- phyloseq::distance(physeq = adonis.ss, method = "bray")
adonis.ss <- data.frame(sample_data(adonis.ss))
adonis(adonis.ss.bray ~ Season, data=adonis.ss)
  # p-value = 0.001
  # R2 = 0.09052
beta.tax = betadisper(d=adonis.ss.bray, group=adonis.ss$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 18.14419

# Spring vs. Fall
adonis.sf <- subset_samples(physeq = Ver.rel, Season != "Summer")
adonis.sf.bray <- phyloseq::distance(physeq = adonis.sf, method = "bray")
adonis.sf <- data.frame(sample_data(adonis.sf))
adonis(adonis.sf.bray ~ Season, data=adonis.sf)
  # p-value = 0.001
  # R2 = 0.13916
beta.tax = betadisper(d=adonis.sf.bray, group=adonis.sf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 22.43885

# Summer vs. Fall
adonis.suf <- subset_samples(physeq = Ver.rel, Season != "Spring")
adonis.suf.bray <- phyloseq::distance(physeq = adonis.suf, method = "bray")
adonis.suf <- data.frame(sample_data(adonis.suf))
adonis(adonis.suf.bray ~ Season, data=adonis.suf)
  # p-value = 0.001
  # R2 = 0.02691
beta.tax = betadisper(d=adonis.suf.bray, group=adonis.suf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 20.66774


##### Nested adonis #####
adonis(Ver.bray ~ Lake_Type + Depth + Fraction + Season, data = sampledf)
  ## Lake_Type R2 = 0.10932
  ## Depth R2 = 0.09008
  ## Fraction R2 = 0.08552
  ## Season R2 = 0.07912
  ## all p-values = 0.001



```


### Create PCoA comparison plots
```{r}
# After comparing NMDS/PCoA & Bray-Curtis/Sorensen, I went with PCoA Bray-Curtis, so this code is now commented out

# tiff("pcoa.compare2.tiff", width = 14, height = 10, units = "in", res = 500)
# grid.newpage()
# pushViewport(viewport(layout=(grid.layout(2,2, widths=c(1,1), heights=c(1.5,1.5)))))
# print(bray.pcoa.Lake_Type.depth, vp=viewport(layout.pos.row=1, layout.pos.col=1))
# print(bray.pcoa.facet, vp=viewport(layout.pos.row=1, layout.pos.col=2))
# print(soren.pcoa.Lake_Type.depth, vp=viewport(layout.pos.row=2, layout.pos.col=1))
# print(soren.pcoa.facet, vp=viewport(layout.pos.row=2, layout.pos.col=2))
# dev.off()

### Bray-Curtis seems to cluster a bit more clearly than Sorensen

```



### Ver Lake Type PCoA
```{r}
##### Laurentian #####

# Subset out Laurentian samples
Ver.lau <- subset_samples(Ver.rel, Lake_Type == "Laurentian")

# Calculate bray-curtis dissimilarity
Ver.lau.bray <- phyloseq::distance(physeq = Ver.lau, method = "bray")

# Perform PcoA ordination
Ver.lau.pcoa <- ordinate(physeq = Ver.lau, method = "PCoA", distance = "bray")

### Plot
Ver.lau.ord <- plot_ordination(physeq = Ver.lau, ordination = Ver.lau.pcoa, axes = c(1, 2),
                title= "Bray-Curtis Dissimilarity") + 
  geom_point(size=2, aes(color = Season, shape = Depth,
                         fill = factor(ifelse(Fraction == "Free", NA, Season)),
                         alpha = Fraction)) +
  scale_shape_manual(values = c(21, 24, 22)) +
  scale_fill_discrete(na.value = "white", guide = "none") +
  scale_alpha_manual(values=c("Particle"=1, "Free"=1)) +
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_text(face="bold", size=10),
        axis.title.y = element_text(face="bold", size=10),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size=8),
        axis.ticks = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        plot.title = element_text(size = 10, face="bold")) +
  annotate("text", x= -0.38, y=0.45, label = "A", fontface = "bold", size=6, colour="black") +
  guides(colour=FALSE, shape=FALSE, alpha = FALSE)
  #guides(color = guide_legend(order=1, title="Season", override.aes=list(size=3)),
  #       shape = guide_legend(order=2, title="Depth",override.aes=list(size=3)),
  #       alpha = guide_legend(order=3, title="Fraction",override.aes=list(size=3)))
  
# Particle = fill, Free = empty
# Note: for scale_fill_discrete to work, you MUST set scale_shape_manual to between 21-25; You also can't set colors manually


##### Estuary #####

# Subset out estuary samples
Ver.est <- subset_samples(Ver.rel, Lake_Type == "Estuary")

# Calculate bray-curtis dissimilarity
Ver.est.bray <- phyloseq::distance(physeq = Ver.est, method = "bray")

# Perform PCoA ordination
Ver.est.pcoa <- ordinate(physeq = Ver.est, method = "PCoA", distance = "bray")
  

### Plot
Ver.est.ord <- plot_ordination(physeq = Ver.est, ordination = Ver.est.pcoa, axes = c(1, 2),
                title= "Bray-Curtis Dissimilarity") + 
  geom_point(size=2, aes(color = Season, shape = Depth,
                         fill = factor(ifelse(Fraction == "Free", NA, Season)),
                         alpha = Fraction)) +
  scale_shape_manual(values = c(21, 24, 22)) +
  scale_fill_discrete(na.value = "white", guide = "none") +
  scale_alpha_manual(values=c("Particle"=1, "Free"=1, "Sediment"=0.5)) +
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_text(face="bold", size=10),
        axis.title.y = element_text(face="bold", size=10),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size=8),
        axis.ticks = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        plot.title = element_text(size = 10, face="bold")) +
  annotate("text", x= -0.29, y=0.45, label = "B", fontface = "bold", size=6, colour="black") +
  guides(colour=FALSE, shape=FALSE, alpha = FALSE) 
  #guides(color = guide_legend(order=1, title="Season", override.aes=list(size=3)),
  #       shape = guide_legend(order=2, title="Depth",override.aes=list(size=3)),
  #       alpha = guide_legend(order=3, title="Fraction",override.aes=list(size=3)))


# The function below is to save a legend from a plot, that can then later be called upon and printed
# To use the function, first save a plot as an object
# Then perform the g_legend(plot) function to steal the legend
# Go back to your plot and now remove the legend (guide)
 ##### Let's steal the legend 
 # g_legend <- function(a.gplot){
 #   tmp <- ggplot_gtable(ggplot_build(a.gplot))
 #   leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
 #   legend <- tmp$grobs[[leg]]
 #   return(legend)}
 # legend <- g_legend(Ver.est.ord)

  
##### Inland #####

# Subset out inland samples
Ver.inl <- subset_samples(Ver.rel, Lake_Type == "Inland")

# Calculate bray-curtis dissimilarity
Ver.inl.bray <- phyloseq::distance(physeq = Ver.inl, method = "bray")

# Perform PCoA ordination
Ver.inl.pcoa <- ordinate(physeq = Ver.inl, method = "PCoA", distance = "bray")

### Plot
Ver.inl.ord <- plot_ordination(physeq = Ver.inl, ordination = Ver.inl.pcoa, axes = c(1, 2),
                title= "Bray-Curtis Dissimilarity") + 
  geom_point(size=2, aes(color = Season, shape = Depth,
                         fill = factor(ifelse(Fraction == "Free", NA, Season)),
                         alpha = Fraction)) +
  scale_shape_manual(values = c(21, 24, 22)) +
  scale_fill_discrete(na.value = "white", guide = "none") +
  scale_alpha_manual(values=c("Particle"=1, "Free"=1)) +
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_text(face="bold", size=10),
        axis.title.y = element_text(face="bold", size=10),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size=8),
        axis.ticks = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        plot.title = element_text(size = 10, face="bold")) +
  annotate("text", x= -0.46, y=0.69, label = "C", fontface = "bold", size=6, colour="black") +
  guides(colour=FALSE, shape=FALSE, alpha = FALSE) 
  #guides(color = guide_legend(order=1, title="Season", override.aes=list(size=3)),
  #       shape = guide_legend(order=2, title="Depth",override.aes=list(size=3)),
  #       alpha = guide_legend(order=3, title="Fraction",override.aes=list(size=3)))




#tiff("ver.pcoa.tiff", width = 15, height = 10, units = "cm", res = 500)
#grid.newpage()
#pushViewport(viewport(layout=(grid.layout(1,3, widths=c(1,1,1), heights=c(1,1,1)))))
#print(Ver.lau.ord, vp=viewport(layout.pos.row=1, layout.pos.col=1))
#print(Ver.est.ord, vp=viewport(layout.pos.row=1, layout.pos.col=2))
#print(Ver.inl.ord, vp=viewport(layout.pos.row=1, layout.pos.col=3))
#dev.off()



```





### Ver Lake PERMANOVA
```{r}

########## Laurentian ##########
sampledf <- data.frame(sample_data(Ver.lau))

### Depth
adonis(Ver.lau.bray ~ Depth, data=sampledf)
  # R2 = 0.04999
  # p-value = 0.119
beta.tax = betadisper(d=Ver.lau.bray, group=sampledf$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.028
  # F = 4.689563

### Season
adonis(Ver.lau.bray ~ Season, data=sampledf)
  # R2 = 0.43082
  # p-value = 0.001
beta.tax = betadisper(d=Ver.lau.bray, group=sampledf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 11.22

# Spring vs. Summer
adonis.ss <- subset_samples(physeq = Ver.lau, Season != "Fall")
adonis.ss.bray <- phyloseq::distance(physeq = adonis.ss, method = "bray")
adonis.ss <- data.frame(sample_data(adonis.ss))
adonis(adonis.ss.bray ~ Season, data=adonis.ss)
  # R2 = 0.47247
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ss.bray, group=adonis.ss$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 15.00923

# Spring vs. Fall
adonis.spf <- subset_samples(physeq = Ver.lau, Season != "Summer")
adonis.spf.bray <- phyloseq::distance(physeq = adonis.spf, method = "bray")
adonis.spf <- data.frame(sample_data(adonis.spf))
adonis(adonis.spf.bray ~ Season, data=adonis.spf)
  # R2 = 0.41549
  # p-value = 0.001
beta.tax = betadisper(d=adonis.spf.bray, group=adonis.spf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 15.21934

# Summer vs. Fall
adonis.suf <- subset_samples(physeq = Ver.lau, Season != "Spring")
adonis.suf.bray <- phyloseq::distance(physeq = adonis.suf, method = "bray")
adonis.suf <- data.frame(sample_data(adonis.suf))
adonis(adonis.suf.bray ~ Season, data=adonis.suf)
  # R2 = 0.18953
  # p-value = 0.001
beta.tax = betadisper(d=adonis.suf.bray, group=adonis.suf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.825
  # F = 0.04694171

### Fraction
adonis(Ver.lau.bray ~ Fraction, data=sampledf)
  # R2 = 0.17341
  # p-value = 0.001
beta.tax = betadisper(d=Ver.lau.bray, group=sampledf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.706
  # F = 0.1308235 


### Station
adonis(Ver.lau.bray ~ Station, data=sampledf)
  # R2 = 0.03244
  # p-value = 0.325
beta.tax = betadisper(d=Ver.lau.bray, group=sampledf$Station)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.008
  # F = 8.578097



##### Nested adonis #####
adonis(Ver.lau.bray ~ Fraction + Season + Station + Depth, data = sampledf)
  ## Fraction R2= 0.17341; p-value = 0.001
  ## Season R2= 0.43275; p-value = 0.001
  ## Station R2 = 0.03455; p-value = 0.013
  ## Depth R2= 0.04509; p-value = 0.003
  ## Residuals = 0.31420


########## ESTUARY ##########
sampledf <- data.frame(sample_data(Ver.est))

### Depth
adonis(Ver.est.bray ~ Depth, data=sampledf)
  # R2 = 0.30094
  # p-value = 0.001
beta.tax = betadisper(d=Ver.est.bray, group=sampledf$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.019
  # F = 4.068133

# Water vs. Sediment
adonis(Ver.est.bray ~ Source, data=sampledf)
  # R2 = 0.28633
  # p-value = 0.001
beta.tax = betadisper(d=Ver.est.bray, group=sampledf$Source)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.004
  # F = 9.392686

# Top vs. Bottom
adonis.tb <- subset_samples(physeq = Ver.est, Depth != "Sediment")
adonis.tb.bray <- phyloseq::distance(physeq = adonis.tb, method = "bray")
adonis.tb <- data.frame(sample_data(adonis.tb))
adonis(adonis.tb.bray ~ Depth, data=adonis.tb)
  # R2 = 0.0224
  # p-value = 0.313
beta.tax = betadisper(d=adonis.tb.bray, group=adonis.tb$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.811
  # F = 0.05359156

# Top vs. Sediment
adonis.ts <- subset_samples(physeq = Ver.est, Depth != "Bottom")
adonis.ts.bray <- phyloseq::distance(physeq = adonis.ts, method = "bray")
adonis.ts <- data.frame(sample_data(adonis.ts))
adonis(adonis.ts.bray ~ Depth, data=adonis.ts)
  # R2 = 0.39375
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ts.bray, group=adonis.ts$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.016
  # F = 6.536549

# Bottom vs. Sediment
adonis.bs <- subset_samples(physeq = Ver.est, Depth != "Top")
adonis.bs.bray <- phyloseq::distance(physeq = adonis.bs, method = "bray")
adonis.bs <- data.frame(sample_data(adonis.bs))
adonis(adonis.bs.bray ~ Depth, data=adonis.bs)
  # R2 = 0.39372
  # p-value = 0.001
beta.tax = betadisper(d=adonis.bs.bray, group=adonis.bs$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.009
  # F = 8.668537

### Season
adonis(Ver.est.bray ~ Season, data=sampledf)
  # R2 = 0.21914
  # p-value = 0.001
beta.tax = betadisper(d=Ver.est.bray, group=sampledf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.756
  # F = 0.2979526

# Spring vs. Summer
adonis.ss <- subset_samples(physeq = Ver.est, Season != "Fall")
adonis.ss.bray <- phyloseq::distance(physeq = adonis.ss, method = "bray")
adonis.ss <- data.frame(sample_data(adonis.ss))
adonis(adonis.ss.bray ~ Season, data=adonis.ss)
  # R2 = 0.21356
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ss.bray, group=adonis.ss$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.814
  # F = 0.05572213

# Spring vs. Fall
adonis.spf <- subset_samples(physeq = Ver.est, Season != "Summer")
adonis.spf.bray <- phyloseq::distance(physeq = adonis.spf, method = "bray")
adonis.spf <- data.frame(sample_data(adonis.spf))
adonis(adonis.spf.bray ~ Season, data=adonis.spf)
  # R2 = 0.25881
  # p-value = 0.001
beta.tax = betadisper(d=adonis.spf.bray, group=adonis.spf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.472
  # F = 0.5064546 

# Summer vs. Fall
adonis.suf <- subset_samples(physeq = Ver.est, Season != "Spring")
adonis.suf.bray <- phyloseq::distance(physeq = adonis.suf, method = "bray")
adonis.suf <- data.frame(sample_data(adonis.suf))
adonis(adonis.suf.bray ~ Season, data=adonis.suf)
  # R2 = 0.05553
  # p-value = 0.026
beta.tax = betadisper(d=adonis.suf.bray, group=adonis.suf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.588
  # F = 0.2926064

### Fraction
adonis(Ver.est.bray ~ Fraction, data=sampledf)
  # R2 = 0.4132
  # p-value = 0.001
beta.tax = betadisper(d=Ver.est.bray, group=sampledf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.086
  # F = 2.717009

# Particle vs. Free
adonis.frac <- subset_samples(physeq = Ver.est, Fraction != "Sediment")
adonis.frac.bray <- phyloseq::distance(physeq = adonis.frac, method = "bray")
adonis.frac <- data.frame(sample_data(adonis.frac))
adonis(adonis.frac.bray ~ Fraction, data=adonis.frac)
  # R2 = 0.19446
  # p-value = 0.001
beta.tax = betadisper(d=adonis.frac.bray, group=adonis.frac$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.141
  # F = 2.431074

# Particle vs. Sediment
adonis.ps <- subset_samples(physeq = Ver.est, Fraction != "Free")
adonis.ps.bray <- phyloseq::distance(physeq = adonis.ps, method = "bray")
adonis.ps <- data.frame(sample_data(adonis.ps))
adonis(adonis.ps.bray ~ Fraction, data=adonis.ps)
  # R2 = 0.39181
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ps.bray, group=adonis.ps$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.076
  # F = 3.423727

# Free vs. Sediment
adonis.fs <- subset_samples(physeq = Ver.est, Fraction != "Particle")
adonis.fs.bray <- phyloseq::distance(physeq = adonis.fs, method = "bray")
adonis.fs <- data.frame(sample_data(adonis.fs))
adonis(adonis.fs.bray ~ Fraction, data=adonis.fs)
  # R2 = 0.51146
  # p-value = 0.001
beta.tax = betadisper(d=adonis.fs.bray, group=adonis.fs$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.235
  # F = 1.431922

### Station
adonis(Ver.est.bray ~ Station, data=sampledf)
  # R2 = 0.09334
  # p-value = 0.061
beta.tax = betadisper(d=Ver.est.bray, group=sampledf$Station)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.416
  # F = 0.9683466


##### Nested adonis #####
adonis(Ver.est.bray ~ Source + Fraction + Season + Station + Depth, data = sampledf)
  ## Source R2 = 0.28633; p-value = 0.001
  ## Fraction R2 = 0.12687; p-value = 0.001
  ## Season R2 = 0.21772; p-value = 0.001
  ## Station R2 = 0.06930; p-value = 0.001
  ## Depth R2 = 0.01287; p-value = 0.036
  ## Residuals = 0.28691




########## INLAND ##########
sampledf <- data.frame(sample_data(Ver.inl))

### Depth
adonis(Ver.inl.bray ~ Depth, data=sampledf)
  # R2 = 0.03548
  # p-value = 0.002
beta.tax = betadisper(d=Ver.inl.bray, group=sampledf$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.003
  # F = 9.534813

### Season
adonis(Ver.inl.bray ~ Season, data=sampledf)
  # R2 = 0.07723
  # p-value = 0.001
beta.tax = betadisper(d=Ver.inl.bray, group=sampledf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.002
  # F = 8.038783

# Spring vs. Summer
adonis.ss <- subset_samples(physeq = Ver.inl, Season != "Fall")
adonis.ss.bray <- phyloseq::distance(physeq = adonis.ss, method = "bray")
adonis.ss <- data.frame(sample_data(adonis.ss))
adonis(adonis.ss.bray ~ Season, data=adonis.ss)
  # R2 = 0.06701
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ss.bray, group=adonis.ss$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 16.4969

# Spring vs. Fall
adonis.spf <- subset_samples(physeq = Ver.inl, Season != "Summer")
adonis.spf.bray <- phyloseq::distance(physeq = adonis.spf, method = "bray")
adonis.spf <- data.frame(sample_data(adonis.spf))
adonis(adonis.spf.bray ~ Season, data=adonis.spf)
  # R2 = 0.17293
  # p-value = 0.001
beta.tax = betadisper(d=adonis.spf.bray, group=adonis.spf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.42
  # F = 0.7247857

# Summer vs. Fall
adonis.suf <- subset_samples(physeq = Ver.inl, Season != "Spring")
adonis.suf.bray <- phyloseq::distance(physeq = adonis.suf, method = "bray")
adonis.suf <- data.frame(sample_data(adonis.suf))
adonis(adonis.suf.bray ~ Season, data=adonis.suf)
  # R2 = 0.02092
  # p-value = 0.019
beta.tax = betadisper(d=adonis.suf.bray, group=adonis.suf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.042
  # F = 4.181126

### Fraction
adonis(Ver.inl.bray ~ Fraction, data=sampledf)
  # R2 = 0.11226
  # p-value = 0.001
beta.tax = betadisper(d=Ver.inl.bray, group=sampledf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.006
  # F = 8.083098

##### Nested adonis #####
adonis(Ver.inl.bray ~ Fraction + Season + Lake + Depth, data = sampledf)
  ## Fraction R2= 0.11226; p-value = 0.001
  ## Season R2= 0.07723; p-value = 0.001
  ## Lake R2= 0.27145; p-value = 0.001
  ## Depth R2= 0.03532; p-value = 0.001
  ## Residuals = 0.50380
```



### Whole Com PCoA
```{r}
# Calculate bray-curtis dissimilarity
scaled.bray <- phyloseq::distance(physeq=scaled, method="bray")

# Perform PCoA ordination
scaled.pcoa <- ordinate(physeq = scaled, method = "PCoA", distance="bray")

### Plot
## Color = Depth, Shape = Lake_Type
plot_ordination(
  physeq = scaled, 
  ordination = scaled.pcoa, 
  color = "Depth",
  shape = "Lake_Type",
  axes = c(1, 2),
  title = "Bray-Curtis Dissimilarity") +
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_text(face="bold", size=14),
        axis.title.y = element_text(face="bold", size=14),
        legend.title = element_text(size=12, face="bold"),
        legend.text = element_text(size=12),
        axis.ticks = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        plot.title = element_text(size = 16, face="bold")) +
  guides(color = guide_legend(order=1, override.aes=list(size=3)),
         shape = guide_legend(order=2, override.aes=list(size=3)))

### Plot
## Color = Lake_Type, Shape = Depth
bcc.pcoa.Lake_Type.depth <- plot_ordination(
  physeq = scaled, 
  ordination = scaled.pcoa, 
  color = "Lake_Type",
  shape = "Depth",
  axes = c(2, 3),
  title = "Bray-Curtis Dissimilarity") +
  scale_y_reverse()+
  scale_color_manual(values = c("indianred1","deepskyblue","mediumpurple2")) +
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_text(face="bold", size=14),
        axis.title.y = element_text(face="bold", size=14),
        legend.title = element_text(size=12, face="bold"),
        legend.text = element_text(size=12),
        axis.ticks = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        plot.title = element_text(size = 16, face="bold")) +
  guides(color = guide_legend(order=1, override.aes=list(size=3)),
         shape = guide_legend(order=2, override.aes=list(size=3)))

### Plot
## Facet = Lake_Type, Color = Season, Shape = Fraction
bcc.pcoa.facet <- plot_ordination(
  physeq = scaled, 
  ordination = scaled.pcoa, 
  color = "Season",
  shape = "Fraction",
  axes = c(1,2),
  title = "Bray-Curtis Dissimilarity") +
  facet_wrap(facets = ~Lake_Type) +
  scale_color_manual(values = c("indianred1","deepskyblue","mediumpurple2")) +
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_text(face="bold", size=14),
        axis.title.y = element_text(face="bold", size=14),
        legend.title = element_text(size=12, face="bold"),
        legend.text = element_text(size=12),
        axis.ticks = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        plot.title = element_text(size = 16, face="bold")) +
  guides(color = guide_legend(order=1, override.aes=list(size=3)),
         shape = guide_legend(order=2, override.aes=list(size=3)))



```




### Whole Com Lake PCoA
```{r}
### Laurentian ###

# Pull out Laurentian samples
scaled.lau <- subset_samples(scaled, Lake_Type == "Laurentian")

# Calculate bray-curtis dissimilarity
scaled.lau.bray <- phyloseq::distance(physeq = scaled.lau, method = "bray")

# Perform PCoA ordination
scaled.lau.pcoa <- ordinate(physeq = scaled.lau, method = "PCoA", distance = "bray")

### Plot
scaled.lau.ord <- plot_ordination(physeq = scaled.lau, ordination = scaled.lau.pcoa, axes = c(1, 2),
                title= "Bray-Curtis Dissimilarity") + 
  geom_point(size=2, aes(color = Season, shape = Depth,
                         fill = factor(ifelse(Fraction == "Free", NA, Season)),
                         alpha = Fraction)) +
  scale_shape_manual(values = c(21, 24, 22)) +
  scale_fill_discrete(na.value = "white", guide = "none") +
  scale_alpha_manual(values=c("Particle"=1, "Free"=1)) +
  #scale_y_reverse() + 
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_text(face="bold", size=10),
        axis.title.y = element_text(face="bold", size=10),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size=8),
        axis.ticks = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        plot.title = element_text(size = 10, face="bold")) +
  scale_y_reverse() + scale_x_reverse() +
  annotate("text", x= 0.42, y=-0.45, label = "D", fontface = "bold", size=6, colour="black") +
  guides(colour=FALSE, shape=FALSE, alpha = FALSE) 
  #guides(color = guide_legend(order=1, title="Season", override.aes=list(size=3)),
  #       shape = guide_legend(order=2, title="Depth",override.aes=list(size=3)),
  #       alpha = guide_legend(order=3, title="Fraction",override.aes=list(size=3)))
# Particle = fill, Free = empty
# Note: for scale_fill_discrete to work, you MUST set scale_shape_manual to between 21-25
#        You also can't set colors manually


### Estuary ###

# Pull out Estuary samples
scaled.est <- subset_samples(scaled, Lake_Type == "Estuary")

# Calculate bray-curtis dissimilarity
scaled.est.bray <- phyloseq::distance(physeq = scaled.est, method = "bray")

# Perform PCoA ordination
scaled.est.pcoa <- ordinate(physeq = scaled.est, method = "PCoA", distance = "bray")
  
### Plot
scaled.est.ord <- plot_ordination(physeq = scaled.est, ordination = scaled.est.pcoa, axes = c(1, 2),
                title= "Bray-Curtis Dissimilarity") + 
  geom_point(size=2, aes(color = Season, shape = Depth,
                         fill = factor(ifelse(Fraction == "Free", NA, Season)),
                         alpha = Fraction)) +
  scale_shape_manual(values = c(21, 24, 22)) +
  scale_fill_discrete(na.value = "white", guide = "none") +
  scale_alpha_manual(values=c("Particle"=1, "Free"=1, "Sediment"=0.5)) +
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_text(face="bold", size=10),
        axis.title.y = element_text(face="bold", size=10),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size=8),
        axis.ticks = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        plot.title = element_text(size = 10, face="bold")) +
  scale_y_reverse() +
  annotate("text", x= -0.24, y=-0.45, label = "E", fontface = "bold", size=6, colour="black") +
  guides(colour=FALSE, shape=FALSE, alpha = FALSE) 
  #guides(color = guide_legend(order=1, title="Season", override.aes=list(size=3)),
  #       shape = guide_legend(order=2, title="Depth",override.aes=list(size=3)),
  #       alpha = guide_legend(order=3, title="Fraction",override.aes=list(size=3)))



  
### Inland ###

# Pull out Inland samples
scaled.inl <- subset_samples(scaled, Lake_Type == "Inland")

# Calculate bray-curtis dissimilarity
scaled.inl.bray <- phyloseq::distance(physeq = scaled.inl, method = "bray")

# Perform PCoA ordination
scaled.inl.pcoa <- ordinate(physeq = scaled.inl, method = "PCoA", distance = "bray")

### Plot
scaled.inl.ord <- plot_ordination(physeq = scaled.inl, ordination = scaled.inl.pcoa, axes = c(1, 2),
                title= "Bray-Curtis Dissimilarity") + 
  geom_point(size=2, aes(color = Season, shape = Depth,
                         fill = factor(ifelse(Fraction == "Free", NA, Season)),
                         alpha = Fraction)) +
  scale_shape_manual(values = c(21, 24, 22)) +
  scale_fill_discrete(na.value = "white", guide = "none") +
  scale_alpha_manual(values=c("Particle"=1, "Free"=1)) +
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_text(face="bold", size=10),
        axis.title.y = element_text(face="bold", size=10),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size=8),
        axis.ticks = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        plot.title = element_text(size = 10, face="bold")) +
  annotate("text", x= -0.37, y=0.6, label = "F", fontface = "bold", size=6, colour="black") +
  guides(colour=FALSE, shape=FALSE, alpha = FALSE) 
  #guides(color = guide_legend(order=1, title="Season", override.aes=list(size=3)),
  #       shape = guide_legend(order=2, title="Depth",override.aes=list(size=3)),
  #       alpha = guide_legend(order=3, title="Fraction",override.aes=list(size=3)))




# tiff("bcc.pcoa.tiff", width = 15, height = 10, units = "cm", res = 500)
# grid.newpage()
# pushViewport(viewport(layout=(grid.layout(1,3, widths=c(1,1,1), heights=c(1,1,1)))))
# print(scaled.lau.ord, vp=viewport(layout.pos.row=1, layout.pos.col=1))
# print(scaled.est.ord, vp=viewport(layout.pos.row=1, layout.pos.col=2))
# print(scaled.inl.ord, vp=viewport(layout.pos.row=1, layout.pos.col=3))
# dev.off()
```


### Big PCoA Figure
```{r}
tiff("pcoa.tiff", width = 17.8, height = 17.8, units = "cm", res = 600)
grid.newpage()
pushViewport(viewport(layout=(grid.layout(3,5, widths=c(1.5,19,19,19,7.5), heights=c(0.7,14,14)))))
grid.text("Laurentian", just=c(0.35, 0.5), vp=viewport(layout.pos.row=1, layout.pos.col=2), gp=gpar(fontsize=12,fontface="bold"))
grid.text("Estuary", just=c(0.35, 0.5), vp=viewport(layout.pos.row=1, layout.pos.col=3), gp=gpar(fontsize=12,fontface="bold"))
grid.text("Inland",  just=c(0.35, 0.5), vp=viewport(layout.pos.row=1, layout.pos.col=4), gp=gpar(fontsize=12,fontface="bold"))
grid.text("Verrucomicrobial Community", rot=90, vp=viewport(layout.pos.row=2, layout.pos.col=1), gp=gpar(fontsize=12,fontface="bold"))
grid.text("Whole Bacterial Community", rot=90, vp=viewport(layout.pos.row=3, layout.pos.col=1), gp=gpar(fontsize=12,fontface="bold"))
print(Ver.lau.ord, vp=viewport(layout.pos.row=2, layout.pos.col=2))
print(Ver.est.ord, vp=viewport(layout.pos.row=2, layout.pos.col=3))
print(Ver.inl.ord, vp=viewport(layout.pos.row=2, layout.pos.col=4))
print(scaled.lau.ord, vp=viewport(layout.pos.row=3, layout.pos.col=2))
print(scaled.est.ord, vp=viewport(layout.pos.row=3, layout.pos.col=3))
print(scaled.inl.ord, vp=viewport(layout.pos.row=3, layout.pos.col=4))
legend$vp <- viewport(layout.pos.row = 1:3, layout.pos.col = 5)
grid.draw(legend)
dev.off()
```


### (More PCoAs)
```{r}
# tiff("bcc.ver.compare2.tiff", width = 14, height = 10, units = "in", res = 500)
# grid.newpage()
# pushViewport(viewport(layout=(grid.layout(2,2, widths=c(1,1), heights=c(1.5,1.5)))))
# print(bray.pcoa.Lake_Type.depth, vp=viewport(layout.pos.row=1, layout.pos.col=1))
# print(bray.pcoa.facet, vp=viewport(layout.pos.row=1, layout.pos.col=2))
# print(bcc.pcoa.Lake_Type.depth, vp=viewport(layout.pos.row=2, layout.pos.col=1))
# print(bcc.pcoa.facet, vp=viewport(layout.pos.row=2, layout.pos.col=2))
# dev.off()

```

### Whole Com PERMANOVA
```{r}
bcc.sampledf <- data.frame(sample_data(scaled))

##### Depth #####
adonis(scaled.bray ~ Depth, data=bcc.sampledf)
  ## R2 = 0.09531
  ## p-value = 0.001
beta.tax = betadisper(d=scaled.bray, group=bcc.sampledf$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 18.0238 

# Top vs. Bottom
adonis.scaled.tb <- subset_samples(physeq = scaled, Depth != "DCM")
adonis.scaled.tb <- subset_samples(physeq = adonis.scaled.tb, Depth != "Sediment")
adonis.scaled.tb.bray <- phyloseq::distance(physeq = adonis.scaled.tb, method = "bray")
adonis.scaled.tb <- data.frame(sample_data(adonis.scaled.tb))
adonis(adonis.scaled.tb.bray ~ Depth, data=adonis.scaled.tb)
  # p-value = 0.002
  # R2 = 0.02071
beta.tax = betadisper(d=adonis.scaled.tb.bray, group=adonis.scaled.tb$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.003
  # F = 9.793284

# Top vs. Sediment
adonis.scaled.ts <- subset_samples(physeq = scaled, Depth != "DCM")
adonis.scaled.ts <- subset_samples(physeq = adonis.scaled.ts, Depth != "Bottom")
adonis.scaled.ts.bray <- phyloseq::distance(physeq = adonis.scaled.ts, method = "bray")
adonis.scaled.ts <- data.frame(sample_data(adonis.scaled.ts))
adonis(adonis.scaled.ts.bray ~ Depth, data=adonis.scaled.ts)
  # p-value = 0.001
  # R2 = 0.14538
beta.tax = betadisper(d=adonis.scaled.ts.bray, group=adonis.scaled.ts$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 19.84845 

# Bottom vs. Sediment
adonis.scaled.bs <- subset_samples(physeq = scaled, Depth != "DCM")
adonis.scaled.bs <- subset_samples(physeq = adonis.scaled.bs, Depth != "Top")
adonis.scaled.bs.bray <- phyloseq::distance(physeq = adonis.scaled.bs, method = "bray")
adonis.scaled.bs <- data.frame(sample_data(adonis.scaled.bs))
adonis(adonis.scaled.bs.bray ~ Depth, data=adonis.scaled.bs)
  # p-value = 0.001
  # R2 = 0.12809
beta.tax = betadisper(d=adonis.scaled.bs.bray, group=adonis.scaled.bs$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 31.08996 


##### Lake_Type #####
adonis(scaled.bray ~ Lake_Type, data=bcc.sampledf)
  ## R2 = 0.09902
  ## p-value = 0.001
beta.tax = betadisper(scaled.bray, bcc.sampledf$Lake_Type)
p <- permutest(beta.tax)
p$tab
  ## p-value = 0.003
  ## F = 5.292305

# Laurentian vs. Estuary
adonis.scaled.le <- subset_samples(physeq = scaled, Lake_Type != "Inland")
adonis.scaled.le.bray <- phyloseq::distance(physeq = adonis.scaled.le, method = "bray")
adonis.scaled.le <- data.frame(sample_data(adonis.scaled.le))
adonis(adonis.scaled.le.bray ~ Lake_Type, data=adonis.scaled.le)
  # p-value = 0.001
  # R2 = 0.09594
beta.tax = betadisper(d=adonis.scaled.le.bray, group=adonis.scaled.le$Lake_Type)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.082
  # F = 3.061581

# Laurentian vs. Inland
adonis.scaled.li <- subset_samples(physeq = Ver.rel, Lake_Type != "Estuary")
adonis.scaled.li.bray <- phyloseq::distance(physeq = adonis.scaled.li, method = "bray")
adonis.scaled.li <- data.frame(sample_data(adonis.scaled.li))
adonis(adonis.scaled.li.bray ~ Lake_Type, data=adonis.scaled.li)
  # p-value = 0.001
  # R2 = 0.08015
beta.tax = betadisper(d=adonis.scaled.li.bray, group=adonis.scaled.li$Lake_Type)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.481
  # F = 0.4470369

# Estuary vs. Inland
adonis.ei <- subset_samples(physeq = Ver.rel, Lake_Type != "Laurentian")
adonis.ei.bray <- phyloseq::distance(physeq = adonis.ei, method = "bray")
adonis.ei <- data.frame(sample_data(adonis.ei))
adonis(adonis.ei.bray ~ Lake_Type, data=adonis.ei)
  # p-value = 0.001
  # R2 = 0.07186
beta.tax = betadisper(d=adonis.ei.bray, group=adonis.ei$Lake_Type)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.763
  # F = 0.09847275 




##### Fraction #####
adonis(scaled.bray ~ Fraction, data=bcc.sampledf)
  ## p-value = 0.001
  ## R2 = 0.21101
beta.tax = betadisper(scaled.bray, bcc.sampledf$Fraction)
p <- permutest(beta.tax)
p$tab
  ## P-value = 0.001
  ## F = 60.67025

# Particle vs. Free
adonis.scaled.pf <- subset_samples(physeq = scaled, Fraction != "Sediment")
adonis.scaled.pf.bray <- phyloseq::distance(physeq = adonis.scaled.pf, method = "bray")
adonis.scaled.pf <- data.frame(sample_data(adonis.scaled.pf))
adonis(adonis.scaled.pf.bray ~ Fraction, data=adonis.scaled.pf)
  # p-value = 0.001
  # R2 = 0.14928
beta.tax = betadisper(d=adonis.scaled.pf.bray, group=adonis.scaled.pf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 105.9411

# Particle vs. Sediment
adonis.scaled.ps <- subset_samples(physeq = scaled, Fraction != "Free")
adonis.scaled.ps.bray <- phyloseq::distance(physeq = adonis.scaled.ps, method = "bray")
adonis.scaled.ps <- data.frame(sample_data(adonis.scaled.ps))
adonis(adonis.scaled.ps.bray ~ Fraction, data=adonis.scaled.ps)
  # p-value = 0.001
  # R2 = 0.12068
beta.tax = betadisper(d=adonis.scaled.ps.bray, group=adonis.scaled.ps$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 45.63044

# Free vs. Sediment
adonis.scaled.fs <- subset_samples(physeq = scaled, Fraction != "Particle")
adonis.scaled.fs.bray <- phyloseq::distance(physeq = adonis.scaled.fs, method = "bray")
adonis.scaled.fs <- data.frame(sample_data(adonis.scaled.fs))
adonis(adonis.scaled.fs.bray ~ Fraction, data=adonis.scaled.fs)
  # p-value = 0.001
  # R2 = 0.22202
beta.tax = betadisper(d=adonis.scaled.fs.bray, group=adonis.scaled.fs$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.106
  # F = 2.668599


##### Season #####
adonis(scaled.bray ~ Season, data=bcc.sampledf)
  ## p-value = 0.001
  ## R2 = 0.0832
beta.tax = betadisper(scaled.bray, bcc.sampledf$Season)
p <- permutest(beta.tax)
p$tab
  ## P-value = 0.025
  ## F = 4.260132

# Spring vs. Summer
adonis.scaled.ss <- subset_samples(physeq = scaled, Season != "Fall")
adonis.scaled.ss.bray <- phyloseq::distance(physeq = adonis.scaled.ss, method = "bray")
adonis.scaled.ss <- data.frame(sample_data(adonis.scaled.ss))
adonis(adonis.scaled.ss.bray ~ Season, data=adonis.scaled.ss)
  # p-value = 0.001
  # R2 = 0.07992
beta.tax = betadisper(d=adonis.scaled.ss.bray, group=adonis.scaled.ss$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 50.16244

# Spring vs. Fall
adonis.scaled.sf <- subset_samples(physeq = scaled, Season != "Summer")
adonis.scaled.sf.bray <- phyloseq::distance(physeq = adonis.scaled.sf, method = "bray")
adonis.scaled.sf <- data.frame(sample_data(adonis.scaled.sf))
adonis(adonis.scaled.sf.bray ~ Season, data=adonis.scaled.sf)
  # p-value = 0.001
  # R2 = 0.10023 
beta.tax = betadisper(d=adonis.scaled.sf.bray, group=adonis.scaled.sf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 30.20449 

# Summer vs. Fall
adonis.scaled.suf <- subset_samples(physeq = scaled, Season != "Spring")
adonis.scaled.suf.bray <- phyloseq::distance(physeq = adonis.scaled.suf, method = "bray")
adonis.scaled.suf <- data.frame(sample_data(adonis.scaled.suf))
adonis(adonis.scaled.suf.bray ~ Season, data=adonis.scaled.suf)
  # p-value = 0.001
  # R2 = 0.02862
beta.tax = betadisper(d=adonis.scaled.suf.bray, group=adonis.scaled.suf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 32.70444


##### Nested adonis #####
adonis(scaled.bray ~ Lake_Type + Depth + Fraction + Season, data = bcc.sampledf)
  ## Lake Type R2 = 0.09902
  ## Depth R2 = 0.09387
  ## Fraction R2 = 0.13366
  ## Season = 0.06705
  ## All p-values = 0.001

# if you rearrange the variables (and include sed as part of frac)....
  ## Fraction R2 = 0.21101
  ## Lake_Type R2 = 0.09730
  ## Season R2 = 0.06683
  ## Depth R2 = 0.01848
  ## All p-values = 0.001

```




### Whole Lake PERMANOVA
```{r bcc.lake.permanova}
########## LAURENTIAN ##########
sampledf <- data.frame(sample_data(scaled.lau))

### Depth
adonis(scaled.lau.bray ~ Depth, data=sampledf)
  # R2 = 0.03723
  # p-value = 0.238
beta.tax = betadisper(d=scaled.lau.bray, group=sampledf$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.849
  # F = 0.03704203

### Season
adonis(scaled.lau.bray ~ Season, data=sampledf)
  # R2 = 0.23951
  # p-value = 0.001
beta.tax = betadisper(d=scaled.lau.bray, group=sampledf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.141
  # F = 2.141275

# Spring vs. Summer
adonis.ss <- subset_samples(physeq = scaled.lau, Season != "Fall")
adonis.ss.bray <- phyloseq::distance(physeq = adonis.ss, method = "bray")
adonis.ss <- data.frame(sample_data(adonis.ss))
adonis(adonis.ss.bray ~ Season, data=adonis.ss)
  # R2 = 0.2255
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ss.bray, group=adonis.ss$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.121
  # F = 2.479235

# Spring vs. Fall
adonis.spf <- subset_samples(physeq = scaled.lau, Season != "Summer")
adonis.spf.bray <- phyloseq::distance(physeq = adonis.spf, method = "bray")
adonis.spf <- data.frame(sample_data(adonis.spf))
adonis(adonis.spf.bray ~ Season, data=adonis.spf)
  # R2 = 0.23554
  # p-value = 0.001
beta.tax = betadisper(d=adonis.spf.bray, group=adonis.spf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.073
  # F = 3.621429

# Summer vs. Fall
adonis.suf <- subset_samples(physeq = scaled.lau, Season != "Spring")
adonis.suf.bray <- phyloseq::distance(physeq = adonis.suf, method = "bray")
adonis.suf <- data.frame(sample_data(adonis.suf))
adonis(adonis.suf.bray ~ Season, data=adonis.suf)
  # R2 = 0.11285
  # p-value = 0.047
beta.tax = betadisper(d=adonis.suf.bray, group=adonis.suf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.918
  # F = 0.01387363

### Fraction
adonis(scaled.lau.bray ~ Fraction, data=sampledf)
  # R2 = 0.34359
  # p-value = 0.001
beta.tax = betadisper(d=scaled.lau.bray, group=sampledf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 52.05048

### Station
adonis(scaled.lau.bray ~ Station, data=sampledf)
  # R2 = 0.04338
  # p-value = 0.182
beta.tax = betadisper(d=scaled.lau.bray, group=sampledf$Station)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.17
  # F = 2.038993


##### Nested adonis #####
adonis(scaled.lau.bray ~ Fraction + Season + Station + Depth, data = sampledf)
  ## Fraction R2= 0.34359; p-value = 0.001
  ## Season R2= 0.24164; p-value = 0.001
  ## Station R2= 0.04492; p-value = 0.007
  ## Depth R2= 0.03424; p-value = 0.010
  ## Residuals = 0.33562


########## ESTUARY ##########
sampledf <- data.frame(sample_data(scaled.est))

### Depth
adonis(scaled.est.bray ~ Depth, data=sampledf)
  # R2 = 0.30522
  # p-value = 0.001
beta.tax = betadisper(d=scaled.est.bray, group=sampledf$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.207
  # F = 1.539821

# Water vs. Sediment
adonis(scaled.est.bray ~ Source, data=sampledf)
  # R2 = 0.28846
  # p-value = 0.001
beta.tax = betadisper(d=scaled.est.bray, group=sampledf$Source)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.084
  # F = 3.271663

# Top vs. Bottom
adonis.tb <- subset_samples(physeq = scaled.est, Depth != "Sediment")
adonis.tb.bray <- phyloseq::distance(physeq = adonis.tb, method = "bray")
adonis.tb <- data.frame(sample_data(adonis.tb))
adonis(adonis.tb.bray ~ Depth, data=adonis.tb)
  # R2 = 0.02693
  # p-value = 0.189
beta.tax = betadisper(d=adonis.tb.bray, group=adonis.tb$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.501
  # F = 0.4961036

# Top vs. Sediment
adonis.ts <- subset_samples(physeq = scaled.est, Depth != "Bottom")
adonis.ts.bray <- phyloseq::distance(physeq = adonis.ts, method = "bray")
adonis.ts <- data.frame(sample_data(adonis.ts))
adonis(adonis.ts.bray ~ Depth, data=adonis.ts)
  # R2 = 0.40019
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ts.bray, group=adonis.ts$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.245
  # F = 1.410866

# Bottom vs. Sediment
adonis.bs <- subset_samples(physeq = scaled.est, Depth != "Top")
adonis.bs.bray <- phyloseq::distance(physeq = adonis.bs, method = "bray")
adonis.bs <- data.frame(sample_data(adonis.bs))
adonis(adonis.bs.bray ~ Depth, data=adonis.bs)
  # R2 = 0.37597
  # p-value = 0.001
beta.tax = betadisper(d=adonis.bs.bray, group=adonis.bs$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.06
  # F = 3.567448

### Season
adonis(scaled.est.bray ~ Season, data=sampledf)
  # R2 = 0.17415
  # p-value = 0.001
beta.tax = betadisper(d=scaled.est.bray, group=sampledf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.756
  # F = 0.2654727

# Spring vs. Summer
adonis.ss <- subset_samples(physeq = scaled.est, Season != "Fall")
adonis.ss.bray <- phyloseq::distance(physeq = adonis.ss, method = "bray")
adonis.ss <- data.frame(sample_data(adonis.ss))
adonis(adonis.ss.bray ~ Season, data=adonis.ss)
  # R2 = 0.18032
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ss.bray, group=adonis.ss$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.856
  # F = 0.02931041

# Spring vs. Fall
adonis.spf <- subset_samples(physeq = scaled.est, Season != "Summer")
adonis.spf.bray <- phyloseq::distance(physeq = adonis.spf, method = "bray")
adonis.spf <- data.frame(sample_data(adonis.spf))
adonis(adonis.spf.bray ~ Season, data=adonis.spf)
  # R2 = 0.18804
  # p-value = 0.001
beta.tax = betadisper(d=adonis.spf.bray, group=adonis.spf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.521
  # F = 0.4368101

# Summer vs. Fall
adonis.suf <- subset_samples(physeq = scaled.est, Season != "Spring")
adonis.suf.bray <- phyloseq::distance(physeq = adonis.suf, method = "bray")
adonis.suf <- data.frame(sample_data(adonis.suf))
adonis(adonis.suf.bray ~ Season, data=adonis.suf)
  # R2 = 0.05209
  # p-value = 0.042
beta.tax = betadisper(d=adonis.suf.bray, group=adonis.suf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.594
  # F = 0.2960811

### Fraction
adonis(scaled.est.bray ~ Fraction, data=sampledf)
  # R2 = 0.41303
  # p-value = 0.001
beta.tax = betadisper(d=scaled.est.bray, group=sampledf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.045
  # F = 3.458586

# Particle vs. Free
adonis.frac <- subset_samples(physeq = scaled.est, Fraction != "Sediment")
adonis.frac.bray <- phyloseq::distance(physeq = adonis.frac, method = "bray")
adonis.frac <- data.frame(sample_data(adonis.frac))
adonis(adonis.frac.bray ~ Fraction, data=adonis.frac)
  # R2 = 0.20022
  # p-value = 0.001
beta.tax = betadisper(d=adonis.frac.bray, group=adonis.frac$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.009
  # F = 6.297787

# Particle vs. Sediment
adonis.ps <- subset_samples(physeq = scaled.est, Fraction != "Free")
adonis.ps.bray <- phyloseq::distance(physeq = adonis.ps, method = "bray")
adonis.ps <- data.frame(sample_data(adonis.ps))
adonis(adonis.ps.bray ~ Fraction, data=adonis.ps)
  # R2 = 0.37385
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ps.bray, group=adonis.ps$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.212
  # F = 1.47037

# Free vs. Sediment
adonis.fs <- subset_samples(physeq = scaled.est, Fraction != "Particle")
adonis.fs.bray <- phyloseq::distance(physeq = adonis.fs, method = "bray")
adonis.fs <- data.frame(sample_data(adonis.fs))
adonis(adonis.fs.bray ~ Fraction, data=adonis.fs)
  # R2 = 0.51092
  # p-value = 0.001
beta.tax = betadisper(d=adonis.fs.bray, group=adonis.fs$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.43
  # F = 0.5958934

### Station
adonis(scaled.est.bray ~ Station, data=sampledf)
  # R2 = 0.09631
  # p-value = 0.04
beta.tax = betadisper(d=scaled.est.bray, group=sampledf$Station)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.554
  # F = 0.7612833


##### Nested adonis #####
adonis(scaled.est.bray ~ Source + Fraction + Season + Station + Depth, data = sampledf)
  ## Source R2= 0.28846; p-value = 0.001
  ## Fraction R2= 0.12457; p-value = 0.001
  ## Season R2= 0.17319; p-value = 0.001
  ## Station R2= 0.07651; p-value = 0.001
  ## Depth R2= 0.1684; p-value = 0.011
  ## Residuals = 0.32043




########## INLAND ##########
sampledf <- data.frame(sample_data(scaled.inl))

### Depth
adonis(scaled.inl.bray ~ Depth, data=sampledf)
  # R2 = 0.03975
  # p-value = 0.001
beta.tax = betadisper(d=scaled.inl.bray, group=sampledf$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 25.05928

### Season
adonis(scaled.inl.bray ~ Season, data=sampledf)
  # R2 = 0.09735
  # p-value = 0.001
beta.tax = betadisper(d=scaled.inl.bray, group=sampledf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 15.04692

# Spring vs. Summer
adonis.ss <- subset_samples(physeq = scaled.inl, Season != "Fall")
adonis.ss.bray <- phyloseq::distance(physeq = adonis.ss, method = "bray")
adonis.ss <- data.frame(sample_data(adonis.ss))
adonis(adonis.ss.bray ~ Season, data=adonis.ss)
  # R2 = 0.08529
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ss.bray, group=adonis.ss$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 30.3471

# Spring vs. Fall
adonis.spf <- subset_samples(physeq = scaled.inl, Season != "Summer")
adonis.spf.bray <- phyloseq::distance(physeq = adonis.spf, method = "bray")
adonis.spf <- data.frame(sample_data(adonis.spf))
adonis(adonis.spf.bray ~ Season, data=adonis.spf)
  # R2 = 0.20982
  # p-value = 0.001
beta.tax = betadisper(d=adonis.spf.bray, group=adonis.spf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.029
  # F = 5.219433

# Summer vs. Fall
adonis.suf <- subset_samples(physeq = scaled.inl, Season != "Spring")
adonis.suf.bray <- phyloseq::distance(physeq = adonis.suf, method = "bray")
adonis.suf <- data.frame(sample_data(adonis.suf))
adonis(adonis.suf.bray ~ Season, data=adonis.suf)
  # R2 = 0.02688
  # p-value = 0.002
beta.tax = betadisper(d=adonis.suf.bray, group=adonis.suf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.065
  # F = 4.040812

### Fraction
adonis(scaled.inl.bray ~ Fraction, data=sampledf)
  # R2 = 0.17221
  # p-value = 0.001
beta.tax = betadisper(d=scaled.inl.bray, group=sampledf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 26.48775

##### Nested adonis #####
adonis(scaled.inl.bray ~ Fraction + Season + Lake + Depth, data = sampledf)
  ## Fraction R2= 0.17221; p-value = 0.001
  ## Season R2= 0.09735; p-value = 0.001
  ## Lake R2 = 0.21003; p-value = 0.001
  ## Depth R2= 0.04004; p-value = 0.001
  ## Residuals = 0.48033
```




### Procrustes (Ver vs Whole Community)
```{r}
# Calculate procrustes based on specified axes of Bray-Curtis PCoA
# The 2nd object is rotated to fit the 1st object
# In this case, I'm rotating the Verruco ordination to fit the Whole Com ordination
procrust <- procrustes(scaled.pcoa$vectors[,1:2], Ver.pcoa$vectors[,1:2],
                       scale=FALSE, symmetric=FALSE)
  # Sum of squares = 9.923
plot(procrust)
plot(procrust,kind=2)
# Test significance between your 2 configurations
pro <- protest(scaled.pcoa$vectors[,1:2], Ver.pcoa$vectors[,1:2])
  # p-value = 0.001
  # m12^2 (sum of squares) = 0.4007
  # correlation = 0.7741
plot(pro)



### Prepare to make a prettier Procrustes plot
# http://stackoverflow.com/questions/30325739/ggplot2-for-procrustes-rotation-in-vegan
# Create dataframe for plotting
pro.df <- data.frame(rda1=procrust$Yrot[,1], rda2=procrust$Yrot[,2],
                         xrda1=procrust$X[,1], xrda2=procrust$X[,2])
  # rda1 = Verruco x coordinate
  # rda2 = Verruco y coordinate
  # xrda1 = Whole Community x coordinate
  # xrda2 = Whole community y coordinate
pro.df$Depth <- sample_data(Ver)$Depth
pro.df$Lake_Type <- sample_data(Ver)$Lake_Type
pro.df$Fraction <- sample_data(Ver)$Fraction
pro.df$Season <- sample_data(Ver)$Season

### Plot!
# Basic
ggplot(pro.df) + 
  #geom_point(aes(x=rda1,y=rda2)) + 
  geom_point(aes(x=xrda1, y=xrda2)) +
  geom_segment(aes(x=rda1, y=rda2, xend=xrda1, yend=xrda2), arrow=arrow(length=unit(0.2,"cm")),
               color="burlywood", alpha=0.5) + facet_grid(~Lake_Type)


### Facet = Lake_Type, Color = Depth, Shape = Fraction
ggplot(pro.df) +
  #geom_point(aes(x=rda1, y=rda2, color=Depth, shape=Fraction)) +
  geom_point(aes(x=xrda1, y=xrda2, color=Depth, shape=Fraction)) +
  geom_segment(aes(x=rda2, y=rda2, xend=xrda1, yend=xrda2),
               arrow=arrow(length=unit(0.2,"cm")), color="burlywood", alpha=0.5) +
  facet_grid(~Lake_Type) +
  scale_color_manual(values = c("indianred1","green3","mediumpurple2", "skyblue")) +
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_text(face="bold", size=12),
        axis.title.y = element_text(face="bold", size=12),
        legend.title = element_text(size=10, face="bold"),
        legend.text = element_text(size=10),
        axis.ticks = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        plot.title = element_text(size = 12, face="bold")) +
  guides(color = guide_legend(order=1, override.aes=list(size=3)),
         shape = guide_legend(order=2, override.aes=list(size=3)))


### Facet = Lake_Type, Color = Fraction, Shape = Season

# This is the annotation text for the plot below (plot)
# Since the plot is facetted and you have different text in each facet, you have to use geom_text and call on the dataframe made below (ann_text)
ann_text <- data.frame(lab=c("correlation=0.813","correlation=0.953","correlation=0.797"), Lake_Type = factor(c("Laurentian", "Estuary", "Inland"),levels = c("Laurentian","Estuary","Inland")))

plot <- ggplot(pro.df) +
  #geom_point(aes(x=rda1, y=rda2, color=Fraction, shape=Season)) +
  geom_point(size=1, aes(x=xrda1, y=xrda2, fill=Fraction, shape=Season), color="black") +
  geom_segment(aes(x=rda2, y=rda2, xend=xrda1, yend=xrda2, color=Fraction),
               arrow=arrow(length=unit(0.2,"cm")), alpha=0.4, show.legend=FALSE) +
  facet_grid(~Lake_Type) +
  theme(strip.text.x = element_text(size = 8)) +
  scale_fill_manual(values = c("indianred1","skyblue","mediumpurple2")) +
  scale_color_manual(values = c("indianred1","skyblue","mediumpurple2")) +
  scale_shape_manual(values = c(21,24,22)) +
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_text(face="bold", size=10),
        axis.title.y = element_text(face="bold", size=10),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size=8),
        axis.ticks = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        plot.title = element_text(size = 10, face="bold")) +
  xlab("Axis.1") + ylab("Axis.2") + 
  annotate("text", x= -0.25, y=0.38, label = "p-value=0.001", size=3,
           colour="black") +
  geom_text(data = ann_text,aes(label=lab), x=c(-0.21,-0.21,-0.21),
            y=c(0.34,0.34,0.34), size=3) +
  guides(color = F, shape = F, fill=F)
  #guides(color = guide_legend(order=1, override.aes=list(size=2)),
  #       shape = guide_legend(order=2, override.aes=list(size=2)))


# The function below is to save a legend from a plot, that can then later be called upon and printed
# To use the function, first save a plot as an object
# Then perform the g_legend(plot) function to steal the legend
# Go back to your plot and now remove the legend (guide)
 ##### Let's steal the legend 
  g_legend <- function(a.gplot){
    tmp <- ggplot_gtable(ggplot_build(a.gplot))
    leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
    legend <- tmp$grobs[[leg]]
    return(legend)}
  legend <- g_legend(plot)


png("procrustes.png", width = 17.8, height = 10, units = "cm", res = 600)
grid.newpage()
pushViewport(viewport(layout=(grid.layout(1,2, widths=c(7,0.9), heights=c(1)))))
print(plot, vp=viewport(layout.pos.row=1, layout.pos.col=1))
legend$vp <- viewport(layout.pos.row = 1, layout.pos.col = 2)
grid.draw(legend)
dev.off()

```



### Lake Procrustes Analyses (Verruco vs. Whole Community)
```{r}
##### Laurentian #####
# Calculate procrustes based on specified axes of Bray-Curtis PCoA
# The 2nd object is rotated to fit the 1st object
# In this case, I'm rotating the Verruco ordination to fit the Whole Com ordination
procrust.lau <- procrustes(scaled.lau.pcoa$vectors[,1:2],
                           Ver.lau.pcoa$vectors[,1:2], scale=FALSE, symmetric=FALSE)
  # Sum of squares = 1.901
plot(procrust.lau)
plot(procrust.lau,kind=2)
pro.lau <- protest(scaled.lau.pcoa$vectors[,1:2], Ver.lau.pcoa$vectors[,1:2])
  # p-value = 0.001
  # m12^2 (sum of squares) = 0.3399
  # correlation = 0.8125
plot(pro.lau)

# Create dataframe for plotting
pro.lau.df <- data.frame(rda1=procrust.lau$Yrot[,1], rda2=procrust.lau$Yrot[,2],
                         xrda1=procrust.lau$X[,1], xrda2=procrust.lau$X[,2])
  # rda1 = Verruco x coordinate
  # rda2 = Verruco y coordinate
  # xrda1 = Whole Community x coordinate
  # xrda2 = Whole community y coordinate
pro.lau.df$Depth <- sample_data(Ver.lau)$Depth
pro.lau.df$Lake_Type <- sample_data(Ver.lau)$Lake_Type
pro.lau.df$Fraction <- sample_data(Ver.lau)$Fraction
pro.lau.df$Season <- sample_data(Ver.lau)$Season

### Plot!
# Basic
ggplot(pro.lau.df) + 
  #geom_point(aes(x=rda1,y=rda2)) + 
  geom_point(aes(x=xrda1, y=xrda2)) +
  geom_segment(aes(x=rda1, y=rda2, xend=xrda1, yend=xrda2), arrow=arrow(length=unit(0.2,"cm")),
               color="burlywood", alpha=0.5)




##### Estuary #####
# Calculate procrustes based on specified axes of Bray-Curtis PCoA
# The 2nd object is rotated to fit the 1st object
# In this case, I'm rotating the Verruco ordination to fit the Whole Com ordination
procrust.est <- procrustes(scaled.est.pcoa$vectors[,1:2], Ver.est.pcoa$vectors[,1:2], scale=FALSE,
                       symmetric=FALSE)
  # Sum of squares = 1.05
plot(procrust.est)
plot(procrust.est,kind=2)
pro.est <- protest(scaled.est.pcoa$vectors[,1:2], Ver.est.pcoa$vectors[,1:2])
  # p-value = 0.001
  # m12^2 (sum of squares) = 0.092233
  # correlation = 0.9528
plot(pro.est)

# Create dataframe for plotting
pro.est.df <- data.frame(rda1=procrust.est$Yrot[,1], rda2=procrust.est$Yrot[,2],
                         xrda1=procrust.est$X[,1], xrda2=procrust.est$X[,2])
  # rda1 = Verruco x coordinate
  # rda2 = Verruco y coordinate
  # xrda1 = Whole Community x coordinate
  # xrda2 = Whole community y coordinate
pro.est.df$Depth <- sample_data(Ver.est)$Depth
pro.est.df$Lake_Type <- sample_data(Ver.est)$Lake_Type
pro.est.df$Fraction <- sample_data(Ver.est)$Fraction
pro.est.df$Season <- sample_data(Ver.est)$Season


### Plot!
# Basic
ggplot(pro.est.df) + 
  #geom_point(aes(x=rda1,y=rda2)) + 
  geom_point(aes(x=xrda1, y=xrda2)) +
  geom_segment(aes(x=rda1, y=rda2, xend=xrda1, yend=xrda2), arrow=arrow(length=unit(0.2,"cm")),
               color="burlywood", alpha=0.5)



##### Inland #####
# Calculate procrustes based on specified axes of Bray-Curtis PCoA
# The 2nd object is rotated to fit the 1st object
# In this case, I'm rotating the Verruco ordination to fit the Whole Com ordination
procrust.inl <- procrustes(scaled.inl.pcoa$vectors[,1:2], Ver.inl.pcoa$vectors[,1:2], scale=FALSE,
                       symmetric=FALSE)
  # Sum of squares = 5.545
plot(procrust.inl)
plot(procrust.inl,kind=2)
pro.inl <- protest(scaled.inl.pcoa$vectors[,1:2], Ver.inl.pcoa$vectors[,1:2])
  # p-value = 0.001
  # m12^2 (sum of squares) = 0.3649
  # correlation = 0.7969
plot(pro.inl)

# Create dataframe for plotting
pro.inl.df <- data.frame(rda1=procrust.inl$Yrot[,1], rda2=procrust.inl$Yrot[,2],
                         xrda1=procrust.inl$X[,1], xrda2=procrust.inl$X[,2])
  # rda1 = Verruco x coordinate
  # rda2 = Verruco y coordinate
  # xrda1 = Whole Community x coordinate
  # xrda2 = Whole community y coordinate
pro.inl.df$Depth <- sample_data(Ver.inl)$Depth
pro.inl.df$Lake_Type <- sample_data(Ver.inl)$Lake_Type
pro.inl.df$Fraction <- sample_data(Ver.inl)$Fraction
pro.inl.df$Season <- sample_data(Ver.inl)$Season

### Plot!
# Basic
ggplot(pro.inl.df) + 
  #geom_point(aes(x=rda1,y=rda2)) + 
  geom_point(aes(x=xrda1, y=xrda2)) +
  geom_segment(aes(x=rda1, y=rda2, xend=xrda1, yend=xrda2), arrow=arrow(length=unit(0.2,"cm")),
               color="burlywood", alpha=0.5)


```





### DESeq
```{r}
# DESeq bible: https://www.bioconductor.org/packages/3.3/bioc/vignettes/DESeq/inst/doc/DESeq.pdf
# Phyloseq to DESeq2: http://joey711.github.io/phyloseq-extensions/DESeq2.html
# Phyloseq to DESeq: http://joey711.github.io/phyloseq-extensions/DESeq.html


### DESeq2 ###

# Subset out Verrucos from RAW COUNT phyloseq object
Vdeseq <- subset_taxa(dupmerge.subset, Phylum == "Verrucomicrobia")

# Subset out the Verruco OTUs that we've been using so far
# When we calculate Ver rel abund, we remove lots of low abundance OTUs
pick.Ver<- colnames(otu_table(Ver.rel))
Vdeseq.pick <- prune_taxa(names(taxa_sums(Vdeseq)) %in% pick.Ver, x=Vdeseq)
  # 208 OTUs

# Add 1 to every OTU count because DESeq doesn't work with lots of 0's
Ver1 <- otu_table(Vdeseq.pick) + 1

# Make new phyloseq object with prepared OTU table
Ver.samp <- sample_data(Vdeseq.pick)
Ver.tax <- tax_table(Vdeseq.pick)
Ver1 <- merge_phyloseq(Ver1, Ver.samp, Ver.tax)


##### Source #####
source <- deSEQ(data=Ver1, valuetest= ~Lake_Type+Season+Source)
  # I left out Depth & Fraction because those all take into account water vs. sediment

### Separate sediment & water samples
sed <- which(source$log2FoldChange < 0)
sed.otus <- rownames(source[sed,])
water <- which(source$log2FoldChange > 0)
water.otus <- rownames(source[water,])

# Plot
deseq.source <- ggplot(source, aes(x=Species, y=log2FoldChange, color=Class)) + geom_point() +
  scale_color_brewer(palette="Set1") +
  ggtitle("Sediment (Top) vs. Water (Bottom)")


##### Fraction #####

# Now let's isolate Verrucos in water
Ver.water <- subset_samples(Ver1, Depth != "Sediment")
watercol <- deSEQ(data=Ver.water, valuetest= ~Lake_Type+Season+Depth, alpha=0.05)

### Separate sediment & water samples
water.bot <- which(watercol$log2FoldChange < 0)
water.bot.otus <- rownames(watercol[water.bot,])
water.top <- which(watercol$log2FoldChange > 0)
water.top.otus <- rownames(watercol[water.top,])

# Plot
deseq.watercol<- ggplot(watercol, aes(x=Species, y=log2FoldChange, color=Class)) + geom_point() +
  scale_color_brewer (palette="Set1") +
  ggtitle("Top (Top) vs. Bottom (Bottom)")


# Verrucos in Bottom vs. Sediment
Ver.bs <- subset_samples(Ver1, Depth != "Top")
Ver.bs <- subset_samples(Ver.bs, Depth != "DCM")
Vbs <- deSEQ(data=Ver.bs, valuetest= ~Lake_Type+Season+Depth, alpha=0.05)

### Separate sediment & water samples
bs.bot <- which(Vbs$log2FoldChange < 0)
bs.bot.otus <- rownames(Vbs[bs.bot,])
bs.sed <- which(Vbs$log2FoldChange > 0)
bs.sed.otus <- rownames(Vbs[bs.sed,])

# Plot
deseq.Vbs <- ggplot(Vbs, aes(x=Species, y=log2FoldChange, color=Class)) + geom_point() +
  scale_color_brewer(palette="Set1") +
  ggtitle("Sediment (Top) vs. Bottom (Bottom)")



# Verrucos in Sediment vs. Top
Ver.st <- subset_samples(Ver1, Depth != "Bottom")
Ver.st <- subset_samples(Ver.st, Depth != "DCM")
Vst <- deSEQ(data=Ver.st, valuetest= ~Lake_Type+Season+Depth, alpha=0.05)

### Separate sediment & water samples
st.sed <- which(Vst$log2FoldChange < 0)
st.sed.otus <- rownames(Vst[st.sed,])
st.top <- which(Vst$log2FoldChange > 0)
st.top.otus <- rownames(Vst[st.top,])

# Plot
deseq.Vst <- ggplot(Vst, aes(x=Species, y=log2FoldChange, color=Class)) + geom_point() +
  scale_color_brewer(palette="Set1") +
  ggtitle("Top (Top) vs. Sediment (Bottom)")


sed.otus1 <- intersect(water.bot.otus, bs.sed.otus)
  # OTUs that prefer bottom, also prefer sed more
sed.otus2 <- intersect(water.top.otus, st.sed.otus)
  # OTUs that prefer top, also prefer sed more

### OTUs that prefer a fraction ###
sed.otus <- c(sed.otus1, sed.otus2)
bot.otus <- intersect(water.bot.otus, bs.bot.otus)
top.otus <- intersect(water.top.otus, st.top.otus)


# Plot
tiff("deseq.depth.tiff", width = 14, height = 10, units = "in", res = 500)
grid.newpage()
pushViewport(viewport(layout=(grid.layout(2,2, widths=c(1,1), heights=c(1.5,1.5)))))
print(deseq.source, vp=viewport(layout.pos.row=1, layout.pos.col=1))
print(deseq.watercol, vp=viewport(layout.pos.row=1, layout.pos.col=2))
print(deseq.Vst, vp=viewport(layout.pos.row=2, layout.pos.col=1))
print(deseq.Vbs, vp=viewport(layout.pos.row=2, layout.pos.col=2))
dev.off()




##### Lake_Type #####

# Now let's isolate Verrucos in Estuary & Laurentian
V.el <- subset_samples(Ver1, Lake_Type != "Inland")
Vel <- deSEQ(data=V.el, valuetest= ~Depth+Season+Lake_Type, alpha=0.05)

### Separate Estuary & Laurentian samples
Vel.est <- which(Vel$log2FoldChange < 0)
Vel.est.otus <- rownames(Vel[Vel.est,])
Vel.lau <- which(Vel$log2FoldChange > 0)
Vel.lau.otus <- rownames(Vel[Vel.lau,])

# Plot
deseq.Vel<- ggplot(Vel, aes(x=Species, y=log2FoldChange, color=Class)) +
  geom_point() + scale_color_brewer(palette="Set1") +
  ggtitle("Laurentian (Top) vs. Estuary (Bottom)")



# Now let's isolate Verrucos in Estuary & Inland
V.ei <- subset_samples(Ver1, Lake_Type != "Laurentian")
Vei <- deSEQ(data=V.ei, valuetest= ~Depth+Season+Lake_Type, alpha=0.05)

### Separate Estuary & Inland samples
Vei.est <- which(Vei$log2FoldChange < 0)
Vei.est.otus <- rownames(Vei[Vel.est,])
Vei.inl <- which(Vei$log2FoldChange > 0)
Vei.inl.otus <- rownames(Vei[Vei.inl,])

# Plot
deseq.Vei<- ggplot(Vei, aes(x=Species, y=log2FoldChange, color=Class)) +
  geom_point() + scale_color_brewer(palette="Set1") +
  ggtitle("Inland (Top) vs. Estuary (Bottom)")




# Now let's isolate Verrucos in Laurentian & Inland
V.li <- subset_samples(Ver1, Lake_Type != "Estuary")
Vli <- deSEQ(data=V.li, valuetest= ~Depth+Season+Lake_Type, alpha=0.05)

### Separate Laurentian & Inland samples
Vli.inl <- which(Vli$log2FoldChange < 0)
Vli.inl.otus <- rownames(Vli[Vli.inl,])
Vli.lau <- which(Vel$log2FoldChange > 0)
Vli.lau.otus <- rownames(Vli[Vli.lau,])

# Plot
deseq.Vli<- ggplot(Vli, aes(x=Species, y=log2FoldChange, color=Class)) +
  geom_point() +scale_color_brewer(palette="Set1") +
  ggtitle("Laurentian (Top) vs. Inland (Bottom)")


### OTUs that prefer a Lake_Type ###
est.otus <- intersect(Vel.est.otus, Vei.est.otus)
inl.otus <- intersect(Vei.inl.otus, Vli.inl.otus)
lau.otus <- intersect(Vel.lau.otus, Vli.lau.otus)

# Plot
tiff("deseq.Lake_Type.tiff", width = 20, height = 10, units = "in", res = 500)
grid.newpage()
pushViewport(viewport(layout=(grid.layout(1,3, widths=c(1.25,1.25,1.25), heights=c(1.5,1.5)))))
print(deseq.Vel, vp=viewport(layout.pos.row=1, layout.pos.col=1))
print(deseq.Vei, vp=viewport(layout.pos.row=1, layout.pos.col=2))
print(deseq.Vli, vp=viewport(layout.pos.row=1, layout.pos.col=3))
dev.off()





##### Fraction #####
# Now let's isolate Verrucos in Free & Particle
V.frac <- subset_samples(Ver1, Fraction != "Sediment")
Vfrac <- deSEQ(data=V.frac, valuetest= ~Depth+Lake_Type+Season+Fraction, alpha=0.05)

### Separate Free and Particle samples
Vfrac.free <- which(Vfrac$log2FoldChange < 0)
free.otus <- rownames(Vfrac[Vfrac.free,])
Vfrac.part <- which(Vfrac$log2FoldChange > 0)
part.otus <- rownames(Vfrac[Vfrac.part,])

# Plot
tiff("deseq.fraction.tiff", width = 7, height = 10, units = "in", res = 500)
ggplot(Vfrac, aes(x=Species, y=log2FoldChange, color=Class)) + geom_point() +
  scale_color_brewer(palette="Set1") +
  ggtitle("Particle (Top) vs. Free (Bottom)")
dev.off()






##### Season #####
# Now let's isolate Verrucos in Spring & Summer
V.ss <- subset_samples(Ver1, Season != "Fall")
Vss <- deSEQ(data=V.ss, valuetest= ~Depth+Lake_Type+Season, alpha=0.05)

### Separate Spring & Summer samples
Vss.sp <- which(Vss$log2FoldChange < 0)
Vss.sp.otus <- rownames(Vss[Vss.sp,])
Vss.su <- which(Vss$log2FoldChange > 0)
Vss.su.otus <- rownames(Vss[Vss.su,])

# plot
deseq.Vss <- ggplot(Vss, aes(x=Species, y=log2FoldChange, color=Class)) + geom_point() + scale_color_brewer(palette="Set1") +
  ggtitle("Season: Summer (Top) vs. Spring (Bottom)")




# Now let's isolate Verrucos in Spring & Fall
V.spf <- subset_samples(Ver1, Season != "Summer")
Vspf <- deSEQ(data=V.spf, valuetest= ~Depth+Lake_Type+Season, alpha=0.05)

### Separate Spring & Fall samples
Vspf.fa <- which(Vspf$log2FoldChange < 0)
Vspf.fa.otus <- rownames(Vspf[Vspf.fa,])
Vspf.sp <- which(Vspf$log2FoldChange > 0)
Vspf.sp.otus <- rownames(Vspf[Vspf.sp,])

# Plot
deseq.Vspf <- ggplot(Vspf, aes(x=Species, y=log2FoldChange, color=Class)) + geom_point() + scale_color_brewer(palette="Set1") +
  ggtitle("Season: Spring (Top) vs. Fall (Bottom)")





# Now let's isolate Verrucos in Summer & Fall
V.suf <- subset_samples(Ver1, Season != "Spring")
Vsuf <- deSEQ(data=V.suf, valuetest= ~Depth+Lake_Type+Season, alpha=0.05)

### Separate Summer & Fall samples
Vsuf.fa <- which(Vsuf$log2FoldChange < 0)
Vsuf.fa.otus <- rownames(Vsuf[Vsuf.fa,])
Vsuf.su <- which(Vsuf$log2FoldChange > 0)
Vsuf.su.otus <- rownames(Vsuf[Vsuf.su,])

# Plot
deseq.Vsuf <- ggplot(Vsuf, aes(x=Species, y=log2FoldChange, color=Class)) + geom_point() + scale_color_brewer(palette="Set1") +
  ggtitle("Season: Summer (Top) vs. Fall (Bottom)")


### OTUs that prefer a season ###
sp.otus <- intersect(Vss.sp.otus,Vspf.sp.otus)
su.otus <- intersect(Vss.su.otus,Vsuf.su.otus)
fa.otus <- intersect(Vspf.fa.otus,Vsuf.fa.otus)


# Plot
tiff("deseq.season.tiff", width = 20, height = 10, units = "in", res = 500)
grid.newpage()
pushViewport(viewport(layout=(grid.layout(1,3, widths=c(1.25,1.25,1.25), heights=c(1.5,1.5)))))
print(deseq.Vss, vp=viewport(layout.pos.row=1, layout.pos.col=1))
print(deseq.Vspf, vp=viewport(layout.pos.row=1, layout.pos.col=2))
print(deseq.Vsuf, vp=viewport(layout.pos.row=1, layout.pos.col=3))
dev.off()
```



### Create ecoIDs
```{r}
#http://stackoverflow.com/questions/10298662/find-elements-not-in-smaller-character-vector-list-but-in-big-list

# These are the Ver OTUs with which we were working
Ver.otus <- rownames(tax_table(Ver1))

### Create Lake_Type label
Lake_Type.label <- rownames(tax_table(Ver1))
# OTUs that prefer Estuary get "E"
Lake_Type.label[Lake_Type.label %in% est.otus] <- paste("E", Lake_Type.label[Lake_Type.label %in% est.otus])
# OTUs that prefer Inland get "I"
Lake_Type.label[Lake_Type.label %in% inl.otus] <- paste("I", Lake_Type.label[Lake_Type.label %in% inl.otus])
# OTUs that prefer Laurentian get "L"
Lake_Type.label[Lake_Type.label %in% lau.otus] <- paste("L", Lake_Type.label[Lake_Type.label %in% lau.otus])


### Create Depth label
Depth.label <- rownames(tax_table(Ver1))
# OTUs that prefer Bottom get "B"
Depth.label[Depth.label %in% bot.otus] <- paste("B", Depth.label[Depth.label %in% bot.otus])
# OTUs that prefer Sediment get "S"
Depth.label[Depth.label %in% sed.otus] <- paste("S", Depth.label[Depth.label %in% sed.otus])
# OTUs that prefer Top get "T"
Depth.label[Depth.label %in% top.otus] <- paste("T", Depth.label[Depth.label %in% top.otus])


### Create Fraction label
Fraction.label <- rownames(tax_table(Ver1))
# OTUs that prefer Free get "F"
Fraction.label[Fraction.label %in% free.otus] <- paste("F", Fraction.label[Fraction.label %in% free.otus])
# OTUs that prefer Particle get "P"
Fraction.label[Fraction.label %in% part.otus] <- paste("P", Fraction.label[Fraction.label %in% part.otus])


### Create Season label
Season.label <- rownames(tax_table(Ver1))
# OTUs that prefer Spring get "C_" (for chuntian (Chinese for Spring))
# There's an underscore because Season is the last ecoID label
Season.label[Season.label %in% sp.otus] <- paste("C_", Season.label[Season.label %in% sp.otus])
# OTUs that prefer Summer get "V_" (for verano (Spanish for Summer))
Season.label[Season.label %in% su.otus] <- paste("V_", Season.label[Season.label %in% su.otus])
# OTUs that prefer Fall get "A_" (for autumn)
Season.label[Season.label %in% fa.otus] <- paste("A_", Season.label[Season.label %in% fa.otus])


# Split ecoID characters to prepare to be put into a dataframe
Lake_Type.split <- data.frame(strsplit(Lake_Type.label, " "), stringsAsFactors=FALSE)
colnames(Lake_Type.split) <- Ver.otus
depth.split <- data.frame(strsplit(Depth.label, " "), stringsAsFactors=FALSE)
colnames(depth.split) <- Ver.otus
fraction.split <- data.frame(strsplit(Fraction.label, " "), stringsAsFactors=FALSE)
colnames(fraction.split) <- Ver.otus
season.split <- data.frame(strsplit(Season.label, " "), stringsAsFactors=FALSE)
colnames(season.split) <- Ver.otus

# Combine all the ecoIDs into one dataframe
Lake_Type.split[3,] <- depth.split[1,]
Lake_Type.split[4,] <- fraction.split[1,]
Lake_Type.split[5,] <- season.split[1,]
Lake_Type.split <- Lake_Type.split[-2,]


# Rename the OTUs with no preference in one of the ecological factors
nopref <- which(substr(Lake_Type.split[1,],1,1) == "O")
Lake_Type.split[1,nopref] <- 0
nopref <- which(substr(Lake_Type.split[2,],1,1) == "O")
Lake_Type.split[2,nopref] <- 0
nopref <- which(substr(Lake_Type.split[3,],1,1) == "O")
Lake_Type.split[3,nopref] <- 0
nopref <- which(substr(Lake_Type.split[4,],1,1) == "O")
Lake_Type.split[4,nopref] <- "0_"

### Combine all of the ecoIDs into the final dataframe
Lake_Type.split[5,] <- paste(Lake_Type.split[2,], Lake_Type.split[1,], Lake_Type.split[3,], Lake_Type.split[4,],
                         colnames(Lake_Type.split))

### Save our file!
write.csv(Lake_Type.split[5,], file="Ecology_Otu_sig", row.names=FALSE, quote=FALSE)
```

### Create updated phyloseq object with EcoID
```{r}
### Create new phyloseq object with EcoIDs

eco.label<- read.csv("Ecology_Otu_sig", header=F)
eco.label <- t(eco.label)
otu <- otu_table(Ver1)
samp <- sample_data(Ver1)

# Add ecoIDs to tax_table
tax <- data.frame(tax_table(Ver1))
tax$EcoID <- eco.label

# Split up ecoIDs to each separate preference
Lake_Type.split <- t(Lake_Type.split)
tax$Pref.Depth <- Lake_Type.split[,3]
tax$Pref.Lake_Type <- Lake_Type.split[,1]
tax$Pref.Fraction <- Lake_Type.split[,4]
tax$Pref.Season <- Lake_Type.split[,5]
tax <- as.matrix(tax)
tax <- tax_table

# Phyloseq object w/ ecoID info
eco.ver <- merge_phyloseq(otu, samp, tax)

# Add Verruco tree to phyloseq object
newick <- read.newick(file="ver.tre")
newick_phy <- phy_tree(newick)

# Final phyloseq object!
Ver.tree<-merge_phyloseq(eco.ver,newick_phy)

```

### Create labels for IToL!
```{r}
### IToL Label Functions
color.id <- function(x) {
  ifelse(grepl("OPB35_soil_group",x),"#e41a1c",
  ifelse(grepl("Opitutae",x), "#377eb8",
  ifelse(grepl("Spartobacteria",x), "#4daf4a",
  ifelse(grepl("S-BQ2-57_soil_group",x), "#984ea3",
  ifelse(grepl("Verrucomicrobia_Incertae_Sedis",x), "#ff7f00",
  ifelse(grepl("Verrucomicrobiae",x), "#ffd92f",
  ifelse(grepl("unclassified",x), "#f1a3a9",
  ifelse(grepl("UA11",x), "#fff5eb",
         NA))))))))
}

depth.id <- function(x) {
  depth <- substr(x$EcoID,1,1)
  ifelse(grepl("T",depth), "1,-1,-1",
  ifelse(grepl("B",depth), "-1,1,-1",
  ifelse(grepl("S",depth), "-1,-1,1",
  ifelse(grepl("0",depth), "-1,-1,-1",
  NA))))
}

Lake_Type.id <- function(x) {
  Lake_Type <- substr(x$EcoID,2,2)
  ifelse(grepl("L",Lake_Type), "1,-1,-1",
  ifelse(grepl("E",Lake_Type), "-1,1,-1",
  ifelse(grepl("I",Lake_Type), "-1,-1,1",
  ifelse(grepl("0", Lake_Type), "-1,-1,-1",
  NA))))
}

fraction.id <- function(x) {
  fraction <- substr(x$EcoID,3,3)
  ifelse(grepl("P",fraction), "1,-1",
  ifelse(grepl("F",fraction), "-1,1",
  ifelse(grepl("0",fraction), "-1,-1",
  NA)))
}

season.id <- function(x) {
  season <- substr(x$EcoID,4,4)
  ifelse(grepl("C",season), "1,-1,-1",
  ifelse(grepl("V",season), "-1,1,-1",
  ifelse(grepl("A",season), "-1,-1,1",
  ifelse(grepl("0", season), "-1,-1,-1",
  NA))))
}

### Create IToL COLOR labels
all <- data.frame(tax_table(Ver.tree))
color.all <- data.frame(all$Species)
color.all$Class <- all$Class
color.all$color <- color.id(color.all$Class)
color.all$label <- paste(color.all$all.Species,"range",color.all$color,color.all$Class)
write.csv(color.all$label,file="sig.ver.color",row.names=FALSE,quote=FALSE)

### Create IToL ECOID Labels
ecoid.all <- data.frame(all$Species)
ecoid.all$EcoID <- all$EcoID
depth.itol <- depth.id(ecoid.all)
ecoid.all$depth.label <- depth.itol
Lake_Type.itol <- Lake_Type.id(ecoid.all)
ecoid.all$Lake_Type.label <- Lake_Type.itol
fraction.itol <- fraction.id(ecoid.all)
ecoid.all$fraction.label <- fraction.itol
season.itol <- season.id(ecoid.all)
ecoid.all$season.label <- season.itol
ecoid.all$itol.label <- paste(ecoid.all$all.Species, ecoid.all$depth.label, ecoid.all$Lake_Type.label,
                              ecoid.all$fraction.label, ecoid.all$season.label)
write.csv(ecoid.all$itol.label,"EcoID.IToL.label.sig", row.names=FALSE, quote=FALSE)
```


### Subset only significant EcoID Verrucos
```{r}
# Subset out Verruco OTUs that have no preference
nosig <- which(substr(ecoid.all$EcoID,1,4)=="0000")
nosig.otus <- as.character(ecoid.all$all.Species[nosig])

# Subset out Verruco OTUs that have at least one preference
sig.otus <- Ver.otus[!Ver.otus %in% nosig.otus]
only.sig <- prune_taxa(sig.otus, Ver.tree)

# Verruco tree of only OTUs that have a preference
write.tree(phy_tree(only.sig), file="ver.sig.tre")

```





### Geiger
```{r}
# https://github.com/mwpennell/geiger-v2

# Read in tree of only Verrucos with a habitat preference
ver.sig.tre <- read.newick(file="ver.sig.tre")

# Create dataframe with ecoID data
eco.label <- read.csv("Ecology_Otu_sig", header=F)
eco.label <- t(eco.label)
eco.label <- data.frame(eco.label)
eco.label$OTU <- substr(eco.label[,1],6,14)
eco.label$Depth <- substr(eco.label[,1],1,1)
eco.label$Lake_Type <- substr(eco.label[,1],2,2)
eco.label$Fraction <- substr(eco.label[,1],3,3)
eco.label$Season <- substr(eco.label[,1],4,4)

# Remove non-significant Verruco OTUs
nosig <- setdiff(eco.label$OTU, ver.sig.tre$tip.label)
nosig.loc <- pmatch(nosig, eco.label$OTU)
eco.label <- eco.label[-nosig.loc,]


# Pull only OTUs with a Depth preference
eco.depth <- data.frame(eco.label$Depth, row.names=eco.label$OTU)
pref <- which(eco.depth != "0")
sig.depth <- data.frame(eco.depth[pref,1], row.names=row.names(eco.depth)[pref])
nopref <- which(eco.depth == "0")
nopref<- row.names(eco.depth)[nopref]
depth.tre <- drop.tip(ver.sig.tre, nopref)

# Test for phylogenetic signal in Depth affinity
optimal <- fitDiscrete(depth.tre, sig.depth, treeTransform="lambda")
phy.Lambda0 <- rescale(depth.tre, "lambda", 0)
zero <- fitDiscrete(phy.Lambda0, sig.depth)
d.lambda=2*(optimal$opt$lnL-zero$opt$lnL)
p.lambda <- pchisq(d.lambda, 1, lower.tail=F)
p.lambda
  # p-value = 0.1857386



# Pull only OTUs with a Lake Type preference
eco.lake <- data.frame(eco.label$Lake_Type, row.names=eco.label$OTU)
pref <- which(eco.lake != "0")
sig.lake <- data.frame(eco.lake[pref,1], row.names=row.names(eco.lake)[pref])
nopref <- which(eco.lake == "0")
nopref<- row.names(eco.lake)[nopref]
lake.tre <- drop.tip(ver.sig.tre, nopref)

# Test for phylogenetic signal in Lake Type affinity
optimal <- fitDiscrete(lake.tre, sig.lake, treeTransform="lambda")
phy.Lambda0 <- rescale(lake.tre, "lambda", 0)
zero <- fitDiscrete(phy.Lambda0, sig.lake)
d.lambda=2*(optimal$opt$lnL-zero$opt$lnL)
p.lambda <- pchisq(d.lambda, 1, lower.tail=F)
p.lambda
  # p-value = 0.0286439


# Pull out only OTUs with a Fraction preference
eco.frac <- data.frame(eco.label$Fraction, row.names=eco.label$OTU)
pref <- which(eco.frac != "0")
sig.frac <- data.frame(eco.frac[pref,1], row.names=row.names(eco.frac)[pref])
nopref <- which(eco.frac == "0")
nopref<- row.names(eco.frac)[nopref]
frac.tre <- drop.tip(ver.sig.tre, nopref)

# Test for phylogenetic signal in Fraction affinity
optimal <- fitDiscrete(frac.tre, sig.frac, treeTransform="lambda")
phy.Lambda0 <- rescale(frac.tre, "lambda", 0)
zero <- fitDiscrete(phy.Lambda0, sig.frac)
d.lambda=2*(optimal$opt$lnL-zero$opt$lnL)
p.lambda <- pchisq(d.lambda, 1, lower.tail=F)
p.lambda
  # p-value = 7.514368e-11



# Pull out only OTUs with a Season preference
eco.season <- data.frame(eco.label$Season, row.names=eco.label$OTU)
pref <- which(eco.season != "0")
sig.season <- data.frame(eco.season[pref,1], row.names=row.names(eco.season)[pref])
nopref <- which(eco.season == "0")
nopref<- row.names(eco.season)[nopref]
season.tre <- drop.tip(ver.sig.tre, nopref)

# Test for phylogenetic signal in Season affinity
optimal <- fitDiscrete(season.tre, sig.season, treeTransform="lambda")
phy.Lambda0 <- rescale(season.tre, "lambda", 0)
zero <- fitDiscrete(phy.Lambda0, sig.season)
d.lambda=2*(optimal$opt$lnL-zero$opt$lnL)
p.lambda <- pchisq(d.lambda, 1, lower.tail=F)
p.lambda
  # p-value = 2.492829e-05

##### Lake Type, Fraction, & Season have significant phylogenetic signals
##### Depth does not have significant phylogenetic signals

```


### Bootstrap Values
```{r}
#https://cran.r-project.org/web/packages/phangorn/vignettes/Trees.pdf

# Read in fasta file
# This file is all verrucos + 1 outgroup (planctomycetes)
# Any nonsignificant verruco sequences will be trimmed out once we combine the fasta file with the tree file
seqs <- read.phyDat("combined.trim.contigs.good.unique.good.filter.unique.precluster.pick.an.unique_list.0.03.rep.cut3.pick.outgroup.fasta", format = "fasta", type = "DNA")

# Read in tree file
ver.sig.tre <- read.newick(file="ver.sig.tre")

# Calculates maximum likelihood for tree
fit <- pml(ver.sig.tre, seqs)

### Time to choose the best model
# Test a bunch of different models
#mt <- modelTest(seqs, tree=ver.sig.tre, multicore=TRUE)
#mt[order(mt$AICc),]
# Choose the best model based on AICc
#bestmodel <- mt$Model[which.min(mt$AICc)]
#env <- attr(mt, "env")
# Below is the best model that you'll use
# GTR+G+I
#fitStart <- eval(get(bestmodel, env), env)

# Optimize model parameters
#fit.optim <- optim.pml(fitStart, rearrangement = "stochastic", optGamma=TRUE, optInv=TRUE, model="GTR")

# Apply bootstrap test
#bs.optim <- bootstrap.pml(fit.optim, bs=100, optNni=TRUE)
bs <- bootstrap.pml(fit, bs=100, optNni=TRUE)

# Unrooted tree (midpoint rooted) with bootstrap support values above 50
#bs.optim.tre <- plotBS(midpoint(fit.optim$tree), bs, p = 50, type="p")
bs.tre <- plotBS(midpoint(fit$tree), bs, p = 50, type="p")

# Consensus tree from bootstrap test
cnet <- consensusNet(bs)

### Which nodes have a bootstrap value of < 50
which(bs.tre$node.label < 50)
  # 11 nodes

### Export tree with bootstrap values as node labels
#write.tree(bs.tre, "bootstrap.tre")

# Compare IToL tree with bootstrap tree
bs.tre <- read.newick(file="bootstrap.tre")
length(intersect(ver.sig.tre$tip.label,bs.tre$tip.label))
  # Same tip labels on ver.sig.tre & treeBS

##### Rename bootstrap tree tips with full taxonomy #####
# Pull out only significant Verrucos
ver.sig <- merge_phyloseq(Ver, bs.tre)
tax.name <- data.frame(tax_table(ver.sig))
tax.name$Tip_Name <- NA

# Create tip name of class;order;family;genus
for (i in 1:125){
  class <- paste(tax.name[i,3])
  order <- paste(tax.name[i,4])
  family <- paste(tax.name[i,5])
  genus <- paste(tax.name[i,6])
  tax.name[i,8] <- paste(class, order, family, genus, sep=";")
}

# Write new tip names into csv file
# I have to manually edit out the unclassified
# Change ";" to "--- " (IToL doesn't recognize ";")
write.csv(tax.name$Tip_Name, "tip_name", row.names = F)

# Read in the final tip names
tip.name <- read.csv("tip_name", header=F)
tip.name$OTU <- tax.name$Species

# Make bootstrapped tree with new tip names
name.tre <- bs.tre

# Match current tip names with new tip names
name.tre$tip.label <- tip.name$V1[match(name.tre$tip.label, tip.name$OTU)]

# Convert new tip labels from integer to character
name.tre$tip.label <- as.character(name.tre$tip.label)

# Save the new tree!
write.tree(name.tre, "bootstrap.tax.tre")
```


### Bioenv
```{r}
# Trim otu_table so that samples match metadata samples
meta.otus <- subset_samples(Ver.rel, SampleID != "Su13.ED.MM15.DN")
meta.otus <- subset_samples(meta.otus, SampleID != "Su13.BD.MM15.DN")
meta.otus <- subset_samples(meta.otus, SampleID != "Sp13.ED.MM15.SN")
meta.otus <- subset_samples(meta.otus, SampleID != "Sp13.ED.MM15.DD")
meta.otus <- subset_samples(meta.otus, SampleID != "Sp13.ED.MM110.DD")
meta.otus <- subset_samples(meta.otus, SampleID != "Sp13.BD.MM15.DD")
meta.otus <- subset_samples(meta.otus, SampleID != "Sp13.BD.MM110.DD")
meta.otus <- subset_samples(meta.otus, SampleID != "Fa13.BD.MM110.SD")
meta.otus <- subset_samples(meta.otus, SampleID != "Fa13.BD.MM110.SN")
meta.otus <- subset_samples(meta.otus, SampleID != "Fa13.BD.MM15.DN")
meta.otus <- subset_samples(meta.otus, SampleID != "Fa13.ED.MM15.DN")
meta.otus <- subset_samples(meta.otus, Station != "Buoy")
meta.otus <- subset_samples(meta.otus, Source != "Sediment")
meta.otus <- subset_samples(meta.otus, SampleID != "Z14.060.P")
meta.otus <- subset_samples(meta.otus, SampleID != "Z14.060.F")


# I'll be examining Laurentian, Estuary, and Inland Lake samples separately
# First separate the samples based on Lake Type
lau.otus <- data.frame(otu_table(subset_samples(meta.otus,Lake_Type=="Laurentian")))
est.otus <- data.frame(otu_table(subset_samples(meta.otus,Lake_Type=="Estuary")))
inl.otus <- data.frame(otu_table(subset_samples(meta.otus,Lake_Type=="Inland")))

# Now prune taxa that have 0 counts
lau.0 <- which(colSums(lau.otus) == 0)
lau.otus <- lau.otus[,-lau.0]
est.0 <- which(colSums(est.otus) == 0)
est.otus <- est.otus[,-est.0]
inl.0 <- which(colSums(inl.otus) == 0)
inl.otus <- inl.otus[,-inl.0]

# Read in metadata files
lau.env <- read.table("metadata_laurentian.csv", header=T, sep=",", row.names=1,
                      as.is=T)
est.env <- read.table("metadata_estuary.csv", header=T, sep=",", row.names=1,
                      as.is=T)
est.env <- est.env[,-27]
  # Remove DO %
inl.env <- read.table("metadata_inland.csv", header=T, sep=",", row.names=1,
                      as.is=T)

# Trim any metadata that isn't numeric
lau.env <- lau.env[,-1:-10]
est.env <- est.env[,-1:-10]
inl.env <- inl.env[,-1:-10]

# Laurentian metadata - Test for normality
shapiro.test(lau.env$Temperature..C)
  # p-value = 0.003358; not normal
shapiro.test(lau.env$SpCond...S.cm)
  # p-value = 0.000349; not normal
shapiro.test(lau.env$DO.Probe..mg.L.)
  # p-value = 0.0002237; not normal
shapiro.test(lau.env$Chl.Probe...g.L.)
  # p-value = 1.947e-06; not normal
shapiro.test(lau.env$Chl.Lab..ug.L.)
  # p-value = 2.712e-05; not normal
shapiro.test(lau.env$TP.ug.L)
  # p-value = 7.47e-08; not normal
shapiro.test(lau.env$PP.ug.L)
  # p-value = 8.309e-08; not normal
shapiro.test(lau.env$TDP.ug.L)
  # p-value = 7.005e-07
shapiro.test(lau.env$TDP.SRP)
  # p-value = 7.005e-07
shapiro.test(lau.env$POC.mg.L)
  # p-value = 0.01825; not normal
shapiro.test(lau.env$PON.mg.L)
  # p-value = 0.0217; not normal
shapiro.test(lau.env$DOC.mg.L)
  # p-value = 6.264e-06; not normal
shapiro.test(lau.env$SiO2.mg.L)
  # p-value = 0.00238; not normal
shapiro.test(lau.env$TSS.mg.L)
  # p-value = 8.456e-08; not normal
shapiro.test(lau.env$Fluorescence.mg.m3.)
  # p-value = 1.479e-06; not normal
shapiro.test(lau.env$PAR)
  # p-value = 3.161e-07; not normal

# Estuary metadata - Test for normality
shapiro.test(est.env$Temperature..C)
  # p-value = 0.0006905; not normal
shapiro.test(est.env$SpCond...S.cm.)
  # p-value = 0.0005477; not normal
shapiro.test(est.env$TDS..mg.L.)
  # p-value = 0.0005534; not normal
shapiro.test(est.env$pH)
  # p-value = 0.0005803; not normal
shapiro.test(est.env$ORP..mV.)
  # p-value = 9.753e-07; not normal
shapiro.test(est.env$Chl.Lab..ug.L.)
  # p-value = 6.355e-06; not normal
shapiro.test(est.env$BGA.cells.mL)
  # p-value = 9.826e-12; not normal
shapiro.test(est.env$Cl.mg.L)
  # p-value = 0.03225; not normal
shapiro.test(est.env$SO4.mg.L)
  # p-value = 4.367e-05; not normal
shapiro.test(est.env$NO3.mg.L)
  # p-value = 7.682e-05; not normal
shapiro.test(est.env$NH3.mg.L)
  # p-value = 1.03e-06; not normal
shapiro.test(est.env$TKN.mg.L)
  # p-value = 0.02124; not normal
shapiro.test(est.env$SRP.ug.L)
  # p-value = 1.462e-11; not normal
shapiro.test(est.env$TP.ug.L)
  # p-value = 4.798e-09; not normal
shapiro.test(est.env$Alk.mg.L)
  # p-value = 0.0001785; not normal
shapiro.test(est.env$DO.Lab.mg.L)
  # p-value = 3.206e-09; not normal
shapiro.test(est.env$DO..)
  # p-value = 4.353e-07; not normal
shapiro.test(est.env$Turb.NTU)
  # p-value = 0.01459; not normal

# Estuary metdata - Plot
plot(est.env$Temperature..C.)
plot(est.env$SpCond...S.cm.)
plot(est.env$TDS..mg.L.)
plot(est.env$pH)
plot(est.env$ORP..mV.)
plot(est.env$Chl.Lab..ug.L.)
plot(est.env$BGA.cells.mL)
  # Looks like a line
plot(est.env$Cl.mg.L)
plot(est.env$SO4.mg.L)
plot(est.env$NO3.mg.L)
plot(est.env$NH3.mg.L)
plot(est.env$TKN.mg.L)
plot(est.env$SRP.ug.L)
  # Is a line
plot(est.env$TP.ug.L)
plot(est.env$Alk.mg.L)
plot(est.env$DO.Lab.mg.L)
plot(est.env$DO..)
plot(est.env$Turb.NTU)





# Inland metadata - Test for normality
shapiro.test(sqrt(inl.env$Chl.Lab..ug.L.))
  # p-value = 1.441e-15; not normal
shapiro.test(sqrt(inl.env$NO3.mg.L))
  # p-value = <2.2e-16; not normal
shapiro.test(sqrt(inl.env$SRP.ug.L))
  # p-value = <2.2e-16; not normal
shapiro.test(inl.env$TP.ug.L)
  # p-value = <2.2e-16; not normal
shapiro.test(inl.env$TDP.ug.L)
  # p-value = <2.2e-16; not normal
shapiro.test(inl.env$NH4.ug.L)
  # p-value = <2.2e-16; not normal


# Inland metdata - Plot
plot(inl.env$Chl.Lab..ug.L.)
plot(inl.env$NO3.mg.L)
  # Looks like a straight line
plot(inl.env$SRP.ug.L)
  # Looks like a straight line
plot(inl.env$TP.ug.L)
  # Looks like a straight line
plot(inl.env$TDP.ug.L)
  # It IS a straight line
plot(inl.env$NH4.ug.L)
  # Looks like a straight line


##### Run Bioenv #####
bioenv.lau <- bioenv(lau.otus ~ Temperature..C. + DO.Probe..mg.L. +
                       Chl.Probe...g.L. + Chl.Lab..ug.L. +
                       TP.ug.L + PP.ug.L + TDP.ug.L + TDP.SRP + POC.mg.L +
                       PON.mg.L + DOC.mg.L + SiO2.mg.L + TSS.mg.L +
                       Fluorescence.mg.m3. + PAR, lau.env,
                     method = "spearman", index = "bray", trace = TRUE,
                     partial = NULL)
  # Best parameter = DO.probe..mg.L
  # correlation = 0.4545795
bioenv.est <- bioenv(est.otus ~ Temperature..C. + SpCond...S.cm. +
                       TDS..mg.L. + pH + ORP..mV. + Chl.Lab..ug.L. +
                       BGA.cells.mL + Cl.mg.L + SO4.mg.L + NO3.mg.L +
                       NH3.mg.L + TKN.mg.L + SRP.ug.L + TP.ug.L +
                       Alk.mg.L + DO.probe.mg.L + Turb.NTU,
                     est.env, method = "spearman", index = "bray",
                     trace =TRUE, partial=NULL)
  # Best parameters = NH3.mg.L
  #                   SRP.ug.L
  #                   DO.probe.mg.L
  # correlation = 0.1246583
bioenv.inl <- bioenv(inl.otus ~ Chl.Lab..ug.L. + NO3.mg.L + SRP.ug.L +
                       TP.ug.L + TDP.ug.L + NH4.ug.L, inl.env,
                     method = "spearman", index = "bray", trace = TRUE,
                     partial = NULL)
  # Best parameters = NO3.mg.L
  #                   SRP.ug.L
  #                   TP.ug.L
  #                   NH4.ug.L
  # correlation = 0.4449871


##### P-value Calculations #####
# Perform random permutations of row names
# Laurentian
x <- 0
result.lau <- vector(mode="numeric", length = 100)
while (x < 100){
  lau.otus.rand <- lau.otus[sample(1:nrow(lau.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(lau.otus.rand ~ Temperature..C. + DO.Probe..mg.L. +
                       Chl.Probe...g.L. + Chl.Lab..ug.L. +
                       TP.ug.L + PP.ug.L + TDP.ug.L + TDP.SRP + POC.mg.L +
                       PON.mg.L + DOC.mg.L + SiO2.mg.L + TSS.mg.L +
                       Fluorescence.mg.m3. + PAR, lau.env,
                       method = "spearman",index = "bray", trace = TRUE,
                       partial = NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.lau[x] = max(tmp)
  print(x)
}
hist(result.lau)
print(mean(result.lau))
print(max(result.lau))
print(quantile(result.lau,0.95))
print(quantile(result.lau,0.99)) 
print(quantile(result.lau,1))
  ## Yay, p-value < 0.01!

# Estuary
x <- 0
result.est <- vector(mode="numeric", length = 100)
while (x < 100){
  est.otus.rand <- est.otus[sample(1:nrow(est.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(est.otus.rand ~ Temperature..C. + SpCond...S.cm. +
                          TDS..mg.L. + pH + ORP..mV. + Chl.Lab..ug.L. +
                          BGA.cells.mL + Cl.mg.L + SO4.mg.L + NO3.mg.L +
                          NH3.mg.L + TKN.mg.L + SRP.ug.L + TP.ug.L +
                          Alk.mg.L + DO.probe.mg.L + Turb.NTU,
                        est.env, method = "spearman", index = "bray", 
                        trace =TRUE, partial=NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.est[x] = max(tmp)
  print(x)
}
hist(result.est)
print(mean(result.est))
print(max(result.est))
print(quantile(result.est,0.95))
print(quantile(result.est,0.99)) 
print(quantile(result.est,1))
  ### Estuary correlation is NOT significant


# Inland
x <- 0
result.inl <- vector(mode="numeric", length = 100)
while (x < 100){
  inl.otus.rand <- inl.otus[sample(1:nrow(inl.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(inl.otus.rand ~ Chl.Lab..ug.L. + NO3.mg.L +
                          SRP.ug.L + TP.ug.L + TDP.ug.L + NH4.ug.L,
                        inl.env, method = "spearman", index = "bray",
                        trace = TRUE, partial = NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.inl[x] = max(tmp)
  print(x)
}
hist(result.inl)
print(mean(result.inl))
print(max(result.inl))
print(quantile(result.inl,0.95))
print(quantile(result.inl,0.99))
print(quantile(result.inl,1))
  ###Yay, p-value < 0.01!









########## WHOLE COM BIOENV ##########
# Trim otu_table so that samples match metadata samples
scaled.meta.otus <- subset_samples(scaled, SampleID != "Su13.ED.MM15.DN")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Su13.BD.MM15.DN")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Sp13.ED.MM15.SN")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Sp13.ED.MM15.DD")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Sp13.ED.MM110.DD")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Sp13.BD.MM15.DD")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Sp13.BD.MM110.DD")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Fa13.BD.MM110.SD")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Fa13.BD.MM110.SN")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Fa13.BD.MM15.DN")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Fa13.ED.MM15.DN")
scaled.meta.otus <- subset_samples(scaled.meta.otus, Station != "Buoy")
scaled.meta.otus <- subset_samples(scaled.meta.otus, Source != "Sediment")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Z14.060.P")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Z14.060.F")


# I'll be examining Laurentian, Estuary, and Inland Lake samples separately
# First separate the samples based on Lake Type
scaled.lau.otus <- data.frame(otu_table(subset_samples(scaled.meta.otus,Lake_Type=="Laurentian")))
scaled.est.otus <- data.frame(otu_table(subset_samples(scaled.meta.otus,Lake_Type=="Estuary")))
scaled.inl.otus <- data.frame(otu_table(subset_samples(scaled.meta.otus,Lake_Type=="Inland")))

# Now prune taxa that have 0 counts
scaled.lau.0 <- which(colSums(scaled.lau.otus) == 0)
scaled.lau.otus <- scaled.lau.otus[,-scaled.lau.0]
scaled.est.0 <- which(colSums(scaled.est.otus) == 0)
scaled.est.otus <- scaled.est.otus[,-scaled.est.0]
scaled.inl.0 <- which(colSums(scaled.inl.otus) == 0)
scaled.inl.otus <- scaled.inl.otus[,-scaled.inl.0]

# Read in metadata files
lau.env <- read.table("metadata_laurentian.csv", header=T, sep=",", row.names=1,
                      as.is=T)
est.env <- read.table("metadata_estuary.csv", header=T, sep=",", row.names=1,
                      as.is=T)
est.env <- est.env[,-27]
  # Remove DO %
inl.env <- read.table("metadata_inland.csv", header=T, sep=",", row.names=1,
                      as.is=T)

# Trim any metadata that isn't numeric
lau.env <- lau.env[,-1:-10]
est.env <- est.env[,-1:-10]
inl.env <- inl.env[,-1:-10]

##### Run Whole Com Bioenv #####
scaled.bioenv.lau <- bioenv(scaled.lau.otus ~ Temperature..C. +
                              DO.Probe..mg.L. + Chl.Probe...g.L. +
                              Chl.Lab..ug.L. + TP.ug.L + PP.ug.L +
                              TDP.ug.L + TDP.SRP + POC.mg.L + PON.mg.L +
                              DOC.mg.L + SiO2.mg.L + TSS.mg.L +
                              Fluorescence.mg.m3. + PAR, lau.env,
                            method = "spearman", index = "bray",
                            trace = TRUE, partial = NULL)
  # Best parameters: Chl.Probe...g.L.
  #                  PP.ug.L
  #                  TDP.SRP
  #                  PAR
  # correlation = 0.3751753
scaled.bioenv.est <- bioenv(scaled.est.otus ~ Temperature..C. + 
                              SpCond...S.cm. + TDS..mg.L. + pH +
                              ORP..mV. + Chl.Lab..ug.L. + BGA.cells.mL +
                              Cl.mg.L + SO4.mg.L + NO3.mg.L + NH3.mg.L +
                              TKN.mg.L + SRP.ug.L + TP.ug.L + Alk.mg.L +
                              DO.probe.mg.L + Turb.NTU,
                            est.env, method = "spearman", index = "bray",
                            trace =TRUE, partial=NULL)
  # Best parameters = NH3.mg.L
  #                   SRP.ug.L
  #                   DO.probe.mg.L
  # correlation = 0.1786684
scaled.bioenv.inl <- bioenv(scaled.inl.otus ~ Chl.Lab..ug.L. + NO3.mg.L +
                              SRP.ug.L + TP.ug.L + TDP.ug.L + NH4.ug.L,
                            inl.env, method = "spearman", index = "bray",
                            trace = TRUE, partial = NULL)
  # Best parameters = NO3.mg.L
  #                   TP.ug.L
  #                   TDP.ug.L
  #                   NH4.ug.L
  # correlation = 0.5508089



##### WC P-value Calculations #####
# Perform random permutations of row names
# Laurentian
x <- 0
result.scaled.lau <- vector(mode="numeric", length = 100)
while (x < 100){
  lau.otus.rand <- scaled.lau.otus[sample(1:nrow(scaled.lau.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(lau.otus.rand ~ Temperature..C. + DO.Probe..mg.L. +
                       Chl.Probe...g.L. + Chl.Lab..ug.L. +
                       TP.ug.L + PP.ug.L + TDP.ug.L + TDP.SRP + POC.mg.L +
                       PON.mg.L + DOC.mg.L + SiO2.mg.L + TSS.mg.L +
                       Fluorescence.mg.m3. + PAR, lau.env,
                       method = "spearman",index = "bray", trace = TRUE,
                       partial = NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.lau[x] = max(tmp)
  print(x)
}
hist(result.scaled.lau)
print(mean(result.scaled.lau))
print(max(result.scaled.lau))
print(quantile(result.scaled.lau,0.95))
print(quantile(result.scaled.lau,0.99)) 
print(quantile(result.scaled.lau,1))
  # All results are 0 o.O
  ### Yay, p-value < 0.01!

# Estuary
x <- 0
result.scaled.est <- vector(mode="numeric", length = 100)
while (x < 100){
  est.otus.rand <- scaled.est.otus[sample(1:nrow(scaled.est.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(est.otus.rand ~ Temperature..C. + SpCond...S.cm. +
                          TDS..mg.L. + pH + ORP..mV. + Chl.Lab..ug.L. +
                          BGA.cells.mL + Cl.mg.L + SO4.mg.L + NO3.mg.L +
                          NH3.mg.L + TKN.mg.L + SRP.ug.L + TP.ug.L +
                          Alk.mg.L + DO.probe.mg.L + Turb.NTU,
                        est.env, method = "spearman", index = "bray", 
                        trace =TRUE, partial=NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.est[x] = max(tmp)
  print(x)
}
hist(result.scaled.est)
print(mean(result.scaled.est))
print(max(result.scaled.est))
print(quantile(result.scaled.est,0.95))
print(quantile(result.scaled.est,0.99)) 
print(quantile(result.scaled.est,1))
  # All results are 0 o.O
  ###Yay, p-value < 0.01!


# Inland
x <- 0
result.scaled.inl <- vector(mode="numeric", length = 100)
while (x < 100){
  inl.otus.rand <- scaled.inl.otus[sample(1:nrow(scaled.inl.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(inl.otus.rand ~ Chl.Lab..ug.L. + NO3.mg.L +
                          SRP.ug.L + TP.ug.L + TDP.ug.L + NH4.ug.L,
                        inl.env, method = "spearman", index = "bray",
                        trace = TRUE, partial = NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.inl[x] = max(tmp)
  print(x)
}
hist(result.scaled.inl)
print(mean(result.scaled.inl))
print(max(result.scaled.inl))
print(quantile(result.scaled.inl,0.95))
print(quantile(result.scaled.inl,0.99))
print(quantile(result.scaled.inl,1))
  # All results are 0 o.O
  ###Yay, p-value < 0.01!



                        


```





### Extra Functions
```{r}
################# FUNCTION TO FIND NAS IN A DATAFRAME #################
nacols <- function(df) {
  colnames(df)[unlist(lapply(df, function(x) any(is.na(x))))]
}



# http://menugget.blogspot.com/2011/06/clarke-and-ainsworths-bioenv-and-bvstep.html#more
bio.env <- function(fix.mat, var.mat, 
fix.dist.method="bray", var.dist.method="euclidean",
scale.fix=FALSE, scale.var=TRUE,
output.best=10,
var.max=ncol(var.mat)
){
 if(dim(fix.mat)[1] != dim(var.mat)[1]){stop("fixed and variable matrices must have the same number of rows")}
 if(var.max > dim(var.mat)[2]){stop("var.max cannot be larger than the number of variables (columns) in var.mat")}
 
 require(vegan)
 
 combn.sum <- sum(factorial(ncol(var.mat))/(factorial(1:var.max)*factorial(ncol(var.mat)-1:var.max)))
 
 if(scale.fix){fix.mat<-scale(fix.mat)}else{fix.mat<-fix.mat}
 if(scale.var){var.mat<-scale(var.mat)}else{var.mat<-var.mat}
 fix.dist <- vegdist(fix.mat, method=fix.dist.method)
 RES_TOT <- c()
 best.i.comb <- c()
 iter <- 0
 for(i in 1:var.max){
  var.comb <- combn(1:ncol(var.mat), i, simplify=FALSE)
  RES <- data.frame(var.incl=rep(NA, length(var.comb)), n.var=i, rho=0)
  for(f in 1:length(var.comb)){
   iter <- iter+1
   var.dist <- vegdist(as.matrix(var.mat[,var.comb[[f]]]), method=var.dist.method)
   temp <- suppressWarnings(cor.test(fix.dist, var.dist, method="spearman"))
   RES$var.incl[f] <- paste(var.comb[[f]], collapse=",")
   RES$rho[f] <- temp$estimate
   if(iter %% 100 == 0){print(paste(round(iter/combn.sum*100, 3), "% finished"))}
  }
 
  order.rho <- order(RES$rho, decreasing=TRUE)
  best.i.comb <- c(best.i.comb, RES$var.incl[order.rho[1]])
  if(length(order.rho) > output.best){
   RES_TOT <- rbind(RES_TOT, RES[order.rho[1:output.best],])
  } else {
   RES_TOT <- rbind(RES_TOT, RES)
  }
 }
 rownames(RES_TOT)<-NULL
 
 if(dim(RES_TOT)[1] > output.best){
  order.by.best <- order(RES_TOT$rho, decreasing=TRUE)[1:output.best]
 } else {
  order.by.best <- order(RES_TOT$rho, decreasing=TRUE)
 }
 OBB <- RES_TOT[order.by.best,]
 rownames(OBB) <- NULL
 
 order.by.i.comb <- match(best.i.comb, RES_TOT$var.incl)
 OBC <- RES_TOT[order.by.i.comb,]
 rownames(OBC) <- NULL
 
 out <- list(
  order.by.best=OBB,
  order.by.i.comb=OBC,
  best.model.vars=paste(colnames(var.mat)[as.numeric(unlist(strsplit(OBB$var.incl[1], ",")))], collapse=",") ,
  best.model.rho=OBB$rho[1]
 )
 out
}

```

