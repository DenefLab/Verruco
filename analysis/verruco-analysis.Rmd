---
title: "Freshwater Verrucocmicrobia"
author: "Edna Chiang"
date: "July 6, 2015"
output: html_document
---


### Load Libraries
```{r}
library(phyloseq)
library(ggplot2)
library(ape)
library(vegan)
library(plyr)
library(dplyr)
library(scales)
library(grid)
library(reshape2)
library(phangorn)
library(phytools)
library(DESeq2)
library(pander)
library(ade4)
library(labdsv)
library(geiger)
library(sciplot)
library(picante)
library(leaps)
library(pgirmess)
library(car)
theme_set(theme_bw())
set.seed(1)
setwd("~/Verruco/analysis")
```

### Import Data
```{r}
load("VerrucoData.RData")
```


### Visualize overall phyloseq object
```{r}
# Check the sequencing depth of each sample 
sums_verruco <- data.frame(colSums(otu_table(verruco)))
colnames(sums_verruco) <- "Sample_TotalSeqs"
sums_verruco$sample <- row.names(sums_verruco)
sums_verruco <- arrange(sums_verruco, Sample_TotalSeqs)

# Create a plot of the number of sequences per sample
ggplot(sums_verruco, aes(x=reorder(sample,Sample_TotalSeqs),
                         y = Sample_TotalSeqs)) + 
  ylab("Number of Sequences per Sample") +
  geom_bar(stat = "identity", colour="black",fill="cornflowerblue") +
  xlab("Sample Name") + 
  ggtitle("Total Number of Sequences per Sample") + 
  theme(axis.text.x = element_text(colour = "black", size=6, angle=45, hjust = 1,
                                   vjust = 1))

# Look at # of reads
ggplot(data.frame(sum = sample_sums(verruco)), aes(sum)) + 
  geom_histogram(colour = "white", fill = "blue") + 
  ggtitle("Sample read counts") + 
  xlab("total sequences")

# Min, Mean, Max of sample read counts
min(sample_sums(verruco))
mean(sample_sums(verruco))
max(sample_sums(verruco))
```


### Merge Duplicates & create new phyloseq object
```{r}
# Merges duplicates & calculates mean
verr.dupmerge <- merge_samples(verruco, "Duplicates")

## Fix metadata of merged duplicates 
# Grab unique lines (first entry) from verruco phyloseq object metadata
unique.idx <- !(duplicated(sample_data(verruco)$Duplicates))
duplicate.metadata <- sample_data(verruco)[unique.idx, ]

# Fix SampleID and rownames
duplicate.metadata$SampleID <- duplicate.metadata$Duplicates
rownames(duplicate.metadata) <- duplicate.metadata$Duplicates

# Assign new metadata to phyloseq object
sample_data(verr.dupmerge) <- duplicate.metadata

```

### Visualize merged dataset
```{r}
# Check the sequencing depth of each sample 
sums_dupmerge <- data.frame(rowSums(otu_table(verr.dupmerge)))
colnames(sums_dupmerge) <- "Sample_TotalSeqs"
sums_dupmerge$sample <- row.names(sums_dupmerge)
sums_dupmerge <- arrange(sums_dupmerge, Sample_TotalSeqs)

# Create a plot of the number of sequences per sample
ggplot(sums_dupmerge, aes(x=reorder(sample, Sample_TotalSeqs),
                          y = Sample_TotalSeqs)) + 
  ylab("Number of Sequences per Sample") +
  geom_bar(stat = "identity", colour="black",fill="cornflowerblue") +
  xlab("Sample Name") + 
  ggtitle("Total Number of Sequences per Sample") + 
  theme(axis.text.x = element_text(colour = "black", size=6, angle=45, hjust = 1,
                                   vjust = 1))

# Look at # of reads
ggplot(data.frame(sum = sample_sums(verr.dupmerge)), aes(sum)) + 
  geom_histogram(colour = "white", fill = "blue") +
  ggtitle("Sample read counts") + 
  xlab("total sequences")

# Mean, max and min of sample read counts
min(sample_sums(verr.dupmerge))
mean(sample_sums(verr.dupmerge))
max(sample_sums(verr.dupmerge))
```


### Trim & normalize data based on # of reads/sequence depth
```{r}
# Function to normalize data
scale_reads <- function(physeq,n){
  physeq.scale <- transform_sample_counts(physeq, function(x) {round((n*x/sum(x)))})
  #otu_table(physeq.scale) = round(otu_table(physeq.scale))
  physeq.scale = prune_taxa(taxa_sums(physeq.scale) > 0, physeq.scale)
  return(physeq.scale)
}

# Remove North Hypo samples because their reads are seriously too low (8 & 18, respectively)
dupmerge.subset <- subset_samples(physeq = verr.dupmerge, SampleID != "Z14.051.P")
dupmerge.subset <- subset_samples(physeq = dupmerge.subset, SampleID != "Z14.051.F")

# Normalize our dataset!
scaled.buoy <- scale_reads(dupmerge.subset,min(sample_sums(dupmerge.subset)))
  ### Scaled to 2,072 (min sample)
    # 5593 taxa
    # 226 samples

# Remove MLB samples
scaled <- subset_samples(scaled.buoy, Station != "Buoy")

# Order the factors
sample_data(scaled)$Lake_Type <- ordered(sample_data(scaled)$Lake_Type,
                                     levels=c("Laurentian","Estuary","Inland"))
sample_data(scaled)$Fraction <- ordered(sample_data(scaled)$Fraction,
                                     levels = c("Particle","Free","Sediment"))
sample_data(scaled)$Depth <- ordered(sample_data(scaled)$Depth,
                                  levels = c("Surface", "Bottom","Sediment"))
sample_data(scaled)$Season <- ordered(sample_data(scaled)$Season,
                                   levels = c("Spring","Summer","Fall"))

# Check the sequencing depth of each sample 
sums_scaled <- data.frame(rowSums(otu_table(scaled)))
colnames(sums_scaled) <- "Sample_TotalSeqs"
sums_scaled$SampleID <- row.names(sums_scaled)
sums_scaled <- arrange(sums_scaled, Sample_TotalSeqs)

# Create a plot of the number of sequences per sample
ggplot(sums_scaled, aes(x=SampleID, y = Sample_TotalSeqs)) + 
  ylab("Number of Sequences per Sample") +
  geom_bar(stat = "identity", colour="black",fill="cornflowerblue") +
  xlab("Sample Name") + 
  ggtitle("Total Number of Sequences per Sample") + 
  theme(axis.text.x = element_text(colour = "black", size=6, angle=45, hjust = 1,
                                   vjust = 1))

# Let's visualized our normalized dataset
ggplot(data.frame(sum = sample_sums(scaled)), aes(sum)) + 
  geom_histogram(colour = "black", fill = "deeppink") +
  ggtitle("Sample read counts") + 
  xlab("total sequences")
```


### Compare LM and Buoy Samples
```{r}
# Merge samples with the same taxonomic rank
good_phylum.buoy <- tax_glom(scaled.buoy, taxrank = "Phylum")

# Transform each merged phylum count to rel abun
phylum.99.buoy = transform_sample_counts(good_phylum.buoy, function(x){(x/sum(x))*100})

# If a phylum has <1% rel abun, change that to 0%
otu_table(phylum.99.buoy)[otu_table(phylum.99.buoy) < 1] <- 0

# Remove anything with 0% rel abun
phylum.99.buoy <- prune_taxa(taxa_sums(phylum.99.buoy) > 0, phylum.99.buoy)

# Pull out all verruco OTUs
Ver.buoy <- subset_taxa(scaled.buoy, Phylum == "Verrucomicrobia")
  # taxa = 329

# From the phyloseq object of merged Phyla, subset out just Verrucos
Ver.box.phy.buoy <- subset_taxa(phylum.99.buoy, Phylum == "Verrucomicrobia")

# Create dataframe of sample data
Ver.box.buoy <- data.frame(sample_data(Ver.buoy))

# Add in rel abun of Verruco phylum
Ver.box.buoy$Relative_Abundance <- otu_table(Ver.box.phy.buoy)



##### Test for normality #####
hist(Ver.box.buoy$Relative_Abundance)
  # Skewed
shapiro.test(Ver.box.buoy$Relative_Abundance)
    # p-value = 1.602e-10
    # Not Normal
ks.test(Ver.box.buoy$Relative_Abundance, "pnorm",
        mean=mean(Ver.box.buoy$Relative_Abundance),
        sd=sd(Ver.box.buoy$Relative_Abundance))
    # 0.01515
    # Not normal

### Log Transform ###
#Ver.box.buoy.log <- log(Ver.box.buoy$Relative_Abundance)
#hist(Ver.box.buoy.log)
#shapiro.test(Ver.box.buoy.log)
  # p-value = 0.04068
  # Not Normal
#ks.test(Ver.box.buoy.log, "pnorm", mean=mean(Ver.box.buoy.log), sd=sd(Ver.box.buoy.log))
  # p-value = 0.4067
  # Normal
#Ver.box.buoy$Relative_Abundance <- log(Ver.box.buoy$Relative_Abundance)
# Choosing to stick with non-transformed data because the overall Verruco data wasn't log transformed; I want to treat everything equally

##### Check all Lake Michigan Cruise Samples #####
Ver.box.LM <- Ver.box.buoy[which(Ver.box.buoy$Study == "LakeMichigan"),]
Ver.box.LM$Station <- ordered(Ver.box.LM$Station, levels = c("Buoy", "Shore", "Far"))

### Plot! ###
ann_LM <- data.frame(lab=c(" ", "+"),
                       Lake_Type = factor(c("Estuary", "Laurentian"),
                                          levels = c("Estuary", "Laurentian")))
Ver.box.LM.plot1 <- ggplot(Ver.box.LM, aes(x=Station, y= Relative_Abundance, 
                                           fill = Lake_Type)) +
  geom_boxplot(position=position_dodge(1)) +
  ggtitle("Laurentian Cruise Samples") +
  scale_fill_manual(values = c("salmon","turquoise3")) +
  theme(axis.title.x = element_text(face="bold", size=8),
        axis.text.x = element_text(angle=0, colour="black", size=6),
        axis.text.y = element_text(colour="black", size=6),
        axis.title.y = element_text(face="bold", size=8),
        plot.title = element_text(face="bold", size=10, hjust = 0.5),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size = 7),
        strip.text.x = element_blank(),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm")) +
  geom_text(data = ann_LM, aes(label=lab), x=c(1,3), y=c(16,18), size=4, color="red")

### Kruskal-Wallis LM 2013 Samples ###
kruskal.test(formula = Relative_Abundance ~ Station, data = Ver.box.LM)
  # p-value = 0.004545
kruskalmc(resp = Relative_Abundance ~ Station, data = Ver.box.LM)
  # Sig = Buoy-Far, Shore-Far
  # Nonsig = Buoy-Shore
kruskal.test(formula = Relative_Abundance ~ Station, data = Ver.box.LM, subset = Station != "Far")
  # Buoy vs. Shore
  # p-value = 0.3881
kruskal.test(formula = Relative_Abundance ~ Station, data = Ver.box.LM, subset = Station != "Shore")
  # Buoy vs. Far
  # p-value = 0.01045
kruskal.test(formula = Relative_Abundance ~ Station, data = Ver.box.LM, subset = Station != "Buoy")
  # Far vs. Shore
  # p-value = 0.004086
kruskal.test(formula = Relative_Abundance ~ Lake_Type, data = Ver.box.LM)
  # Musk vs. LM
  # p-value = 0.0596
summary(Ver.box.LM[which(Ver.box.LM$Lake_Type == "Estuary"), 13])
summary(Ver.box.LM[which(Ver.box.LM$Lake_Type == "Laurentian"), 13])





##### Compare Buoy to other Estuary samples #####
Ver.box.est <- Ver.box.buoy[which(Ver.box.buoy$Lake_Type == "Estuary"),]
Ver.box.est <- Ver.box.est[which(Ver.box.est$Depth != "Sediment"),]
Ver.box.est$Station <- ordered(Ver.box.est$Station, 
                               levels = c("Buoy","Inlet", "Bear", "Outlet", "Deep"))
Ver.box.est$Cruise <- "Laurentian"
Ver.box.est[which(Ver.box.est$Study == "Muskegon"), 14] <- "Estuary"
Ver.box.est$Cruise <- ordered(Ver.box.est$Cruise, levels = c("Estuary", "Laurentian"))


### Plot!!! ###
ann_est <- data.frame(lab=c("a", "a"),
                       Cruise = factor(c("Estuary", "Laurentian"),
                                          levels = c("Estuary", "Laurentian")))
Ver.box.est.plot <- ggplot(Ver.box.est, aes(x=Station, y=Relative_Abundance,
                                            fill = Cruise)) +
  geom_boxplot(position=position_dodge(1)) + ylim(0,44) +
  ggtitle("Estuary Samples") +
  scale_fill_manual(values = c("turquoise3","salmon")) +
  theme(axis.title.x = element_text(face="bold", size=8),
        axis.text.x = element_text(angle=0, colour="black", size=6),
        axis.text.y = element_text(colour="black", size=6),
        axis.title.y = element_text(face="bold", size=8),
        plot.title = element_text(face="bold", size=10, hjust = 0.5),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size = 7),
        strip.text.x = element_blank(),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm")) +
    geom_text(data = ann_est, aes(label=lab), x=c(1,5), y=c(45,45), size=3, color="red")


### Kruskal-Wallis Estuary Comparisons ###
kruskal.test(formula = Relative_Abundance ~ Station, data = Ver.box.est)
  # All Stations
  # p-value = 0.008687
kruskalmc(resp = Relative_Abundance ~ Station, data = Ver.box.est)
  # Only sig = Buoy-Deep
kruskal.test(formula = Relative_Abundance ~ Station, data = Ver.box.est, subset = Station== "Buoy" | Station == "Deep")
  # Buoy vs. Deep
  # p-value = 0.006862


# There's an outlier in Deep where Verruco rel abund > 40%
# Test when removing outlier
Ver.box.est.out <- Ver.box.est[-which(Ver.box.est$Relative_Abundance > 40),]
kruskal.test(formula = Relative_Abundance ~ Station, data = Ver.box.est.out)
  # All Stations
  # p-value = 0.01431
kruskalmc(resp = Relative_Abundance ~ Station, data = Ver.box.est.out)
  # No sig
kruskal.test(formula = Relative_Abundance ~ Cruise, data = Ver.box.est.out)
  # p-value = 0.01699



### Adjust pvals ###
pvals <- c(0.004545, 0.3881, 0.01045, 0.004086, 0.0596, 0.008687, 0.006862, 0.01431, 0.01699)
comp.kw.vals <- data.frame(pvals)
comp.kw.vals$Lake <- c(rep("LM",5), rep("Est",4))
comp.kw.vals$Comp <- c("All", "BS", "BF", "SF", "LM vs Est", "All", "BD", "All (out)", "All (Cruise)")
comp.kw.vals$Bonf <- p.adjust(comp.kw.vals$pvals, method="bonferroni")
comp.kw.vals$BenH <- p.adjust(comp.kw.vals$pvals, method="BH")




### Plot Comparisons ###
tiff("LM.comp.tiff", width = 15, height = 5, units = "cm", res = 600)
grid.newpage()
pushViewport(viewport(layout=(grid.layout(1,2, widths=c(1,1), heights=c(1,1)))))
print(Ver.box.LM.plot1, vp=viewport(layout.pos.row=1, layout.pos.col=1))
print(Ver.box.est.plot, vp=viewport(layout.pos.row=1, layout.pos.col=2))
dev.off()


```
### Rank abundance curve of top 300 OTUs
```{r}
### Get top 300 most abundant OTUs
top300.taxa <- sort(taxa_sums(scaled), TRUE)[1:300]
top300.OTUs <- prune_taxa(names(top300.taxa), scaled)
top300.sums <- data.frame(taxa_sums(top300.OTUs))

ggplot(top300.sums,aes(x=row.names(top300.sums), y=taxa_sums.top300.OTUs.)) + 
  ylab("Number of Sequences per OTU") + scale_x_discrete(expand = c(0,0)) + 
  scale_y_continuous(expand = c(0,0)) + theme_classic() +
  geom_bar(stat="identity",colour="black",fill="darkturquoise") +
  xlab("OTU Rank") +
  ggtitle("Rank Abundance Curve of the Top 300 OTUs") + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```



### Examine Phyla
```{r}
# Merge samples with the same taxonomic rank
good_phylum <- tax_glom(scaled, taxrank = "Phylum")

# Transform each merged phylum count to rel abun
phylum.99 = transform_sample_counts(good_phylum, function(x){(x/sum(x))*100})

# If a phylum has <1% rel abun, change that to 0%
otu_table(phylum.99)[otu_table(phylum.99) < 1] <- 0

# Remove anything with 0% rel abun
phylum.99 <- prune_taxa(taxa_sums(phylum.99) > 0, phylum.99)

# Create rank abundance of OTUs
top5phyla.barplot <-barplot(sort(taxa_sums(phylum.99),TRUE)[1:5]/nsamples(phylum.99),
  las = 2,
  cex.axis = 0.7, 
  space = F, 
  names.arg = c("Proteobacteria", "Bacteroidetes","Actinobacteria", "Verrucomicrobia", "Cyanobacteria"), 
  col = c("khaki1", "mediumorchid3", "firebrick3", "lightslateblue", "chartreuse3"), 
  main = "Top 5 Bacterial Phyla", 
  xlab = "Phylum", 
  ylab = "Relative Abundance (%)", 
  ylim = c(0, 35), 
  las = 0
)

```

### Phyla-level bar plot
```{r}
# Summarize data by Lake_Type
phy.df <- psmelt(phylum.99)
phy.sum <- phy.df %>%
  group_by(Lake_Type, Phylum, Fraction, Season) %>%
  summarize(Mean = mean(Abundance),
            Median = median(Abundance),
            SD = sd(Abundance),
            SE = se(Abundance),
            iqr = IQR(Abundance))

# Calculate IQR limits
phy.sum$iqr.min <- phy.sum$Median - 0.5*phy.sum$iqr
phy.sum[which(phy.sum$iqr.min < 0),10] <- 0
  # Any IQR min < 0, change to 0 (otherwise error bar won't plot)
phy.sum$iqr.max <- phy.sum$Median + 0.5*phy.sum$iqr


# Remove phyla that are <1% rel abun (median) in all 3 Lake Types
phy.trim <- phy.sum[-which(phy.sum$Phylum== "BD1-5"),]
phy.trim <- phy.trim[-which(phy.trim$Phylum== "Candidate_division_OD1"),]
phy.trim <- phy.trim[-which(phy.trim$Phylum== "Candidate_division_OP3"),] 
phy.trim <- phy.trim[-which(phy.trim$Phylum== "Candidate_division_OP8"),] 
phy.trim <- phy.trim[-which(phy.trim$Phylum== "Candidate_division_SR1"),]
phy.trim <- phy.trim[-which(phy.trim$Phylum== "Fibrobacteres"),]
phy.trim <- phy.trim[-which(phy.trim$Phylum== "Firmicutes"),] 
phy.trim <- phy.trim[-which(phy.trim$Phylum== "Gemmatimonadetes"),] 
phy.trim <- phy.trim[-which(phy.trim$Phylum== "Lentisphaerae"),] 
phy.trim <- phy.trim[-which(phy.trim$Phylum== "NPL-UPA2"),] 
phy.trim <- phy.trim[-which(phy.trim$Phylum== "TM6"),] 
phy.trim$Phylum <- ordered(phy.trim$Phylum, levels=c("Verrucomicrobia", "unclassified", "Spirochaetae", "Proteobacteria", "Planctomycetes", "Nitrospirae", "Cyanobacteria", "Chloroflexi", "Chlorobi", "Candidate_division_WS3", "Bacteroidetes", "Armatimonadetes", "Actinobacteria", "Acidobacteria"))

# Set phylum plotting colors for 14 taxa
phylum.colors <- c(Acidobacteria = "cornsilk3",
                   Actinobacteria="firebrick3",
                   Armatimonadetes="lightsalmon",
                   Bacteroidetes="lightblue1",
                   Candidate_division_WS3 = "lightgreen",
                   Chlorobi="goldenrod1",
                   Chloroflexi="plum1",
                   Cyanobacteria="#33a02c",
                   Nitrospirae = "deepskyblue",
                   Planctomycetes="tomato4",
                   Proteobacteria="khaki1",
                   Spirochaetae = "indianred3",
                   unclassified = "dimgray",
                   Verrucomicrobia="lightslateblue")

##### PLOT #####

label_rev <- function(labels) {
  label_value(rev(labels))
}


#png("phy.relabund.png", width = 17.8, height = 23, units = "cm", res = 600)
ggplot(phy.trim, aes(x=Phylum, y=Median, fill=Phylum)) +
          geom_bar(stat="identity", color="black") +
          scale_fill_manual(values = phylum.colors, name="Phylum") +
  geom_errorbar(aes(ymax=iqr.max, ymin=iqr.min), width=0.25) + 
  xlab("Phyla") + ylab("Median Relative Abundance (Taxa > 1%)") +
  facet_grid(Fraction + Season ~ Lake_Type, space="free", scales = "free_x",
             labeller = label_rev) +
  coord_flip() +
  scale_y_continuous(breaks = c(0,5,10,15,20,25,30,35,40,45,50), limits = c(0,51)) +
          theme(axis.title.x = element_text(size=10, face="bold"),
                axis.text.x = element_text(size=8),
                axis.text.y = element_blank(),
                axis.ticks.y = element_blank(),
                axis.title.y = element_text(size=10, face="bold"),
                plot.title = element_text(size = 12, face="bold", hjust=0.5),
                legend.title = element_text(size=10, face="bold"),
                legend.text = element_text(size =8),
                strip.text.x = element_text(size=10, face="bold"),
                strip.text.y = element_text(size=10, face="bold"),
                plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
                strip.background = element_blank(),
                legend.position="right") +
  guides(fill = guide_legend(reverse=TRUE, keywidth = 0.75, keyheight = 0.75))
#dev.off()


```

### Separate out Verrucos
```{r}
# Pull out all verruco OTUs
Ver <- subset_taxa(scaled, Phylum == "Verrucomicrobia")
  # taxa = 329

# Check the sequencing depth of Verrucos each sample 
sums_Ver <- data.frame(rowSums(otu_table(Ver)))
colnames(sums_Ver) <- "Sample_TotalSeqs"
sums_Ver$sample <- row.names(sums_Ver)
sums_Ver <- arrange(sums_Ver, Sample_TotalSeqs)
summary(sums_Ver)

####  Create a plot of the number of Verruco sequences per sample
ggplot(sums_Ver, aes(x=reorder(sample, Sample_TotalSeqs), y = Sample_TotalSeqs)) + 
  ylab("Number of Sequences per Sample") +
  geom_bar(stat = "identity", colour="black",fill="cornflowerblue")  + xlab("Sample Name") + 
  ggtitle("Total Number of Sequences per Sample") + 
  theme(axis.text.x = element_text(colour = "black", size=6, angle=45, hjust = 1, vjust = 1))

```

### Verruco Relative Abundance to test normality
```{r}
# Transforms each merged phylum count to rel abun
Ver.rel <- transform_sample_counts(Ver, function(x){x/sum(x)})

# If a phylum has <1% rel abun, change that to 0%
otu_table(Ver.rel)[otu_table(Ver.rel)<.01] <- 0

# Remove anything with 0% rel abun
Ver.rel = prune_taxa(taxa_sums(Ver.rel)>0,Ver.rel)
  # Remove taxa = 135
  # Remain taxa = 208

# Create rank abundance of OTUs
barplot(sort(taxa_sums(Ver.rel),TRUE)[1:20]/nsamples(Ver.rel),las=2,cex.axis=.7)
    ## 1 = OPB35_soil_group
    ## 2 = OPB35_soil_group
    ## 3 = Opitutae - vadinHA64
    ## 4 = Spartobacteria - Chthoniobacterales - FukuN18_freshwater_Lake_Type
    ## 5 = Verrucomicrobiae - Verrucomicrobiales - Verrucomicrobiaceae

Ver.otu <- as.numeric(otu_table(Ver.rel))
hist(Ver.otu)
    ## So skewed that I can't even get a legit histogram from it
qqnorm(Ver.otu)
qqline(Ver.otu)
    ## Looks exponentially distributed

# Test for normality
shapiro.test(Ver.otu)
    ## Too many samples
ks.test(Ver.otu, "pnorm", mean=mean(Ver.otu), sd=sd(Ver.otu))
    # p-value = 0
    # Not normal
ks.test(Ver.otu, "pexp")
    ## p-value = 9
    ## not exponentially distributed
Ver.otu <- Ver.otu + 1

#### Log Transformation ####
Ver.log <- log(Ver.otu)
hist(Ver.log)
    ## Still not normal
    ## Skewed to the right
qqnorm(Ver.log)
qqline(Ver.log)
ks.test(Ver.log, "pnorm", mean=mean(Ver.otu), sd=sd(Ver.otu))
    ## p=value = 0
    ## Not normal

### Verruco Intra-Phylum Rel Abun is NOT NORMAL

```


### Intra-Verruco Rel Abund
```{r}
# Merge all Verruco OTUs by Class
classVer <- tax_glom(Ver, taxrank = "Class")

# Calculate relative abundance
classVer.rel = transform_sample_counts(classVer, function(x){x/sum(x)})

# If a phylum has <1% rel abun, change that to 0%
otu_table(classVer.rel)[otu_table(classVer.rel)<.01] <- 0

# Remove anything with 0% rel abun
classVer.rel = prune_taxa(taxa_sums(classVer.rel)>0,classVer.rel)

# Create rank abundance of OTUs
barplot(sort(taxa_sums(classVer.rel),TRUE)[1:20]/nsamples(classVer.rel),las=2,cex.axis=.7)



# Create dataframe to use in ggplot
classVer.df <- psmelt(classVer.rel)
classVer.df$Abundance <- classVer.df$Abundance * 100
classVer.df$Class <- ordered(classVer.df$Class, levels=c("unclassified","Verrucomicrobiae","Verrucomicrobia_Incertae_Sedis","Spartobacteria","S-BQ2-57_soil_group","Opitutae","OPB35_soil_group"))

# Colors that will be used in ggplot
Ver.colors <- c("OPB35_soil_group" = "#e41a1c", Opitutae = "#377eb8", "S-BQ2-57_soil_group" = "#984ea3", Spartobacteria = "#4daf4a", "Verrucomicrobia_Incertae_Sedis" = "#ff7f00", Verrucomicrobiae = "#ffd92f", unclassified="#f1a3a9")






##### Fraction + Season & Lake_Type facet #####

# Pull out the factors that I'll be using to make my graph
sub.classVer.df <- subset(classVer.df, select = c("Sample","Lake_Type", "Class", "Abundance","Fraction", "Season"))

# Calculate stat summaries
lakefracseas <- ddply(sub.classVer.df, c("Lake_Type", "Class", "Fraction", "Season"), summarise,
                   Mean = mean(Abundance),
                   Median = median(Abundance),
                   SD = sd(Abundance),
                   SE = se(Abundance),
                   iqr = IQR(Abundance))

# Calculate IQR limits
lakefracseas$iqr.min <- lakefracseas$Median - 0.5*lakefracseas$iqr
lakefracseas[which(lakefracseas$iqr.min < 0), 10] <- 0
  # Any IQR min < 0, change to 0 (otherwise error bar won't plot)
lakefracseas$iqr.max <- lakefracseas$Median + 0.5*lakefracseas$iqr


###### THIS ONE!!!!!!!! ######

# This command is used to rearrange the vertical facet labels so that Fraction is on the outside & Season is on the inside
label_rev <- function(labels) {
  label_value(rev(labels))
}

#tiff("intraver.tiff", width = 17.8, height = 18, units = "cm", res = 600)
ggplot(lakefracseas, aes(y=Median, x = Class, fill = Class)) +
  facet_grid(Fraction + Season ~ Lake_Type, labeller= label_rev)   +
  geom_bar(stat="identity", position=position_dodge()) +
  scale_fill_manual(values = Ver.colors, name = "Class") +
  theme_bw() + ggtitle("Verrucomicrobia Classes Above 1%") + coord_flip() +
  geom_errorbar(aes(ymin = iqr.min, ymax = iqr.max), width = 0.25) + 
  xlab("Class") + ylab("Median Relative Abundance (%)") +
  theme(axis.title.x = element_text(face="bold", size=10),
        axis.text.x = element_text(colour = "black", size=8),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.y = element_text(face="bold", size=10),
        plot.title = element_text(face="bold", size = 12, hjust=0.5),
        strip.text.x = element_text(size=10, face="bold"),
        strip.text.y = element_text(size=10, face="bold"),
        legend.title = element_text(size=10, face="bold"),
        legend.text = element_text(size=8),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        strip.background = element_blank(),
        legend.position="right") +
  guides(fill = guide_legend(reverse=TRUE))
#dev.off()

```



### Box-And-Whisker Plots
```{r}
# From the phyloseq object of merged Phyla, subset out just Verrucos
Ver.box.phy <- subset_taxa(phylum.99, Phylum == "Verrucomicrobia")

# Create dataframe of sample data
Ver.box <- data.frame(sample_data(Ver))

# Add in rel abun of Verruco phylum
Ver.box$Relative_Abundance <- otu_table(Ver.box.phy)


##### Test for Normality #####
# Visualize
hist(Ver.box$Relative_Abundance)
    ## So skewed that I can't even get a legit histogram from it
qqnorm(Ver.box$Relative_Abundance)
qqline(Ver.box$Relative_Abundance)

# Test for normality
shapiro.test(Ver.box$Relative_Abundance)
    # Not Normal
ks.test(Ver.box$Relative_Abundance, "pnorm",
        mean=mean(Ver.box$Relative_Abundance),
        sd=sd(Ver.box$Relative_Abundance))
    # p-value = 0.015
    # Not normal

# Visualize Log
hist(log(Ver.box$Relative_Abundance))
    # Yay! Looks so pretty!
qqnorm(log(Ver.box$Relative_Abundance))
qqline(log(Ver.box$Relative_Abundance))


# Test for normality
shapiro.test(log(Ver.box$Relative_Abundance))
    # p-value = 0.04068
    # Not Normal
ks.test(log(Ver.box$Relative_Abundance), "pnorm",
        mean=mean(log(Ver.box$Relative_Abundance)),
        sd=sd(log(Ver.box$Relative_Abundance)))
    # p-value = 0.4067
    # Not exponentially distributed


### Plotting Time!

### Fraction ###

Ver.box.frac <- Ver.box[Ver.box$Fraction != "Sediment",]

ann_text <- data.frame(lab=c("*", " ", "*"),
                       Lake_Type = factor(c("Laurentian", "Estuary", "Inland"),
                                          levels = c("Laurentian", "Estuary",
                                                     "Inland")),
                       Fraction = factor(c("Particle", "Free", "Free")))

#tiff("boxplot.tiff", width = 8.7, height = 8.7, units = "cm", res = 600)
frac.box <- ggplot(Ver.box.frac, aes(x=Lake_Type, y=Relative_Abundance, fill=Fraction)) +
  geom_boxplot(position=position_dodge(1)) +
  scale_fill_manual(values = c("rosybrown","gold")) + 
  xlab("Lake Type") + ylab("Relative Abundance (%)") +
  facet_grid(~ Lake_Type, space = "free_x", scale="free") +
  theme(axis.title.x = element_text(face="bold", size=8),
        axis.text.x = element_text(angle=0, colour="black", size=6),
        axis.text.y = element_text(colour="black", size=6),
        axis.title.y = element_text(face="bold", size=8),
        plot.title = element_text(face="bold", size=8),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size = 7),
        strip.text.x = element_blank(),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm")) + # top, right, bottom, left
  geom_text(data = ann_text, aes(label=lab), x=c(1,1,1), y=c(41,41,41), size=3, color="red")
#dev.off()


### Season ###

# This is the annotation text for the plot below (seas.box)
# Since the plot is facetted and you have different text in each facet, you have to use geom_text and call on the dataframe made below (ann_text)
ann_text <- data.frame(lab=c(" ", " ", "+"),
                       Lake_Type = factor(c("Laurentian", "Estuary", "Inland"),
                                          levels = c("Laurentian", "Estuary",
                                                     "Inland")),
                       Season = factor(c("Spring", "Summer", "Fall")))

seas.box <- ggplot(Ver.box, aes(x=Lake_Type, y=Relative_Abundance, fill=Season)) +
  geom_boxplot(position=position_dodge(1)) +
  #scale_fill_manual(values = c("indianred1","skyblue2","mediumpurple2")) +
  xlab("Lake Type") + ylab("Relative Abundance (%)") +
  facet_grid(~ Lake_Type, space = "free_x", scale="free") +
  theme(axis.title.x = element_text(face="bold", size=8),
        axis.text.x = element_text(angle=0, colour="black", size=6),
        axis.text.y = element_text(colour="black", size=6),
        axis.title.y = element_text(face="bold", size=8),
        plot.title = element_text(face="bold", size=8),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size = 7),
        strip.text.x = element_blank(),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm")) + # top, right, bottom, left
  geom_text(data = ann_text, aes(label=lab), x=c(1,1,1.33), y=c(42,42,42), size=3, color="red")



### Depth ###

# This is the annotation text for the plot below (seas.box)
# Since the plot is facetted and you have different text in each facet, you have to use geom_text and call on the dataframe made below (ann_text)
ann2_text <- data.frame(lab=c(" ", "+", "*"),
                       Lake_Type = factor(c("Laurentian", "Estuary", "Inland"),
                                          levels = c("Laurentian", "Estuary",
                                                     "Inland")),
                       Depth = factor(c("Surface", "Bottom", "Sediment")))

#tiff("boxplot.tiff", width = 8.7, height = 8.7, units = "cm", res = 600)
depth.box <- ggplot(Ver.box, aes(x=Lake_Type, y=Relative_Abundance, fill=Depth)) +
  geom_boxplot(position=position_dodge(1)) +
  scale_fill_manual(values = c("cadetblue1","dodgerblue3","purple3")) +
  xlab("Lake Type") + ylab("Relative Abundance (%)") +
  facet_grid(~ Lake_Type, space = "free_x", scale="free") +
  theme(axis.title.x = element_text(face="bold", size=8),
        axis.text.x = element_text(angle=0, colour="black", size=6),
        axis.text.y = element_text(colour="black", size=6),
        axis.title.y = element_text(face="bold", size=8),
        plot.title = element_text(face="bold", size=8),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size = 7),
        strip.text.x = element_blank(),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm")) + # top, right, bottom, left
  geom_text(data = ann2_text, aes(label=lab), x=c(1,1.33,1), y=c(42,42,41), size=3, color="red")
#dev.off()



# tiff("boxplot.tiff", width = 8.7, height = 10, units = "cm", res = 600)
# grid.newpage()
# pushViewport(viewport(layout=(grid.layout(1,2, widths=c(7,2.15), heights=c(1)))))
# print(plot, vp=viewport(layout.pos.row=1, layout.pos.col=1))
# legend$vp <- viewport(layout.pos.row = 1, layout.pos.col = 2)
# grid.draw(legend)
# dev.off()


##### Kruskal-Wallis #####

### Test between lake types ###
kruskal.test(formula = Relative_Abundance ~ Lake_Type, data = Ver.box)
  # All Lake Types
  # p-value = 1.728e-10
kruskalmc(resp = Relative_Abundance ~ Lake_Type, data = Ver.box)
  # Laur vs Est, Laur vs Inl = sig
  # Est vs Inl = nonsig
kruskal.test(formula = Relative_Abundance ~ Lake_Type, data = Ver.box, subset=Lake_Type=="Laurentian" | Lake_Type=="Estuary")
  # Laurentian vs Estuary
  # p-value = 1.152e-08
kruskal.test(formula = Relative_Abundance ~ Lake_Type, data = Ver.box, subset=Lake_Type=="Laurentian" | Lake_Type=="Inland")
  # Laurentian vs Inland
  # p-value = 1.206e-10
kruskal.test(formula = Relative_Abundance ~ Lake_Type, data = Ver.box, subset=Lake_Type=="Estuary" | Lake_Type=="Inland")
  # Estuary vs Inland
  # p-value = 0.4838


### Test Fraction  ###
kruskal.test(formula = Relative_Abundance ~ Fraction, data = Ver.box)
  # All Fraction
  # p-value = 8.544e-05
kruskal.test(formula = Relative_Abundance ~ Source, data = Ver.box)
  # All Source
  # p-value = 0.0001279
kruskalmc(resp = Relative_Abundance ~ Fraction, data = Ver.box)
  # Part-Sed, Free-Sed = Sig
  # Part-Free = nonsig
kruskal.test(formula = Relative_Abundance ~ Fraction, data = Ver.box, subset = Fraction != "Sediment")
  # All Free vs Part
  # p-value = 0.04143
kruskal.test(formula = Relative_Abundance ~ Fraction, data = Ver.box, subset = Fraction != "Free")
  # All Part vs Sed
  # p-value = 0.0007238
kruskal.test(formula = Relative_Abundance ~ Fraction, data = Ver.box, subset = Fraction != "Particle")
  # All Free vs Sed
  # p-value = 4.624e-05

# Laurentian
kruskal.test(formula = Relative_Abundance ~ Fraction, data = Ver.box, subset=Lake_Type=="Laurentian")
  # Fraction
  # p-value = 0.01748

# Estuary
kruskal.test(formula = Relative_Abundance ~ Source, data = Ver.box, subset=Lake_Type=="Estuary")
  # Source
  # p-value = 7.625e-07
kruskalmc(resp = Relative_Abundance ~ Fraction, data = Ver.box, subset=Lake_Type=="Estuary")
  # Part-Sed, Free-Sed = Sig
  # Part-Free = Nonsig
kruskal.test(formula = Relative_Abundance ~ Fraction, data = Ver.box, subset=Lake_Type=="Estuary" & Fraction != "Sediment")
  # Free vs Part
  # p-value = 0.1158
kruskal.test(formula = Relative_Abundance ~ Fraction, data = Ver.box, subset=Lake_Type=="Estuary" & Fraction != "Free")
  # Part vs Sed
  # p-value = 5.505e-06
kruskal.test(formula = Relative_Abundance ~ Fraction, data = Ver.box, subset=Lake_Type=="Estuary" & Fraction != "Particle")
  # Free vs Sed
  # p-value = 9.424e-06

# Inland
kruskal.test(formula = Relative_Abundance ~ Fraction, data = Ver.box, subset=Lake_Type=="Inland")
  # Fraction
  # p-value = 3.624e-05


### Test Season ###
kruskal.test(formula = Relative_Abundance ~ Season, data = Ver.box)
  # All Season
  # p-value = 0.6316
kruskalmc(resp = Relative_Abundance ~ Season, data = Ver.box)
  # Nonsig

# Laurentian
kruskal.test(formula = Relative_Abundance ~ Season, data = Ver.box, subset=Lake_Type=="Laurentian")
  # Season
  # p-value = 0.241
kruskalmc(resp = Relative_Abundance ~ Season, data = Ver.box, subset=Lake_Type=="Laurentian")
  # nonsig

# Estuary
kruskal.test(formula = Relative_Abundance ~ Season, data = Ver.box, subset=Lake_Type=="Estuary")
  # Season
  # p-value = 0.08429
kruskalmc(resp = Relative_Abundance ~ Season, data = Ver.box, subset=Lake_Type=="Estuary")
  # Nonsig

# Inland
kruskal.test(formula = Relative_Abundance ~ Season, data = Ver.box, subset=Lake_Type=="Inland")
  # Season
  # p-value = 0.0009751
kruskalmc(resp = Relative_Abundance ~ Season, data = Ver.box, subset=Lake_Type=="Inland")
kruskal.test(formula = Relative_Abundance ~ Season, data = Ver.box, subset=Lake_Type=="Inland" & Season != "Spring")
  # Summer vs Fall
  # p-value = 0.0005545
kruskal.test(formula = Relative_Abundance ~ Season, data = Ver.box, subset=Lake_Type=="Inland" & Season != "Summer")
  # Spring vs Fall
  # p-value = 0.0007583
kruskal.test(formula = Relative_Abundance ~ Season, data = Ver.box, subset=Lake_Type=="Inland" & Season != "Fall")
  # Spring vs Summer
  # p-value = 0.3826

### Test Depth ###
kruskal.test(formula = Relative_Abundance ~ Depth, data = Ver.box)
  # All Depth
  # p-value = 0.0006495
kruskalmc(resp = Relative_Abundance ~ Depth, data = Ver.box)
  # Water sig from sed
kruskal.test(formula = Relative_Abundance ~ Depth, data = Ver.box, subset = Depth !="Sediment")
  # All Sur vs Bot
  # p-value = 0.8849

# Laurentian
kruskal.test(formula = Relative_Abundance ~ Depth, data = Ver.box, subset=Lake_Type=="Laurentian")
  # Depth
  # p-value = 0.07562

# Estuary
kruskal.test(formula = Relative_Abundance ~ Depth, data = Ver.box, subset=Lake_Type=="Estuary")
  # Depth
  # p-value = 3.29e-06
kruskalmc(resp = Relative_Abundance ~ Depth, data = Ver.box, subset=Lake_Type=="Estuary")
  # Water sig from sed
kruskal.test(formula = Relative_Abundance ~ Source, data = Ver.box, subset=Lake_Type=="Estuary")
  # Water vs Sediment
  # p-value = 7.625e-07
kruskal.test(formula = Relative_Abundance ~ Depth, data = Ver.box, subset=Lake_Type=="Estuary" & Source == "Water")
  # Sur vs Bot
  # p-value = 0.2803
kruskal.test(formula = Relative_Abundance ~ Depth, data = Ver.box, subset=Lake_Type=="Estuary" & Depth != "Surface")
  # Bot vs Sed
  # p-value = 5.505e-06
kruskal.test(formula = Relative_Abundance ~ Depth, data = Ver.box, subset=Lake_Type=="Estuary" & Depth != "Bottom")
  # Sur vs Sed
  # p-value = 9.424e-06

# Inland
kruskal.test(formula = Relative_Abundance ~ Depth, data = Ver.box, subset=Lake_Type=="Inland")
  # Depth
  # p-value = 0.02212

##### Adjust P-Values #####
pvals <- c(1.152e-08, 1.206e-10, 0.4838, 8.544e-05, 0.0001279, 0.04143,
           0.0007238, 4.624e-05, 0.01748, 7.625e-07, 0.1158, 5.505e-06,
           9.424e-06, 3.624e-05, 0.6103, 0.241, 0.08429, 0.0009751,
           0.0005545, 0.0007583, 0.3826, 0.0006495, 0.8849, 0.07562,
           3.29e-06, 7.625e-07, 0.2803, 5.505e-06, 9.424e-06, 0.02212)
boxplot.kw.vals <- data.frame(pvals)
boxplot.kw.vals$Lake <- c("LE", "LI", "EI", "All", "All", "All", "All", "All", "L", "E", "E", "E", "E", "I", "All", "L", "E", "I", "I", "I", "I", "All", "All", "L", "E", "E", "E", "E", "E", "I")
boxplot.kw.vals$Comp <- c("Lake", "Lake", "Lake", "Frac", "Source", "PF", "PS", "FS", "Frac", "Source", "PF", "PS", "FS", "Frac", "Seas", "Seas", "Seas", "Seas", "SuFa", "SpFa", "SpSu", "Depth", "TB", "Depth", "Depth", "WS", "TB", "BS", "TS", "Depth")
boxplot.kw.vals$Bonf <- p.adjust(boxplot.kw.vals$pvals, method="bonferroni")
boxplot.kw.vals$BenH <- p.adjust(boxplot.kw.vals$pvals, method="BH")
```


### Linear Model
```{r}
# Read in metadata files
lau.env <- read.table("metadata/metadata_laurentian.csv", header=T, sep=",",
                      row.names=1, as.is=T)
est.env <- read.table("metadata/metadata_estuary.csv", header=T, sep=",",
                      row.names=1, as.is=T)
est.env <- est.env[,-27]
  # Remove DO %
inl.env <- read.table("metadata/metadata_inland.csv", header=T, sep=",",
                      row.names=1, as.is=T)

# Subset out Verrucos
Ver.phy <- subset_taxa(phylum.99, Phylum == "Verrucomicrobia")

# Remove samples that have NAs in the metadata
trim.otus <- subset_samples(Ver.phy, SampleID != "Su13.ED.MM15.DN")
trim.otus <- subset_samples(trim.otus, SampleID != "Su13.BD.MM15.DN")
trim.otus <- subset_samples(trim.otus, SampleID != "Sp13.ED.MM15.SN")
trim.otus <- subset_samples(trim.otus, SampleID != "Sp13.ED.MM15.DD")
trim.otus <- subset_samples(trim.otus, SampleID != "Sp13.ED.MM110.DD")
trim.otus <- subset_samples(trim.otus, SampleID != "Sp13.BD.MM15.DD")
trim.otus <- subset_samples(trim.otus, SampleID != "Sp13.BD.MM110.DD")
trim.otus <- subset_samples(trim.otus, SampleID != "Fa13.BD.MM110.SD")
trim.otus <- subset_samples(trim.otus, SampleID != "Fa13.BD.MM110.SN")
trim.otus <- subset_samples(trim.otus, SampleID != "Fa13.BD.MM15.DN")
trim.otus <- subset_samples(trim.otus, SampleID != "Fa13.ED.MM15.DN")
trim.otus <- subset_samples(trim.otus, Station != "Buoy")
trim.otus <- subset_samples(trim.otus, Source != "Sediment")
trim.otus <- subset_samples(trim.otus, SampleID != "Z14.060.P")
trim.otus <- subset_samples(trim.otus, SampleID != "Z14.060.F")

# Categorize samples by lake
Ver.lau <- subset_samples(trim.otus, Lake_Type == "Laurentian")
Ver.est <- subset_samples(trim.otus, Lake_Type == "Estuary")
Ver.inl <- subset_samples(trim.otus, Lake_Type == "Inland")

# Prepare metadata
lau.samp <- sample_data(lau.env)
est.samp <- sample_data(est.env)
inl.samp <- sample_data(inl.env)

# Make new phyloseq object with metadata
lau.phy <- merge_phyloseq(Ver.lau, lau.samp)
est.phy <- merge_phyloseq(Ver.est, est.samp)
inl.phy <- merge_phyloseq(Ver.inl, inl.samp)

# Convert pyloseq to dataframe
lau.df <- psmelt(lau.phy)
est.df <- psmelt(est.phy)
inl.df <- psmelt(inl.phy)

### Look for correlations between environmental factors
pairs(lau.df[21:35])
  # Using DO, Temp. & SiO2
pairs(est.df[21:37])
  # Using ORP, Temp, TDS, Chl, & SO4
pairs(inl.df[21:26])
  # Using SRP, Chl, & NH4


####### Fit data to linear model #######
# http://www.r-bloggers.com/simple-linear-regression-2/

##### Laurentian #####
xyplot(log(Abundance) ~ DO.Probe..mg.L., lau.df)
lau.DO <- lm(DO.Probe..mg.L.~ log(Abundance), lau.df)
summary(lau.DO)
confint(lau.DO, level=0.95)
  # Linear

xyplot(log(Abundance) ~ Temperature..C., lau.df)
lau.temp <- lm(Temperature..C.~log(Abundance), lau.df)
summary(lau.temp)
confint(lau.temp, level=0.95)
  # Says linear, but R2 is essentially 0

xyplot(log(Abundance) ~ SiO2.mg.L, lau.df)
lau.Si <- lm(SiO2.mg.L~log(Abundance), lau.df)
summary(lau.Si)
confint(lau.Si, level=0.95)
  # Linear



### Unused environmental factors
xyplot(log(Abundance) ~ DOC.mg.L, lau.df)
lau.DOC <- lm(DOC.mg.L~log(Abundance), lau.df)
summary(lau.DOC)
confint(lau.DOC, level=0.95)
  # Negative R2
xyplot(log(Abundance) ~ TP.ug.L, lau.df)
lau.TP <- lm(TP.ug.L~log(Abundance), lau.df)
summary(lau.TP)
confint(lau.TP, level=0.95)
  # Not linear
xyplot(log(Abundance) ~ PON.mg.L, lau.df)
lau.PON <- lm(PON.mg.L~log(Abundance), lau.df)
summary(lau.PON)
confint(lau.PON, level=0.95)
  # Not linear
xyplot(log(Abundance) ~ PAR, lau.df)
lau.PAR <- lm(PAR~log(Abundance), lau.df)
summary(lau.PAR)
confint(lau.PAR, level=0.95)
  # Negative R2
xyplot(log(Abundance) ~ Chl.Probe...g.L., lau.df)
lau.Chl.p <- lm(Chl.Probe...g.L.~log(Abundance), lau.df)
summary(lau.Chl.p)
confint(lau.Chl.p, level=0.95)
  # Not linear
xyplot(log(Abundance) ~ Chl.Lab..ug.L., lau.df)
lau.Chl.l <- lm(Chl.Lab..ug.L.~log(Abundance), lau.df)
summary(lau.Chl.l)
confint(lau.Chl.l, level=0.95)
  # Not linear
xyplot(log(Abundance) ~ PP.ug.L, lau.df)
lau.PP <- lm(PP.ug.L~log(Abundance), lau.df)
summary(lau.PP)
confint(lau.PP, level=0.95)
  # Not linear
xyplot(log(Abundance) ~ TDP.ug.L, lau.df)
lau.TDP <- lm(TDP.ug.L~log(Abundance), lau.df)
summary(lau.TDP)
confint(lau.TDP, level=0.95)
  # Not linear
xyplot(log(Abundance) ~ TDP.SRP, lau.df)
lau.TDP.SRP <- lm(TDP.SRP~log(Abundance), lau.df)
summary(lau.TDP.SRP)
confint(lau.TDP.SRP, level=0.95)
  # Negative R2
xyplot(log(Abundance) ~ POC.mg.L, lau.df)
lau.POC <- lm(POC.mg.L~log(Abundance), lau.df)
summary(lau.POC)
confint(lau.POC, level=0.95)
  # Not linear
xyplot(log(Abundance) ~ TSS.mg.L, lau.df)
lau.TSS <- lm(TSS.mg.L~log(Abundance), lau.df)
summary(lau.TSS)
confint(lau.TSS, level=0.95)
  # Not linear
xyplot(log(Abundance) ~ Fluorescence.mg.m3., lau.df)
lau.fluor <- lm(Fluorescence.mg.m3.~log(Abundance), lau.df)
summary(lau.fluor)
confint(lau.fluor, level=0.95)
  # Not linear




##### Estuary #####
xyplot(log(Abundance) ~ ORP..mV., est.df)
est.ORP <- lm(ORP..mV.~log(Abundance), est.df)
summary(est.ORP)
confint(est.ORP, level=0.95)
  # Linear
xyplot(log(Abundance) ~ Temperature..C., est.df)
est.temp <- lm(Temperature..C.~log(Abundance), est.df)
summary(est.temp)
confint(est.temp, level=0.95)
  # LINEARRRRR
xyplot(log(Abundance) ~ TDS..mg.L., est.df)
est.TDS <- lm(TDS..mg.L.~log(Abundance), est.df)
summary(est.TDS)
confint(est.TDS, level=0.95)
  # LINEARRRRRR
xyplot(log(Abundance) ~ NO3.mg.L, est.df)
est.NO3 <- lm(NO3.mg.L~log(Abundance), est.df)
summary(est.NO3)
confint(est.NO3, level=0.95)
  # LINEARRRRRR


### Unused environmental factors
xyplot(log(Abundance) ~ pH, est.df)
est.pH <- lm(pH~log(Abundance), est.df)
summary(est.pH)
confint(est.pH, level=0.95)
  # LINEARRRRRR
xyplot(log(Abundance) ~ Cl.mg.L, est.df)
est.Cl <- lm(Cl.mg.L~log(Abundance), est.df)
summary(est.Cl)
confint(est.Cl, level=0.95)
  # LINEARRRRRR
xyplot(log(Abundance) ~ SRP.ug.L, est.df)
est.SRP <- lm(SRP.ug.L~log(Abundance), est.df)
summary(est.SRP)
confint(est.SRP, level=0.95)
  # Not linear
xyplot(log(Abundance) ~ Alk.mg.L, est.df)
est.Alk <- lm(Alk.mg.L~log(Abundance), est.df)
summary(est.Alk)
confint(est.Alk, level=0.95)
  # LINEARRRRR
xyplot(log(Abundance) ~ Turb.NTU, est.df)
est.Turb <- lm(Turb.NTU~log(Abundance), est.df)
summary(est.Turb)
confint(est.Turb, level=0.95)
  # Negative R2
xyplot(log(Abundance) ~ SpCond...S.cm., est.df)
est.SpCond <- lm(SpCond...S.cm.~log(Abundance), est.df)
summary(est.SpCond)
confint(est.SpCond, level=0.95)
  # LINEARRRRR
xyplot(log(Abundance) ~ Chl.Lab..ug.L., est.df)
est.Chl <- lm(Chl.Lab..ug.L.~log(Abundance), est.df)
summary(est.Chl)
confint(est.Chl, level=0.95)
  # Linear
xyplot(log(Abundance) ~ BGA.cells.mL, est.df)
est.BGA <- lm(BGA.cells.mL~log(Abundance), est.df)
summary(est.BGA)
confint(est.BGA, level=0.95)
  # Not linear
xyplot(log(Abundance) ~ SO4.mg.L, est.df)
est.SO4 <- lm(SO4.mg.L~log(Abundance), est.df)
summary(est.SO4)
confint(est.SO4, level=0.95)
  # Linear
xyplot(log(Abundance) ~ NH3.mg.L, est.df)
est.NH3 <- lm(NH3.mg.L~log(Abundance), est.df)
summary(est.NH3)
confint(est.NH3, level=0.95)
  # Not linear
xyplot(log(Abundance) ~ TKN.mg.L, est.df)
est.TKN <- lm(TKN.mg.L~log(Abundance), est.df)
summary(est.TKN)
confint(est.TKN, level=0.95)
  # Negative R2
xyplot(log(Abundance) ~ TP.ug.L, est.df)
est.TP <- lm(TP.ug.L~log(Abundance), est.df)
summary(est.TP)
confint(est.TP, level=0.95)
  # Negative R2
xyplot(log(Abundance) ~ DO.probe.mg.L, est.df)
est.DO <- lm(DO.probe.mg.L~log(Abundance), est.df)
summary(est.DO)
confint(est.DO, level=0.95)
  # Negative R2



##### Inland #####
xyplot(log(Abundance) ~ SRP.ug.L, inl.df)
inl.SRP <- lm(SRP.ug.L~log(Abundance), inl.df)
summary(inl.SRP)
confint(inl.SRP, level=0.95)
  # Linear, but super low R2
xyplot(log(Abundance) ~ Chl.Lab..ug.L., inl.df)
inl.Chl <- lm(Chl.Lab..ug.L.~log(Abundance), inl.df)
summary(inl.Chl)
confint(inl.Chl, level=0.95)
  # Linear, but R2 is essentially 0
xyplot(log(Abundance) ~ TP.ug.L, inl.df)
inl.TP <- lm(TP.ug.L~log(Abundance), inl.df)
summary(inl.TP)
confint(inl.TP, level=0.95)
  # Linear
xyplot(log(Abundance) ~ NH4.ug.L, inl.df)
inl.NH4 <- lm(NH4.ug.L~log(Abundance), inl.df)
summary(inl.NH4)
confint(inl.NH4, level=0.95)
  # Linear


### Unused environmental factors
xyplot(log(Abundance) ~ NO3.mg.L, inl.df)
inl.NO3 <- lm(NO3.mg.L~log(Abundance), inl.df)
summary(inl.NO3)
confint(inl.NO3, level=0.95)
  # Negative R2
xyplot(log(Abundance) ~ TDP.ug.L, inl.df)
inl.TDP <- lm(TDP.ug.L~log(Abundance), inl.df)
summary(inl.TDP)
confint(inl.TDP, level=0.95)
  # Imma say no because too many points are near 0 for TDP


##### MODELLING TIME #####  

# Function to extract the best subset multiple linear regression model 
# Arguments:
#   vars: vectors of all variables to consider in the model
#   response: response variable of the model (must be in quotes!)
#   dat: dataframe with vars and response
# Returns: a list with the variables in the best model, bic, cp, and adjusted r2
get_bestsub_summary <- function(vars, response, dat) {
  formula = reformulate(termlabels = vars, response = response)
  lm_model <- regsubsets(formula, method = "exhaustive", dat)
  bic <- summary(lm_model)$bic
  cp <- summary(lm_model)$cp
  adjr2 <- summary(lm_model)$adjr2
  best_model <- summary(lm_model)$which[which.min(bic), ]
  return(list(model = best_model, bic = bic, cp = cp, adjr2 = adjr2))
}


# Variables to include in models
lau.vars <- c("Temperature..C.", "DO.Probe..mg.L.", "SiO2.mg.L")
est.vars <- c("ORP..mV.", "Temperature..C.", "TDS..mg.L.", "Chl.Lab..ug.L.", "SO4.mg.L")
inl.vars <- c("SRP.ug.L", "Chl.Lab..ug.L.", "NH4.ug.L")

# Get the best variable subset model 
# Then fit the model to extract coefficients and p-values
lau.best.model <- lapply(lau.df, 
  function(x) {
    best_model <- get_bestsub_summary(lau.vars, "Abundance", lau.df)
    model <- lm(
      formula = reformulate(lau.vars[best_model$model[-1]], "Abundance"), 
      data = lau.df)
    return(model)
  })
summary(lau.best.model)
  # SiO2 coefficient = 1.190
  # Intercept = 2.443


est.best.model <- lapply(est.df, 
  function(x) {
    best_model <- get_bestsub_summary(est.vars, "Abundance", est.df)
    model <- lm(
      formula = reformulate(est.vars[best_model$model[-1]], "Abundance"), 
      data = est.df)
    return(model)
  })
  # ORP coefficient = 0.03577
  # Temp coefficient = -0.56380
  # TDS coefficient = -0.11094
  # Intercept = 36.16245

inl.best.model <- lapply(inl.df, 
  function(x) {
    best_model <- get_bestsub_summary(inl.vars, "Abundance", inl.df)
    model <- lm(
      formula = reformulate(inl.vars[best_model$model[-1]], "Abundance"), 
      data = inl.df)
    return(model)
  })
  # NH4.ug.L coefficient = -0.007094
  # Intercept = 11.894036

#### Pull out p-value
## Laurentian
lau.best.model <- get_bestsub_summary(lau.vars, "Abundance", lau.df)
lau.model <- lm(Abundance ~ SiO2.mg.L, lau.df)
summary(lau.model)
  # SiO2 p-value = 0.1262
  # Adjusted R2 = 0.06225

## Estuary
est.best.model <- get_bestsub_summary(est.vars, "Abundance", est.df)
est.model <- lm(Abundance ~ ORP..mV. + Temperature..C. + TDS..mg.L., est.df)
summary(est.model)
  # ORP p-value = 0.012133
  # Temp p-value = 0.008675
  # TDS = 0.000118
  # Adjusted R2 = 0.5989

## Inland
inl.best.model <- get_bestsub_summary(inl.vars, "Abundance", inl.df)
inl.model <- lm(Abundance ~ NH4.ug.L, inl.df)
summary(inl.model)
  # p-value = 2e-16
  # Adjusted R2 = 0.06124
```






### Plot Residuals
```{r}
### Laurentian ###
lau.y <- as.vector(lau.df$Abundance)
# Model uses SiO2, which is unavailable for 2 of the data (1 & 8)
# Remove these 2 data points
#lau.y <- lau.y[-1]
#lau.y <- lau.y[-7]
plot_residuals(lau.model, lau.y, "Laurentian")


### Estuary ###
est.y <- as.vector(est.df$Abundance)
plot_residuals(est.model, est.y, "Estuary")


### Inland ###
inl.y <- as.vector(inl.df$Abundance)
plot_residuals(inl.model, inl.y, "Inland")




##### PLOT!!! #####
dev.new()
tiff("residuals.tiff", width = 15, height = 10, units = "cm", res = 600)
grid.newpage()
pushViewport(viewport(layout=(grid.layout(3,3))))
print(plot_residuals(lau.model, lau.y, "Laurentian"), vp=viewport(layout.pos.row=1, 
                                                                  layout.pos.col=1:3))
print(plot_residuals(est.model, est.y, "Estuary"), vp=viewport(layout.pos.row=2, 
                                                                  layout.pos.col=1:3))
print(plot_residuals(inl.model, inl.y, "Inland"), vp=viewport(layout.pos.row=3, 
                                                                  layout.pos.col=1:3))
dev.off()






#tiff("ver.pcoa.tiff", width = 15, height = 10, units = "cm", res = 500)
#grid.newpage()
#pushViewport(viewport(layout=(grid.layout(1,3, widths=c(1,1,1), heights=c(1,1,1)))))
#print(Ver.lau.ord, vp=viewport(layout.pos.row=1, layout.pos.col=1))
#print(Ver.est.ord, vp=viewport(layout.pos.row=1, layout.pos.col=2))
#print(Ver.inl.ord, vp=viewport(layout.pos.row=1, layout.pos.col=3))
#dev.off()

```

### Alpha Diversity
```{r}
# Min # of reads
min_lib <- min(sample_sums(Ver))

# We will subsample to the minimum number of reads. We will repeat this 100 times and average the diversity estimates from each trial.

# Initialize matrices to store richness and evenness estimates
nsamp = nsamples(Ver)
trials = 100

richness <- matrix(nrow = nsamp, ncol = trials)
row.names(richness) <- sample_names(Ver)
evenness <- matrix(nrow = nsamp, ncol = trials)
row.names(evenness) <- sample_names(Ver)

for (i in 1:100) {
  # Subsample
  r <- rarefy_even_depth(Ver, sample.size = min_lib, verbose = FALSE, replace = TRUE)
  
  # Calculate richness
  rich <- as.numeric(as.matrix(estimate_richness(r, measures = "Observed")))
  richness[ ,i] <- rich
  
  # Calculate evenness
  even <- as.numeric(as.matrix(estimate_richness(r, measures = "InvSimpson")))
  evenness[ ,i] <- even
}


# Create a new dataframe to hold the means and standard deviations of richness estimates
SampleID <- row.names(richness)
mean <- apply(richness, 1, mean)
sd <- apply(richness, 1, sd)
measure <- rep("Observed Richness", nsamp)
rich_stats <- data.frame(SampleID, mean, sd, measure)

# Create a new dataframe to hold the means and standard deviations of evenness estimates
SampleID <- row.names(evenness)
mean <- apply(evenness, 1, mean)
sd <- apply(evenness, 1, sd)
measure <- rep("Inverse Simpson", nsamp)
even_stats <- data.frame(SampleID, mean, sd, measure)

# Calculate Simpson's Evenness
simps_stats<- data.frame(matrix(nrow = nrow(even_stats), ncol = 4))
colnames(simps_stats) = c("SampleID", "mean", "sd", "measure")
simps_stats$SampleID <- even_stats$SampleID
simps_stats$mean <- even_stats$mean/rich_stats$mean
simps_stats$sd <- even_stats$sd/rich_stats$sd
simps_stats$measure <- "Simpson's Evenness"

# Combine the estimates into one dataframe
alpha <- rbind(rich_stats, even_stats, simps_stats)

# Add the sample metadata into this dataframe using the merge() command
s <- data.frame(sample_data(Ver))
alphadiv <- merge(alpha, s, by = "SampleID") 

# Group samples together by Lake_Type and Fraction & summarize stats
sum.stats <- alphadiv %>%
  group_by(Lake_Type, Fraction, measure) %>%
  summarize(Mean = mean(mean), 
            SE = se(mean), 
            SD = sd(mean), 
            Median = median(mean))

# Combine stats summary & sample metadata
final.stats <- left_join(alphadiv, sum.stats, by=c("Lake_Type", "Fraction", "measure"))
final.stats$measure <- factor(final.stats$measure, levels=c("Inverse Simpson", "Simpson's Evenness", "Observed Richness"))




##### Isolate Inverse Simpson #####

# Pull out just Inverse Simpson
inv.simp <- final.stats[which(final.stats$measure == "Inverse Simpson"),]


### Fraction ###
inv.simp.water <- inv.simp[which(inv.simp$Depth != "Sediment"),]
inv.simp.frac.plot <- ggplot(inv.simp.water, aes(x=Lake_Type, y=mean, fill=Fraction)) +
  geom_boxplot(position=position_dodge(1)) +
  scale_fill_manual(values = c("rosybrown","gold")) +
  xlab("Lake Type") + ylab("Inverse Simpson") +
  facet_grid(~ Lake_Type, space = "free_x", scale="free") +
  theme(axis.title.x = element_text(face="bold", size=10),
        axis.text.x = element_text(angle=0, colour="black", size=8),
        axis.text.y = element_text(colour="black", size=8),
        axis.title.y = element_text(face="bold", size=10),
        plot.title = element_text(face="bold", size=10),
        legend.title = element_text(size=10, face="bold"),
        legend.text = element_text(size = 9),
        strip.text.x = element_blank(),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm")) # top, right, bottom, left


### Season ###

# This is the annotation text for the plot below (seas.box)
# Since the plot is facetted and you have different text in each facet, you have to use geom_text and call on the dataframe made below (ann_text)

ann.seas <- data.frame(lab=c("", "+", ""),
                       Lake_Type = factor(c("Laurentian", "Estuary", "Inland"),
                                          levels = c("Laurentian", "Estuary",
                                                     "Inland")),
                       Season = factor(c("Spring", "Summer", "Fall"),
                                         levels = c("Spring", "Summer", "Fall")))

inv.simp.seas.plot <- ggplot(inv.simp, aes(x=Lake_Type, y=mean, fill=Season)) +
  geom_boxplot(position=position_dodge(1)) +
  #scale_fill_manual(values = c("indianred1","skyblue2","mediumpurple2")) +
  xlab("Lake Type") + ylab("Inverse Simpson") +
  facet_grid(~ Lake_Type, space = "free_x", scale="free") +
  theme(axis.title.x = element_text(face="bold", size=8),
        axis.text.x = element_text(angle=0, colour="black", size=6),
        axis.text.y = element_text(colour="black", size=6),
        axis.title.y = element_text(face="bold", size=8),
        plot.title = element_text(face="bold", size=8),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size = 7),
        strip.text.x = element_blank(),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm")) + # top, right, bottom, left
  geom_text(data = ann.seas, aes(x = c(1.33,1.33,1), y=c(5.15,15,5.15), label = lab), size = 3, color="red")




### Depth ###

# This is the annotation text for the plot below (seas.box)
# Since the plot is facetted and you have different text in each facet, you have to use geom_text and call on the dataframe made below (ann_text)
ann.depth <- data.frame(lab=c(" ", "+", ""),
                       Lake_Type = factor(c("Laurentian", "Estuary", "Inland"),
                                          levels = c("Laurentian", "Estuary",
                                                     "Inland")),
                       Depth = factor(c("Surface", "Bottom", "Sediment")))

inv.simp.depth.plot <- ggplot(inv.simp, aes(x=Lake_Type, y=mean, fill=Depth)) +
  geom_boxplot(position=position_dodge(1)) +
  scale_fill_manual(values = c("cadetblue1","dodgerblue3","purple3")) +
  xlab("Lake Type") + ylab("Inverse Simpson") +
  facet_grid(~ Lake_Type, space = "free_x", scale="free") +
  theme(axis.title.x = element_text(face="bold", size=8),
        axis.text.x = element_text(angle=0, colour="black", size=6),
        axis.text.y = element_text(colour="black", size=6),
        axis.title.y = element_text(face="bold", size=8),
        plot.title = element_text(face="bold", size=8),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size = 7),
        strip.text.x = element_blank(),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm")) + # top, right, bottom, left
  geom_text( data = ann.depth, aes(x=c(1,1.33,1), y=c(16.5,16.5,16.5), label=lab), size=3, color="red")








##### Kruskal-Wallis #####
# For Inverse Simpson values

# Lake Type
kruskal.test(formula = mean ~ Lake_Type, data = inv.simp)
  # p-value = 0.07479

# Source
kruskal.test(formula = mean ~ Source, data = inv.simp)
  # p-value = 0.0007124

# Free vs Part
kruskal.test(formula = mean ~ Fraction, data = inv.simp, subset=Fraction != "Sediment")
  # p-value = 0.3659

### Fraction

# Laurentian
kruskal.test(formula = mean ~ Fraction, data = inv.simp, subset=Lake_Type=="Laurentian")
  # Fraction
  # p-value = 0.1464

# Estuary
kruskal.test(formula = mean ~ Fraction, data = inv.simp, subset=Lake_Type=="Estuary")
  # Fraction
  # p-value = 0.005992
kruskalmc(resp = mean ~ Fraction, data = inv.simp, subset=Lake_Type=="Estuary")
  # Part-Free = nonsig
  # Part-Sed, Free-Sed = Sig
kruskal.test(formula = mean ~ Source, data = inv.simp, subset=Lake_Type=="Estuary")
  # Sed vs Water
  # p-value = 0.001382
kruskal.test(formula = mean ~ Fraction, data = inv.simp, subset=Lake_Type=="Estuary" & Fraction != "Sediment")
  # Free vs Part
  # p-value = 0.9439
kruskal.test(formula = mean ~ Fraction, data = inv.simp, subset=Lake_Type=="Estuary" & Fraction != "Free")
  # Part vs Sed
  # p-value = 0.008412
kruskal.test(formula = mean ~ Fraction, data = inv.simp, subset=Lake_Type=="Estuary" & Fraction != "Particle")
  # Free vs Sed
  # p-value = 0.001526

# Inland
kruskal.test(formula = mean ~ Fraction, data = inv.simp, subset=Lake_Type=="Inland")
  # Fraction
  # p-value = 0.7716

### Season
kruskal.test(formula = mean ~ Season, data = inv.simp)
  # All Season
  # p-value = 0.5134

# Laurentian
kruskal.test(formula = mean ~ Season, data = inv.simp, subset=Lake_Type=="Laurentian")
  # Season  
  # p-value = 0.1302

# Estuary
kruskal.test(formula = mean ~ Season, data = inv.simp, subset=Lake_Type=="Estuary")
  # Season
  # p-value = 0.00288
kruskalmc(resp = mean ~ Season, data = inv.simp, subset=Lake_Type=="Estuary")
kruskal.test(formula = mean ~ Season, data = inv.simp, subset=Lake_Type=="Estuary" & Season != "Spring")
  # Summer vs Fall
  # p-value = 0.003485
kruskal.test(formula = mean ~ Season, data = inv.simp, subset=Lake_Type=="Estuary" & Season != "Summer")
  # Spring vs Fall
  # p-value = 0.7897
kruskal.test(formula = mean ~ Season, data = inv.simp, subset=Lake_Type=="Estuary" & Season != "Fall")
  # Spring vs Summer
  # p-value = 0.003732

# Inland
kruskal.test(formula = mean ~ Season, data = inv.simp, subset=Lake_Type=="Inland")
  # Season
  # p-value = 0.3546


### Depth
kruskal.test(formula = mean ~ Depth, data = inv.simp)
  # All Depth
  # p-value = 0.001582
kruskalmc(resp = mean ~ Depth, data = inv.simp)
  # Sur-Sed, Bot-Sed = Sig
  # Sur-Bot = nonsig
kruskal.test(formula = mean ~ Depth, data = inv.simp, subset= Depth != "Sediment")
  # All Water
  # p-value = 0.2206

# Laurentian
kruskal.test(formula = mean ~ Depth, data = inv.simp, subset = Lake_Type == "Laurentian")
  # Depth 
  # p-value = 0.03301

# Estuary
kruskal.test(formula = mean ~ Depth, data = inv.simp, subset = Lake_Type == "Estuary")
  # Depth
  # p-value = 0.005557
kruskalmc(resp = mean ~ Depth, data = inv.simp, subset=Lake_Type=="Estuary")
  # Sur-Bot = nonsig
  # Sur-Sed, Bot-Sed = Sig
kruskal.test(formula = mean ~ Depth, data = inv.simp, subset = Lake_Type == "Estuary" & Depth != "Sediment" )
  # Sur vs Bottom
  # p-value = 0.6387
kruskal.test(formula = mean ~ Depth, data = inv.simp, subset = Lake_Type == "Estuary" & Depth != "Surface" )
  # Bottom vs Sediment
  # p-value = 0.004181
kruskal.test(formula = mean ~ Depth, data = inv.simp, subset = Lake_Type == "Estuary" & Depth != "Bottom" )
  # Sur vs Sediment 
  # p-value = 0.003276

# Inland
kruskal.test(formula = mean ~ Depth, data = inv.simp, subset = Lake_Type == "Inland")
  # p-value = 0.9873

##### Adjust P-values #####
invsimp.kw.vals <- data.frame(c(0.07479, 0.0007124, 0.3659, 0.1464, 0.005992, 0.001382, 0.9439, 0.008412, 0.001526, 0.7716, 0.5134, 0.1302, 0.00288, 0.003485, 0.7897, 0.003732, 0.3546, 0.001582, 0.2206, 0.03301, 0.005557, 0.6387, 0.004181, 0.003276, 0.9873))
colnames(invsimp.kw.vals) <- "pvals"
invsimp.kw.vals$Lake <- c("All", "All", "All", "L", "E", "E", "E", "E", "E", "I", "All", "L", "E", "E", "E", "E", "I", "All", "All", "L", "E", "E", "E", "E", "I")
invsimp.kw.vals$Comp <- c("Lake", "Source", "PF", "Frac", "Frac", "Source", "PF", "PS", "FS", "PF", "Seas", "Seas", "Seas", "SuFa", "SpFa", "SpSu", "Seas", "Depth", "TB", "TB", "Depth", "TB", "BS", "TS", "Depth")
invsimp.kw.vals$Bonf <- p.adjust(invsimp.kw.vals$pvals, method="bonferroni")
invsimp.kw.vals$BenH <- p.adjust(invsimp.kw.vals$pvals, method="BH")


```

### RelAbun + Inverse Simpson Plot
```{r}
# Combine Verruco Rel Abun Boxplot & Inverse Simpson Plot
tiff("boxplot.invsimp.tiff", width = 17.8, height = 10, units = "cm", res = 600)
grid.newpage()
pushViewport(viewport(layout=(grid.layout(2,3, widths=c(1,1,1), heights=c(1.5,1.5,1.5)))))
print(depth.box, vp=viewport(layout.pos.row=1, layout.pos.col=1))
print(seas.box, vp=viewport(layout.pos.row=1, layout.pos.col=2))
print(frac.box, vp=viewport(layout.pos.row=1, layout.pos.col=3))
print(inv.simp.depth.plot, vp=viewport(layout.pos.row=2, layout.pos.col=1))
print(inv.simp.seas.plot, vp=viewport(layout.pos.row=2, layout.pos.col=2))
print(inv.simp.frac.plot, vp=viewport(layout.pos.row=2, layout.pos.col=3))
dev.off()

```



### Phylogenetic Diversity
```{r}
#http://picante.r-forge.r-project.org/picante-intro.pdf

### Unweighted Calculations ###

# Create objects that you'll use with the picante package
ver.tree <- read.newick(file="tree_files/ver.tre")
pre.picante <- merge_phyloseq(Ver.rel, ver.tree)
picante.phy <- phy_tree(pre.picante)
  # Phylogenetic tree to be used
picante.com <- data.frame(otu_table(pre.picante))
  # Community data (otu table) to be used

# Calculate Faith's Phylogenetic Diversity
pd.result <- pd(picante.com, picante.phy, include.root=T)
pd <- data.frame(pd.result)

# Convert Verruco tree to a distance matrix
#This distance matrix is used to calculate MDP & MNTD
phydist <- cophenetic(picante.phy)

# Calculate MDP (Mean Pairwise Distance)
ses.mpd.result <- ses.mpd(picante.com, phydist, null.model = "taxa.labels", 
                          abundance.weighted=F, runs=999)

## Pull out MDP results
mpd <- data.frame(ses.mpd.result)




##### Unweigh: Preparing to plot #####

mpd$SampleID <- row.names(mpd)
# mntd$SampleID <- row.names(mntd)
pd$SampleID <- row.names(pd)
  # Make sure all SampleID's match!

# Let's pull out the first Stat of each test
# PD test = PD
# MPD test = SES (Standardized Effect Size)
pd.stats <- data.frame(pd$SampleID, pd$PD)
pd.stats$Measure <- rep("PD", 216)
colnames(pd.stats) <- c("SampleID", "Stat", "Measure")
mpd.stats <- data.frame(mpd$SampleID, mpd$mpd.obs.z)
mpd.stats$Measure <- rep("MPD SES",216)
colnames(mpd.stats) <- c("SampleID", "Stat", "Measure")

## Let's combine those initial stats into one big dataframe
unweigh.stats <- rbind(pd.stats, mpd.stats)

## Making the final dataframe to use!
unweigh.stats <- rbind(unweigh.stats, mpd.stats)

## Pull out sample data
s <- data.frame(sample_data(Ver))
## Combine sample data with unweighted stats data
unweigh.stats <- merge(unweigh.stats, s, by="SampleID")


## Group samples together by Lake_Type and Fraction & calculate stats summaries
sum.unweigh <- unweigh.stats %>%
  group_by(Lake_Type, Fraction, Measure) %>%
  summarize(Mean = mean(Stat),
            SE = se(Stat),
            SD = sd(Stat),
            Median = median(Stat))

## Combine the raw stats with the summarized stats
final.unweigh <- left_join(unweigh.stats, sum.unweigh, 
                           by=c("Lake_Type", "Fraction", "Measure"))
final.unweigh$Measure <- factor(final.unweigh$Measure, levels=c("PD", "MPD SES", "MPD p-value"))




##### ISOLATE MPD #####
mpd.ready <- merge(mpd.stats, s, by="SampleID")


# Group samples together by Lake_Type and Fraction
sum.mpd <- mpd.ready %>%
  group_by(Lake_Type, Fraction, Measure) %>%
  summarize(Mean = mean(Stat),
            SE = se(Stat),
            SD = sd(Stat),
            Median = median(Stat))


# Combine the raw stats with the summarized stats
final.mpd <- left_join(mpd.ready, sum.mpd, by=c("Lake_Type", "Fraction", "Measure"))

##### Lake Type #####
mpd.lake.plot <- ggplot(final.mpd, aes(x = Lake_Type, y = Stat, fill = Lake_Type)) + 
  geom_boxplot(position=position_dodge(1)) +
  scale_fill_manual(values = c("firebrick2","darkorange","khaki1")) +
  xlab("Lake Type") + ylab("Mean") +
  ggtitle("SES MPD") +
  theme(axis.title.x = element_text(face="bold", size=10),
        axis.text.x = element_blank(),
        axis.text.y = element_text(colour="black", size=8),
        axis.title.y = element_text(face="bold", size=10),
        plot.title = element_text(face="bold", size=10, hjust=0.5),
        legend.title = element_text(size=10, face="bold"),
        legend.text = element_text(size = 9),
        strip.text.x = element_blank(),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm")) +
  annotate("text", x= 2, y=3.2, label = "*", fontface="bold", size=5, colour="red")


##### Fraction #####
ann.mpd.frac <- data.frame(lab=c("*", "+", "*"),
                       Lake_Type = factor(c("Laurentian", "Estuary", "Inland"),
                                          levels = c("Laurentian", "Estuary",
                                                     "Inland")),
                       Fraction = factor(c("Particle", "Free", "Sediment")))
mpd.frac.plot <- ggplot(final.mpd, aes(x = Lake_Type, y = Stat, fill = Fraction)) + 
  geom_boxplot(position=position_dodge(1)) +
  scale_fill_manual(values = c("rosybrown","gold","saddlebrown")) +
  xlab("Lake Type") + ylab("Mean") +
  ggtitle("SES MPD") +
  facet_grid(~Lake_Type, space = "free_x", scale = "free") +
  theme(axis.title.x = element_text(face="bold", size=10),
        axis.text.x = element_text(angle=0, colour="black", size=7),
        axis.text.y = element_text(colour="black", size=8),
        axis.title.y = element_text(face="bold", size=10),
        plot.title = element_text(face="bold", size=10, hjust=0.5),
        legend.title = element_text(size=10, face="bold"),
        legend.text = element_text(size = 9),
        strip.text.x = element_blank(),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm")) +
  geom_text(data = ann.mpd.frac, aes(x = c(1,1.35,1), y=c(4.5, 4.5, 4.5), label = lab), size = 4, color="red")

##### Season #####
ann.mpd.seas <- data.frame(lab=c("a", "a", "", "+"),
                       Lake_Type = factor(c("Laurentian", "Laurentian", "Estuary",
                                            "Inland"),
                                          levels = c("Laurentian", "Estuary",
                                                     "Inland")),
                       Season = factor(c("Spring", "Summer", "Fall", "Spring"),
                                         levels = c("Spring", "Summer", "Fall")))
mpd.seas.plot <- ggplot(final.mpd, aes(x=Lake_Type, y=Stat, fill=Season)) +
  geom_boxplot(position=position_dodge(1)) +
  xlab("Lake Type") + ylab("Mean") +
  ggtitle("SES MPD") +
  facet_grid(~ Lake_Type, space = "free_x", scale="free") +
  theme(axis.title.x = element_text(face="bold", size=10),
        axis.text.x = element_text(angle=0, colour="black", size=7),
        axis.text.y = element_text(colour="black", size=8),
        axis.title.y = element_text(face="bold", size=10),
        plot.title = element_text(face="bold", size=10, hjust=0.5),
        legend.title = element_text(size=10, face="bold"),
        legend.text = element_text(size = 9),
        strip.text.x = element_blank(),
        plot.margin = unit(c(0.1, -0.1, 0.1, 0.1), "cm")) + # top, right, bottom, left
  geom_text(data = ann.mpd.seas, aes(x = c(0.65,1.35,1,0.65), y=c(4.5,4.5,4.5,4.5), label = lab), size = 4, color="red")




######## Plot MPD ########
tiff("mpd.tiff", width = 17.8, height = 7, units = "cm", res = 600)
grid.newpage()
pushViewport(viewport(layout=(grid.layout(1,3, widths=c(0.7,1,1), heights=c(0.5,0.5,0.5))))) 
print(mpd.lake.plot, vp=viewport(layout.pos.row=1, layout.pos.col=1))
print(mpd.frac.plot, vp=viewport(layout.pos.row=1, layout.pos.col=2))
print(mpd.seas.plot, vp=viewport(layout.pos.row=1, layout.pos.col=3))
dev.off()









########## MPD Kruskal-Wallis ##########
### Lake Type
kruskal.test(formula = Stat ~ Lake_Type, data = final.mpd)
  # All Lake Types
  # p-value = 1.131e-06
kruskalmc(resp = Stat ~ Lake_Type, data = final.mpd)
kruskal.test(formula = Stat ~ Lake_Type, data = final.mpd, subset = Lake_Type != "Laurentian")
  # Estuary vs Inland
  # p-value = 0.01799
kruskal.test(formula = Stat ~ Lake_Type, data = final.mpd, subset = Lake_Type != "Estuary")
  # Laurentian vs. Inland
  # p-value = 0.0001075
kruskal.test(formula = Stat ~ Lake_Type, data = final.mpd, subset = Lake_Type != "Inland")
  # Laurentian vs. Estuary
  # p-value = 1.649e-07



### Fraction
kruskal.test(formula = Stat ~ Fraction, data = final.mpd)
  # All Fraction
  # p-value = 4.877e-13
# Source
kruskal.test(formula = Stat ~ Source, data = final.mpd)
  # p-value = 7.637e-08
kruskalmc(resp = Stat ~ Fraction, data = final.mpd)
  # All sig
kruskal.test(formula = Stat ~ Fraction, data = final.mpd, subset = Fraction != "Sediment")
  # All Part vs Free
  # p-value = 3.539e-08

# Laurentian
kruskal.test(formula = Stat ~ Fraction, data = final.mpd, subset = Lake_Type == "Laurentian")
  # Fraction
  # p-value = 0.001916

# Estuary
kruskal.test(formula = Stat ~ Fraction, data = final.mpd, subset = Lake_Type == "Estuary")
  # Fraction
  # p-value = 4.945e-06
kruskalmc(resp = Stat ~ Fraction, data = final.mpd, subset = Lake_Type == "Estuary")
  # All sig
kruskal.test(formula = Stat ~ Source, data = final.mpd, subset = Lake_Type == "Estuary")
  # Source
  # p-value = 9.452e-07
kruskal.test(formula = Stat ~ Fraction, data = final.mpd, subset = Lake_Type == "Estuary" & Fraction != "Sediment")
  # Free vs Part
  # p-value = 0.496
kruskal.test(formula = Stat ~ Fraction, data = final.mpd, subset = Lake_Type == "Estuary" & Fraction != "Particle")
  # Free vs Sediment
  # p-value = 3.82e-06
kruskal.test(formula = Stat ~ Fraction, data = final.mpd, subset = Lake_Type == "Estuary" & Fraction != "Free")
  # Particle vs Sediment
  # p-value = 1.889e-05

# Inland
kruskal.test(formula = Stat ~ Fraction, data = final.mpd, subset = Lake_Type == "Inland")
  # Fraction
  # p-value = 8.328e-08



### Season
kruskal.test(formula = Stat ~ Season, data = final.mpd)
  # All Season
  # p-value = 0.2896

# Laurentian
kruskal.test(formula = Stat ~ Season, data = final.mpd, subset = Lake_Type == "Laurentian")
  # Season
  # p-value = 0.02085
kruskalmc(resp = Stat ~ Season, data = final.mpd, subset = Lake_Type=="Laurentian")
  # Nonsig
kruskal.test(formula = Stat ~ Season, data = final.mpd, subset = Lake_Type == "Laurentian" & Season != "Spring")
  # Summer vs Fall
  # p-value = 0.05634
kruskal.test(formula = Stat ~ Season, data = final.mpd, subset = Lake_Type == "Laurentian" & Season != "Summer")
  # Spring vs Fall
  # p-value = 0.01106
kruskal.test(formula = Stat ~ Season, data = final.mpd, subset = Lake_Type == "Laurentian" & Season != "Fall")
  # Spring vs Summer
  # p-value = 0.242

# Estuary
kruskal.test(formula = Stat ~ Season, data = final.mpd, subset = Lake_Type == "Estuary")
  # Season
  # p-value = 0.9986

# Inland
kruskal.test(formula = Stat ~ Season, data = final.mpd, subset = Lake_Type == "Inland")
  # Season
  # p-value = 0.03356
kruskal.test(formula = Stat ~ Season, data = final.mpd, subset = Lake_Type == "Inland" & Season != "Spring")
  # Summer vs Fall
  # p-value = 0.7131
kruskal.test(formula = Stat ~ Season, data = final.mpd, subset = Lake_Type == "Inland" & Season != "Summer")
  # Spring vs Fall
  # p-value = 0.034
kruskal.test(formula = Stat ~ Season, data = final.mpd, subset = Lake_Type == "Inland" & Season != "Fall")
  # Spring vs Summer
  # p-value = 0.01232



### Depth
kruskal.test(formula = Stat ~ Depth, data = final.mpd)
  # All Depth
  # p-value = 5.033e-07
kruskalmc(resp = Stat ~ Depth, data = final.mpd)
  # Sur-Sed, Bot-Sed = Sig
  # Sur-Bot = nonsig
kruskal.test(formula = Stat ~ Depth, data = final.mpd, subset = Depth != "Sediment")
  # All Sur vs Bottom
  # p-value = 0.7318

# Laurentian
kruskal.test(formula = Stat ~ Depth, data = final.mpd, subset = Lake_Type == "Laurentian")
  # Depth
  # p-value = 0.1355

# Estuary
kruskal.test(formula = Stat ~ Depth, data = final.mpd, subset = Lake_Type == "Estuary")
  # Depth
  # p-value = 2.348e-06
kruskalmc(resp = Stat ~ Depth, data = final.mpd, subset = Lake_Type=="Estuary")
  # Sur-Sed, Bot-Sed = Sig
  # Sur-Bot = Nonsig
kruskal.test(formula = Stat ~ Source, data = final.mpd, subset = Lake_Type == "Estuary")
  # Source
  # p-value = 9.452e-07
kruskal.test(formula = Stat ~ Depth, data = final.mpd, subset = Lake_Type == "Estuary" & Depth != "Sediment")
  # Sur vs Bottom
  # p-value = 0.08879
kruskal.test(formula = Stat ~ Depth, data = final.mpd, subset = Lake_Type == "Estuary" & Depth != "Surface")
  # Bottom vs Sediment
  # p-value = 9.424e-06
kruskal.test(formula = Stat ~ Depth, data = final.mpd, subset = Lake_Type == "Estuary" & Depth != "Bottom")
  # Sur vs Sediment
  # p-value = 7.889e-06

# Inland
kruskal.test(formula = Stat ~ Depth, data = final.mpd, subset = Lake_Type == "Inland")
  # Depth
  # p-value = 0.05432


### Remove Sed samples and compare Lake Type
### Lake Type
kruskal.test(formula = Stat ~ Lake_Type, data = final.mpd, subset = Fraction != "Sediment")
  # All Lake Types
  # p-value = 7.156e-05
kruskalmc(resp = Stat ~ Lake_Type, data = final.mpd, subset = Fraction != "Sediment")
  # Est - Inl nonsig
kruskal.test(formula = Stat ~ Lake_Type, data = final.mpd, subset = Lake_Type != "Laurentian" & Fraction != "Sediment")
  # Estuary vs Inland
  # p-value = 0.7034
kruskal.test(formula = Stat ~ Lake_Type, data = final.mpd, subset = Lake_Type != "Estuary")
  # Laurentian vs. Inland
  # p-value = 0.0001075
kruskal.test(formula = Stat ~ Lake_Type, data = final.mpd, subset = Lake_Type != "Inland" & Fraction != "Sediment")
  # Laurentian vs. Estuary
  # p-value = 1.408e-05


##### Adjust P-Values #####
mpd.kw.vals <- data.frame(c(1.131e-06, 0.01799, 0.0001075, 1.649e-07, 4.877e-13, 7.637e-08, 3.539e-08, 0.001916, 4.945e-06, 9.452e-07, 0.496, 3.82e-06, 1.889e-05, 8.328e-08, 0.2896, 0.02085, 0.05634, 0.01106, 0.242, 0.9986, 0.03356, 0.7131, 0.034, 0.01232, 5.033e-07, 0.7318, 0.1355, 2.348e-06, 9.452e-07, 0.08879, 9.424e-06, 7.889e-06, 0.05432,7.156e-05, 0.7034, 0.0001075, 1.408e-05))
colnames(mpd.kw.vals) <- "pvals"
mpd.kw.vals$Lake <- c("All", "EI", "LI", "LE", "All", "All", "All", "L", "E", "E", "E", "E", "E", "I", "All", "L", "L", "L", "L", "E", "I", "I", "I", "I", "All", "All", "L", "E", "E", "E", "E", "E", "I", "All", "EI", "LI", "LE")
mpd.kw.vals$Comp <- c("Lake", "EI", "LI", "LE", "Frac", "Source", "PF", "Frac", "Frac", "Source", "PF", "FS", "PS", "Frac", "Seas", "Seas", "SuFa", "SpFa", "Spsu", "Seas", "Seas", "SuFa", "SpFa", "SpSu", "Depth", "TB", "Depth", "Depth", "Source", "TB", "BS", "TS", "Depth", "NoSed", "NoSed", "NoSed", "NoSed")
mpd.kw.vals$Bonf <- p.adjust(mpd.kw.vals$pvals, method="bonferroni")
mpd.kw.vals$BenH <- p.adjust(mpd.kw.vals$pvals, method="BH")
```


### PCoA (Bray-Curtis)
```{r}
# Calculate bray-curtis dissimilarity from phyloseq object
Ver.bray <- phyloseq::distance(physeq = Ver.rel, method = "bray")

# Performs ordination on phyloseq object
Ver.pcoa <- ordinate(physeq = Ver.rel, method = "PCoA", distance = "bray")


#To determine approximately how much variation the axes should explain:
#Ver.pcoa$values
#look for broken stick value
```



### Ver PERMANOVA
```{r}
sampledf <- data.frame(sample_data(Ver.rel))

##### Depth #####
adonis(Ver.bray ~ Depth, data=sampledf)
  ## R2 = 0.1117 
  ## p-value = 0.001
beta.tax = betadisper(d=Ver.bray, group=sampledf$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 26.73463

# Surface vs. Bottom
adonis.tb <- subset_samples(physeq = Ver.rel, Depth != "DCM")
adonis.tb <- subset_samples(physeq = adonis.tb, Depth != "Sediment")
adonis.tb.bray <- phyloseq::distance(physeq = adonis.tb, method = "bray")
adonis.tb <- data.frame(sample_data(adonis.tb))
adonis(adonis.tb.bray ~ Depth, data=adonis.tb)
  # p-value = 0.001
  # R2 = 0.03619
beta.tax = betadisper(d=adonis.tb.bray, group=adonis.tb$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.304
  # F = 1.013249 

# Surface vs. Sediment
adonis.ts <- subset_samples(physeq = Ver.rel, Depth != "DCM")
adonis.ts <- subset_samples(physeq = adonis.ts, Depth != "Bottom")
adonis.ts.bray <- phyloseq::distance(physeq = adonis.ts, method = "bray")
adonis.ts <- data.frame(sample_data(adonis.ts))
adonis(adonis.ts.bray ~ Depth, data=adonis.ts)
  # p-value = 0.001
  # R2 = 0.12477
beta.tax = betadisper(d=adonis.ts.bray, group=adonis.ts$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 53.5601 

# Bottom vs. Sediment
adonis.bs <- subset_samples(physeq = Ver.rel, Depth != "DCM")
adonis.bs <- subset_samples(physeq = adonis.bs, Depth != "Surface")
adonis.bs.bray <- phyloseq::distance(physeq = adonis.bs, method = "bray")
adonis.bs <- data.frame(sample_data(adonis.bs))
adonis(adonis.bs.bray ~ Depth, data=adonis.bs)
  # p-value = 0.001
  # R2 = 0.16959 
beta.tax = betadisper(d=adonis.bs.bray, group=adonis.bs$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 44.43599 


##### Lake_Type #####
adonis(Ver.bray ~ Lake_Type, data=sampledf)
  ## R2 = 0.10811
  ## p-value = 0.001
beta.tax = betadisper(Ver.bray, sampledf$Lake_Type)
p <- permutest(beta.tax)
p$tab
  ## p-value = 0.804
  ## F = 0.2344702 

# Laurentian vs. Estuary
adonis.scaled.le <- subset_samples(physeq = scaled, Lake_Type != "Inland")
adonis.scaled.le.bray <- phyloseq::distance(physeq = adonis.scaled.le, method = "bray")
adonis.scaled.le <- data.frame(sample_data(adonis.scaled.le))
adonis(adonis.scaled.le.bray ~ Lake_Type, data=adonis.scaled.le)
  # p-value = 0.001
  # R2 = 0.11055
beta.tax = betadisper(d=adonis.scaled.le.bray, group=adonis.scaled.le$Lake_Type)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.067
  # F = 3.033354

# Laurentian vs. Inland
adonis.scaled.li <- subset_samples(physeq = scaled, Lake_Type != "Estuary")
adonis.scaled.li.bray <- phyloseq::distance(physeq = adonis.scaled.li, method = "bray")
adonis.scaled.li <- data.frame(sample_data(adonis.scaled.li))
adonis(adonis.scaled.li.bray ~ Lake_Type, data=adonis.scaled.li)
  # p-value = 0.001
  # R2 = 0.0732
beta.tax = betadisper(d=adonis.scaled.li.bray, group=adonis.scaled.li$Lake_Type)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 13.455

# Estuary vs. Inland
adonis.scaled.ei <- subset_samples(physeq = scaled, Lake_Type != "Laurentian")
adonis.scaled.ei.bray <- phyloseq::distance(physeq = adonis.scaled.ei, method = "bray")
adonis.scaled.ei <- data.frame(sample_data(adonis.scaled.ei))
adonis(adonis.scaled.ei.bray ~ Lake_Type, data=adonis.scaled.ei)
  # p-value = 0.001
  # R2 = 0.06438
beta.tax = betadisper(d=adonis.scaled.ei.bray, group=adonis.scaled.ei$Lake_Type)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.359
  # F = 0.8845943





##### Fraction #####
adonis(Ver.bray ~ Fraction, data=sampledf)
  ## p-value = 0.001
  ## R2 = 0.1663
beta.tax = betadisper(Ver.bray, sampledf$Fraction)
p <- permutest(beta.tax)
p$tab
  ## P-value = 0.001
  ## F = 28.29785 

# Particle vs. Free
adonis.pf <- subset_samples(physeq = Ver.rel, Fraction != "Sediment")
adonis.pf.bray <- phyloseq::distance(physeq = adonis.pf, method = "bray")
adonis.pf <- data.frame(sample_data(adonis.pf))
adonis(adonis.pf.bray ~ Fraction, data=adonis.pf)
  # p-value = 0.001
  # R2 = 0.09661
beta.tax = betadisper(d=adonis.pf.bray, group=adonis.pf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 22.35251 

# Particle vs. Sediment
adonis.ps <- subset_samples(physeq = Ver.rel, Fraction != "Free")
adonis.ps.bray <- phyloseq::distance(physeq = adonis.ps, method = "bray")
adonis.ps <- data.frame(sample_data(adonis.ps))
adonis(adonis.ps.bray ~ Fraction, data=adonis.ps)
  # p-value = 0.001
  # R2 = 0.13127
beta.tax = betadisper(d=adonis.ps.bray, group=adonis.ps$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 57.86883

# Free vs. Sediment
adonis.fs <- subset_samples(physeq = Ver.rel, Fraction != "Particle")
adonis.fs.bray <- phyloseq::distance(physeq = adonis.fs, method = "bray")
adonis.fs <- data.frame(sample_data(adonis.fs))
adonis(adonis.fs.bray ~ Fraction, data=adonis.fs)
  # p-value = 0.001
  # R2 = 0.1877 
beta.tax = betadisper(d=adonis.fs.bray, group=adonis.fs$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 17.73738 



##### Season #####
adonis(Ver.bray ~ Season, data=sampledf)
  ## p-value = 0.001
  ## R2 = 0.08844
beta.tax = betadisper(Ver.bray, sampledf$Season)
p <- permutest(beta.tax)
p$tab
  ## P-value = 0.016
  ## F = 4.424293 

# Spring vs. Summer
adonis.ss <- subset_samples(physeq = Ver.rel, Season != "Fall")
adonis.ss.bray <- phyloseq::distance(physeq = adonis.ss, method = "bray")
adonis.ss <- data.frame(sample_data(adonis.ss))
adonis(adonis.ss.bray ~ Season, data=adonis.ss)
  # p-value = 0.001
  # R2 = 0.08535
beta.tax = betadisper(d=adonis.ss.bray, group=adonis.ss$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 17.16133

# Spring vs. Fall
adonis.sf <- subset_samples(physeq = Ver.rel, Season != "Summer")
adonis.sf.bray <- phyloseq::distance(physeq = adonis.sf, method = "bray")
adonis.sf <- data.frame(sample_data(adonis.sf))
adonis(adonis.sf.bray ~ Season, data=adonis.sf)
  # p-value = 0.001
  # R2 = 0.12483 
beta.tax = betadisper(d=adonis.sf.bray, group=adonis.sf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 20.02684

# Summer vs. Fall
adonis.suf <- subset_samples(physeq = Ver.rel, Season != "Spring")
adonis.suf.bray <- phyloseq::distance(physeq = adonis.suf, method = "bray")
adonis.suf <- data.frame(sample_data(adonis.suf))
adonis(adonis.suf.bray ~ Season, data=adonis.suf)
  # p-value = 0.001
  # R2 = 0.02465
beta.tax = betadisper(d=adonis.suf.bray, group=adonis.suf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 19.89149  


##### Nested adonis #####
adonis(Ver.bray ~ Lake_Type + Depth + Fraction + Season, data = sampledf)
  ## Lake_Type R2 = 0.10811
  ## Depth R2 = 0.10905
  ## Fraction R2 = 0.08670
  ## Season R2 = 0.07013
  ## all p-values = 0.001



```


### Ver Lake Type PCoA
```{r}
##### Laurentian #####

# Subset out Laurentian samples
Ver.lau <- subset_samples(Ver.rel, Lake_Type == "Laurentian")

# Calculate bray-curtis dissimilarity
Ver.lau.bray <- phyloseq::distance(physeq = Ver.lau, method = "bray")

# Perform PcoA ordination
Ver.lau.pcoa <- ordinate(physeq = Ver.lau, method = "PCoA", distance = "bray")

### Plot
Ver.lau.ord <- plot_ordination(physeq = Ver.lau, ordination = Ver.lau.pcoa, axes = c(1, 2),
                title= "Bray-Curtis Dissimilarity") + 
  geom_point(size=2, aes(color = Season, shape = Depth,
                         fill = factor(ifelse(Fraction == "Free", NA, Season)),
                         alpha = Fraction)) +
  scale_shape_manual(values = c(21, 24, 22)) +
  scale_fill_discrete(na.value = "white", guide = "none") +
  scale_alpha_manual(values=c("Particle"=1, "Free"=1)) +
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_text(face="bold", size=9),
        axis.title.y = element_text(face="bold", size=9),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size=8),
        axis.ticks = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        plot.title = element_text(size = 9, face="bold")) +
  annotate("text", x= -0.39, y=0.43, label = "A", fontface = "bold", size=5, colour="black") +
  guides(colour=FALSE, shape=FALSE, alpha = FALSE)
# Particle = fill, Free = empty
# Note: for scale_fill_discrete to work, you MUST set scale_shape_manual to between 21-25; You also can't set colors manually


##### Estuary #####

# Subset out estuary samples
Ver.est <- subset_samples(Ver.rel, Lake_Type == "Estuary")

# Calculate bray-curtis dissimilarity
Ver.est.bray <- phyloseq::distance(physeq = Ver.est, method = "bray")

# Perform PCoA ordination
Ver.est.pcoa <- ordinate(physeq = Ver.est, method = "PCoA", distance = "bray")
  

### Plot
Ver.est.ord <- plot_ordination(physeq = Ver.est, ordination = Ver.est.pcoa, axes = c(1, 2),
                title= "Bray-Curtis Dissimilarity") + 
  geom_point(size=2, aes(color = Season, shape = Depth,
                         fill = factor(ifelse(Fraction == "Free", NA, Season)),
                         alpha = Fraction)) +
  scale_shape_manual(values = c(21, 24, 22)) +
  scale_fill_discrete(na.value = "white", guide = "none") +
  scale_alpha_manual(values=c("Particle"=1, "Free"=1, "Sediment"=0.5)) +
  scale_y_reverse() +
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_text(face="bold", size=9),
        axis.title.y = element_text(face="bold", size=9),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size=8),
        axis.ticks = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        plot.title = element_text(size = 9, face="bold")) +
  annotate("text", x= -0.62, y=-0.31, label = "B", fontface = "bold", size=5, colour="black") +
  guides(colour=FALSE, shape=FALSE, alpha = FALSE) 
  #guides(color = guide_legend(order=1, title="Season", override.aes=list(size=3)),
  #       shape = guide_legend(order=2, title="Depth",override.aes=list(size=3)),
  #       alpha = guide_legend(order=3, title="Fraction",override.aes=list(size=3)))

# The function below is to save a legend from a plot, that can then later be called upon and printed
# To use the function, first save a plot as an object
# Then perform the g_legend(plot) function to steal the legend
# Go back to your plot and now remove the legend (guide)
 ##### Let's steal the legend 
g_legend <- function(a.gplot){
   tmp <- ggplot_gtable(ggplot_build(a.gplot))
   leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
   legend <- tmp$grobs[[leg]]
   return(legend)}
legend <- g_legend(Ver.est.ord)

  
##### Inland #####

# Subset out inland samples
Ver.inl <- subset_samples(Ver.rel, Lake_Type == "Inland")

# Calculate bray-curtis dissimilarity
Ver.inl.bray <- phyloseq::distance(physeq = Ver.inl, method = "bray")

# Perform PCoA ordination
Ver.inl.pcoa <- ordinate(physeq = Ver.inl, method = "PCoA", distance = "bray")

### Plot
Ver.inl.ord <- plot_ordination(physeq = Ver.inl, ordination = Ver.inl.pcoa, axes = c(1, 2),
                title= "Bray-Curtis Dissimilarity") + 
  geom_point(size=2, aes(color = Season, shape = Depth,
                         fill = factor(ifelse(Fraction == "Free", NA, Season)),
                         alpha = Fraction)) +
  scale_shape_manual(values = c(21, 24, 22)) +
  scale_fill_discrete(na.value = "white", guide = "none") +
  scale_alpha_manual(values=c("Particle"=1, "Free"=1)) +
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_text(face="bold", size=9),
        axis.title.y = element_text(face="bold", size=9),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size=8),
        axis.ticks = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        plot.title = element_text(size = 9, face="bold")) +
  annotate("text", x= -0.46, y=0.66, label = "C", fontface = "bold", size=5, colour="black") +
  guides(colour=FALSE, shape=FALSE, alpha = FALSE) 

```





### Ver Lake PERMANOVA
```{r}

########## Laurentian ##########
sampledf <- data.frame(sample_data(Ver.lau))

### Depth
adonis(Ver.lau.bray ~ Depth, data=sampledf)
  # R2 = 0.04999
  # p-value = 0.122
beta.tax = betadisper(d=Ver.lau.bray, group=sampledf$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.048
  # F = 4.689563

### Season
adonis(Ver.lau.bray ~ Season, data=sampledf)
  # R2 = 0.43082
  # p-value = 0.001
beta.tax = betadisper(d=Ver.lau.bray, group=sampledf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 11.22

# Spring vs. Summer
adonis.ss <- subset_samples(physeq = Ver.lau, Season != "Fall")
adonis.ss.bray <- phyloseq::distance(physeq = adonis.ss, method = "bray")
adonis.ss <- data.frame(sample_data(adonis.ss))
adonis(adonis.ss.bray ~ Season, data=adonis.ss)
  # R2 = 0.47247
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ss.bray, group=adonis.ss$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 15.00923

# Spring vs. Fall
adonis.spf <- subset_samples(physeq = Ver.lau, Season != "Summer")
adonis.spf.bray <- phyloseq::distance(physeq = adonis.spf, method = "bray")
adonis.spf <- data.frame(sample_data(adonis.spf))
adonis(adonis.spf.bray ~ Season, data=adonis.spf)
  # R2 = 0.41549
  # p-value = 0.001
beta.tax = betadisper(d=adonis.spf.bray, group=adonis.spf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.002
  # F = 15.21934

# Summer vs. Fall
adonis.suf <- subset_samples(physeq = Ver.lau, Season != "Spring")
adonis.suf.bray <- phyloseq::distance(physeq = adonis.suf, method = "bray")
adonis.suf <- data.frame(sample_data(adonis.suf))
adonis(adonis.suf.bray ~ Season, data=adonis.suf)
  # R2 = 0.18953
  # p-value = 0.001
beta.tax = betadisper(d=adonis.suf.bray, group=adonis.suf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.846
  # F = 0.04694171

### Fraction
adonis(Ver.lau.bray ~ Fraction, data=sampledf)
  # R2 = 0.17341
  # p-value = 0.001
beta.tax = betadisper(d=Ver.lau.bray, group=sampledf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.706
  # F = 0.1308235 


### Station
adonis(Ver.lau.bray ~ Station, data=sampledf)
  # R2 = 0.03244
  # p-value = 0.334
beta.tax = betadisper(d=Ver.lau.bray, group=sampledf$Station)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.005
  # F = 8.578097



##### Nested adonis #####
adonis(Ver.lau.bray ~ Fraction + Season + Station + Depth, data = sampledf)
  ## Fraction R2= 0.17341; p-value = 0.001
  ## Season R2= 0.43275; p-value = 0.001
  ## Station R2 = 0.03455; p-value = 0.013
  ## Depth R2= 0.04509; p-value = 0.003
  ## Residuals = 0.31420


########## ESTUARY ##########
sampledf <- data.frame(sample_data(Ver.est))

### Depth
adonis(Ver.est.bray ~ Depth, data=sampledf)
  # R2 = 0.34938
  # p-value = 0.001
beta.tax = betadisper(d=Ver.est.bray, group=sampledf$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.059
  # F = 2.910407 

# Water vs. Sediment
adonis(Ver.est.bray ~ Source, data=sampledf)
  # R2 = 0.33418
  # p-value = 0.001
beta.tax = betadisper(d=Ver.est.bray, group=sampledf$Source)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.012
  # F = 6.943519

# Surface vs. Bottom
adonis.tb <- subset_samples(physeq = Ver.est, Depth != "Sediment")
adonis.tb.bray <- phyloseq::distance(physeq = adonis.tb, method = "bray")
adonis.tb <- data.frame(sample_data(adonis.tb))
adonis(adonis.tb.bray ~ Depth, data=adonis.tb)
  # R2 = 0.02563
  # p-value = 0.344
beta.tax = betadisper(d=adonis.tb.bray, group=adonis.tb$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.649
  # F = 0.2145667 

# Surface vs. Sediment
adonis.ts <- subset_samples(physeq = Ver.est, Depth != "Bottom")
adonis.ts.bray <- phyloseq::distance(physeq = adonis.ts, method = "bray")
adonis.ts <- data.frame(sample_data(adonis.ts))
adonis(adonis.ts.bray ~ Depth, data=adonis.ts)
  # R2 = 0.45023
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ts.bray, group=adonis.ts$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.068
  # F = 3.871339

# Bottom vs. Sediment
adonis.bs <- subset_samples(physeq = Ver.est, Depth != "Surface")
adonis.bs.bray <- phyloseq::distance(physeq = adonis.bs, method = "bray")
adonis.bs <- data.frame(sample_data(adonis.bs))
adonis(adonis.bs.bray ~ Depth, data=adonis.bs)
  # R2 = 0.42448
  # p-value = 0.001
beta.tax = betadisper(d=adonis.bs.bray, group=adonis.bs$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.01
  # F = 6.740729

### Season
adonis(Ver.est.bray ~ Season, data=sampledf)
  # R2 = 0.21504
  # p-value = 0.001
beta.tax = betadisper(d=Ver.est.bray, group=sampledf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.785
  # F = 0.2592087 

# Spring vs. Summer
adonis.ss <- subset_samples(physeq = Ver.est, Season != "Fall")
adonis.ss.bray <- phyloseq::distance(physeq = adonis.ss, method = "bray")
adonis.ss <- data.frame(sample_data(adonis.ss))
adonis(adonis.ss.bray ~ Season, data=adonis.ss)
  # R2 = 0.21109
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ss.bray, group=adonis.ss$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.545
  # F = 0.3551472 

# Spring vs. Fall
adonis.spf <- subset_samples(physeq = Ver.est, Season != "Summer")
adonis.spf.bray <- phyloseq::distance(physeq = adonis.spf, method = "bray")
adonis.spf <- data.frame(sample_data(adonis.spf))
adonis(adonis.spf.bray ~ Season, data=adonis.spf)
  # R2 = 0.23828
  # p-value = 0.001
beta.tax = betadisper(d=adonis.spf.bray, group=adonis.spf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.51
  # F = 0.4848279   

# Summer vs. Fall
adonis.suf <- subset_samples(physeq = Ver.est, Season != "Spring")
adonis.suf.bray <- phyloseq::distance(physeq = adonis.suf, method = "bray")
adonis.suf <- data.frame(sample_data(adonis.suf))
adonis(adonis.suf.bray ~ Season, data=adonis.suf)
  # R2 = 0.06413 
  # p-value = 0.056
beta.tax = betadisper(d=adonis.suf.bray, group=adonis.suf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.877
  # F = 0.02023845

### Fraction
adonis(Ver.est.bray ~ Fraction, data=sampledf)
  # R2 = 0.46667
  # p-value = 0.001
beta.tax = betadisper(d=Ver.est.bray, group=sampledf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.037
  # F = 3.360917 

# Particle vs. Free
adonis.frac <- subset_samples(physeq = Ver.est, Fraction != "Sediment")
adonis.frac.bray <- phyloseq::distance(physeq = adonis.frac, method = "bray")
adonis.frac <- data.frame(sample_data(adonis.frac))
adonis(adonis.frac.bray ~ Fraction, data=adonis.frac)
  # R2 = 0.22339 
  # p-value = 0.001
beta.tax = betadisper(d=adonis.frac.bray, group=adonis.frac$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.048
  # F = 4.159478

# Particle vs. Sediment
adonis.ps <- subset_samples(physeq = Ver.est, Fraction != "Free")
adonis.ps.bray <- phyloseq::distance(physeq = adonis.ps, method = "bray")
adonis.ps <- data.frame(sample_data(adonis.ps))
adonis(adonis.ps.bray ~ Fraction, data=adonis.ps)
  # R2 = 0.42929
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ps.bray, group=adonis.ps$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.059
  # F = 3.607883

# Free vs. Sediment
adonis.fs <- subset_samples(physeq = Ver.est, Fraction != "Particle")
adonis.fs.bray <- phyloseq::distance(physeq = adonis.fs, method = "bray")
adonis.fs <- data.frame(sample_data(adonis.fs))
adonis(adonis.fs.bray ~ Fraction, data=adonis.fs)
  # R2 = 0.575
  # p-value = 0.001
beta.tax = betadisper(d=adonis.fs.bray, group=adonis.fs$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.591
  # F = 0.2720408 

### Station
adonis(Ver.est.bray ~ Station, data=sampledf)
  # R2 = 0.0549
  # p-value = 0.446
beta.tax = betadisper(d=Ver.est.bray, group=sampledf$Station)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.49
  # F = 0.8152906


##### Nested adonis #####
adonis(Ver.est.bray ~ Source + Fraction + Season + Station + Depth, data = sampledf)
  ## Source R2 = 0.33418; p-value = 0.001
  ## Fraction R2 = 0.13249; p-value = 0.001
  ## Season R2 = 0.21504; p-value = 0.001
  ## Station R2 = 0.03557; p-value = 0.024
  ## Depth R2 = 0.01520; p-value = 0.038
  ## Residuals = 0.28691




########## INLAND ##########
sampledf <- data.frame(sample_data(Ver.inl))

### Depth
adonis(Ver.inl.bray ~ Depth, data=sampledf)
  # R2 = 0.08139
  # p-value = 0.001
beta.tax = betadisper(d=Ver.inl.bray, group=sampledf$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.011
  # F = 8.347568

### Season
adonis(Ver.inl.bray ~ Season, data=sampledf)
  # R2 = 0.07723
  # p-value = 0.001
beta.tax = betadisper(d=Ver.inl.bray, group=sampledf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.002
  # F = 8.038783

# Spring vs. Summer
adonis.ss <- subset_samples(physeq = Ver.inl, Season != "Fall")
adonis.ss.bray <- phyloseq::distance(physeq = adonis.ss, method = "bray")
adonis.ss <- data.frame(sample_data(adonis.ss))
adonis(adonis.ss.bray ~ Season, data=adonis.ss)
  # R2 = 0.06701
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ss.bray, group=adonis.ss$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 16.4969

# Spring vs. Fall
adonis.spf <- subset_samples(physeq = Ver.inl, Season != "Summer")
adonis.spf.bray <- phyloseq::distance(physeq = adonis.spf, method = "bray")
adonis.spf <- data.frame(sample_data(adonis.spf))
adonis(adonis.spf.bray ~ Season, data=adonis.spf)
  # R2 = 0.17293
  # p-value = 0.001
beta.tax = betadisper(d=adonis.spf.bray, group=adonis.spf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.404
  # F = 0.7247857

# Summer vs. Fall
adonis.suf <- subset_samples(physeq = Ver.inl, Season != "Spring")
adonis.suf.bray <- phyloseq::distance(physeq = adonis.suf, method = "bray")
adonis.suf <- data.frame(sample_data(adonis.suf))
adonis(adonis.suf.bray ~ Season, data=adonis.suf)
  # R2 = 0.02092
  # p-value = 0.019
beta.tax = betadisper(d=adonis.suf.bray, group=adonis.suf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.036
  # F = 4.181126

### Fraction
adonis(Ver.inl.bray ~ Fraction, data=sampledf)
  # R2 = 0.11226
  # p-value = 0.001
beta.tax = betadisper(d=Ver.inl.bray, group=sampledf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.007
  # F = 8.083098

##### Nested adonis #####
adonis(Ver.inl.bray ~ Fraction + Season + Lake + Depth, data = sampledf)
  ## Fraction R2= 0.11226; p-value = 0.001
  ## Season R2= 0.07723; p-value = 0.001
  ## Lake R2= 0.27145; p-value = 0.001
  ## Depth R2= 0.07777; p-value = 0.001
  ## Residuals = 0.46128
```



### Whole Com PCoA
```{r}
# Calculate bray-curtis dissimilarity
scaled.bray <- phyloseq::distance(physeq=scaled, method="bray")

# Perform PCoA ordination
scaled.pcoa <- ordinate(physeq = scaled, method = "PCoA", distance="bray")
```




### Whole Com Lake PCoA
```{r}
### Laurentian ###

# Pull out Laurentian samples
scaled.lau <- subset_samples(scaled, Lake_Type == "Laurentian")

# Calculate bray-curtis dissimilarity
scaled.lau.bray <- phyloseq::distance(physeq = scaled.lau, method = "bray")

# Perform PCoA ordination
scaled.lau.pcoa <- ordinate(physeq = scaled.lau, method = "PCoA", distance = "bray")

### Plot
scaled.lau.ord <- plot_ordination(physeq = scaled.lau, ordination = scaled.lau.pcoa, axes = c(1, 2),
                title= "Bray-Curtis Dissimilarity") + 
  geom_point(size=2, aes(color = Season, shape = Depth,
                         fill = factor(ifelse(Fraction == "Free", NA, Season)),
                         alpha = Fraction)) +
  scale_shape_manual(values = c(21, 24, 22)) +
  scale_fill_discrete(na.value = "white", guide = "none") +
  scale_alpha_manual(values=c("Particle"=1, "Free"=1)) +
  #scale_y_reverse() + 
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_text(face="bold", size=9),
        axis.title.y = element_text(face="bold", size=9),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size=8),
        axis.ticks = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        plot.title = element_text(size = 9, face="bold")) +
  scale_y_reverse() + scale_x_reverse() +
  annotate("text", x= 0.42, y=-0.44, label = "D", fontface = "bold", size=5, colour="black") +
  guides(colour=FALSE, shape=FALSE, alpha = FALSE) 
# Note: for scale_fill_discrete to work, you MUST set scale_shape_manual to between 21-25
#        You also can't set colors manually


### Estuary ###

# Pull out Estuary samples
scaled.est <- subset_samples(scaled, Lake_Type == "Estuary")

# Calculate bray-curtis dissimilarity
scaled.est.bray <- phyloseq::distance(physeq = scaled.est, method = "bray")

# Perform PCoA ordination
scaled.est.pcoa <- ordinate(physeq = scaled.est, method = "PCoA", distance = "bray")
  
### Plot
scaled.est.ord <- plot_ordination(physeq = scaled.est, ordination = scaled.est.pcoa, axes = c(1, 2),
                title= "Bray-Curtis Dissimilarity") + 
  geom_point(size=2, aes(color = Season, shape = Depth,
                         fill = factor(ifelse(Fraction == "Free", NA, Season)),
                         alpha = Fraction)) +
  scale_shape_manual(values = c(21, 24, 22)) +
  scale_fill_discrete(na.value = "white", guide = "none") +
  scale_alpha_manual(values=c("Particle"=1, "Free"=1, "Sediment"=0.5)) +
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_text(face="bold", size=9),
        axis.title.y = element_text(face="bold", size=9),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size=8),
        axis.ticks = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        plot.title = element_text(size = 9, face="bold")) +
  scale_y_reverse() +
  annotate("text", x= -0.63, y=-0.25, label = "E", fontface = "bold", size=5, colour="black") +
  guides(colour=FALSE, shape=FALSE, alpha = FALSE) 




  
### Inland ###

# Pull out Inland samples
scaled.inl <- subset_samples(scaled, Lake_Type == "Inland")

# Calculate bray-curtis dissimilarity
scaled.inl.bray <- phyloseq::distance(physeq = scaled.inl, method = "bray")

# Perform PCoA ordination
scaled.inl.pcoa <- ordinate(physeq = scaled.inl, method = "PCoA", distance = "bray")

### Plot
scaled.inl.ord <- plot_ordination(physeq = scaled.inl, ordination = scaled.inl.pcoa, axes = c(1, 2),
                title= "Bray-Curtis Dissimilarity") + 
  geom_point(size=2, aes(color = Season, shape = Depth,
                         fill = factor(ifelse(Fraction == "Free", NA, Season)),
                         alpha = Fraction)) +
  scale_shape_manual(values = c(21, 24, 22)) +
  scale_fill_discrete(na.value = "white", guide = "none") +
  scale_alpha_manual(values=c("Particle"=1, "Free"=1)) +
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_text(face="bold", size=9),
        axis.title.y = element_text(face="bold", size=9),
        legend.title = element_text(size=8, face="bold"),
        legend.text = element_text(size=8),
        axis.ticks = element_blank(),
        plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"), #top, right, bottom, left
        plot.title = element_text(size = 9, face="bold")) +
  annotate("text", x= -0.37, y=0.55, label = "F", fontface = "bold", size=5, colour="black") +
  guides(colour=FALSE, shape=FALSE, alpha = FALSE) 
```


### Big PCoA Figure
```{r}
tiff("pcoa.tiff", width = 17.8, height = 11, units = "cm", res = 600)
#pdf("pcoa.pdf", width=7, height=7, useDingbats = F)
grid.newpage()
pushViewport(viewport(layout=(grid.layout(3,5, widths=c(1.5,19,19,19,8), heights=c(1,14,14)))))
grid.text("Laurentian", just=c(0.35, 0.5), vp=viewport(layout.pos.row=1, layout.pos.col=2), gp=gpar(fontsize=10,fontface="bold"))
grid.text("Estuary", just=c(0.35, 0.5), vp=viewport(layout.pos.row=1, layout.pos.col=3), gp=gpar(fontsize=10,fontface="bold"))
grid.text("Inland",  just=c(0.35, 0.5), vp=viewport(layout.pos.row=1, layout.pos.col=4), gp=gpar(fontsize=10,fontface="bold"))
grid.text("Verrucomicrobial Community", rot=90, vp=viewport(layout.pos.row=2, layout.pos.col=1), gp=gpar(fontsize=10,fontface="bold"))
grid.text("Whole Bacterial Community", rot=90, vp=viewport(layout.pos.row=3, layout.pos.col=1), gp=gpar(fontsize=10,fontface="bold"))
print(Ver.lau.ord, vp=viewport(layout.pos.row=2, layout.pos.col=2))
print(Ver.est.ord, vp=viewport(layout.pos.row=2, layout.pos.col=3))
print(Ver.inl.ord, vp=viewport(layout.pos.row=2, layout.pos.col=4))
print(scaled.lau.ord, vp=viewport(layout.pos.row=3, layout.pos.col=2))
print(scaled.est.ord, vp=viewport(layout.pos.row=3, layout.pos.col=3))
print(scaled.inl.ord, vp=viewport(layout.pos.row=3, layout.pos.col=4))
legend$vp <- viewport(layout.pos.row = 1:3, layout.pos.col = 5)
grid.draw(legend)
dev.off()
```


### Whole Com PERMANOVA
```{r}
bcc.sampledf <- data.frame(sample_data(scaled))

##### Depth #####
adonis(scaled.bray ~ Depth, data=bcc.sampledf)
  ## R2 = 0.12446
  ## p-value = 0.001
beta.tax = betadisper(d=scaled.bray, group=bcc.sampledf$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 16.52378 

# Surface vs. Bottom
adonis.scaled.tb <- subset_samples(physeq = scaled, Depth != "DCM")
adonis.scaled.tb <- subset_samples(physeq = adonis.scaled.tb, Depth != "Sediment")
adonis.scaled.tb.bray <- phyloseq::distance(physeq = adonis.scaled.tb, method = "bray")
adonis.scaled.tb <- data.frame(sample_data(adonis.scaled.tb))
adonis(adonis.scaled.tb.bray ~ Depth, data=adonis.scaled.tb)
  # p-value = 0.001
  # R2 = 0.05024
beta.tax = betadisper(d=adonis.scaled.tb.bray, group=adonis.scaled.tb$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.006
  # F = 8.154884 

# Surface vs. Sediment
adonis.scaled.ts <- subset_samples(physeq = scaled, Depth != "DCM")
adonis.scaled.ts <- subset_samples(physeq = adonis.scaled.ts, Depth != "Bottom")
adonis.scaled.ts.bray <- phyloseq::distance(physeq = adonis.scaled.ts, method = "bray")
adonis.scaled.ts <- data.frame(sample_data(adonis.scaled.ts))
adonis(adonis.scaled.ts.bray ~ Depth, data=adonis.scaled.ts)
  # p-value = 0.001
  # R2 = 0.13178
beta.tax = betadisper(d=adonis.scaled.ts.bray, group=adonis.scaled.ts$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 20.53398

# Bottom vs. Sediment
adonis.scaled.bs <- subset_samples(physeq = scaled, Depth != "DCM")
adonis.scaled.bs <- subset_samples(physeq = adonis.scaled.bs, Depth != "Surface")
adonis.scaled.bs.bray <- phyloseq::distance(physeq = adonis.scaled.bs, method = "bray")
adonis.scaled.bs <- data.frame(sample_data(adonis.scaled.bs))
adonis(adonis.scaled.bs.bray ~ Depth, data=adonis.scaled.bs)
  # p-value = 0.001
  # R2 = 0.16174
beta.tax = betadisper(d=adonis.scaled.bs.bray, group=adonis.scaled.bs$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 29.07199


##### Lake_Type #####
adonis(scaled.bray ~ Lake_Type, data=bcc.sampledf)
  ## R2 = 0.10228
  ## p-value = 0.001
beta.tax = betadisper(scaled.bray, bcc.sampledf$Lake_Type)
p <- permutest(beta.tax)
p$tab
  ## p-value = 0.005
  ## F = 5.282899  

# Laurentian vs. Estuary
adonis.scaled.le <- subset_samples(physeq = scaled, Lake_Type != "Inland")
adonis.scaled.le.bray <- phyloseq::distance(physeq = adonis.scaled.le, method = "bray")
adonis.scaled.le <- data.frame(sample_data(adonis.scaled.le))
adonis(adonis.scaled.le.bray ~ Lake_Type, data=adonis.scaled.le)
  # p-value = 0.001
  # R2 = 0.11055
beta.tax = betadisper(d=adonis.scaled.le.bray, group=adonis.scaled.le$Lake_Type)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.094
  # F = 3.033354

# Laurentian vs. Inland
adonis.scaled.li <- subset_samples(physeq = Ver.rel, Lake_Type != "Estuary")
adonis.scaled.li.bray <- phyloseq::distance(physeq = adonis.scaled.li, method = "bray")
adonis.scaled.li <- data.frame(sample_data(adonis.scaled.li))
adonis(adonis.scaled.li.bray ~ Lake_Type, data=adonis.scaled.li)
  # p-value = 0.001
  # R2 = 0.08015
beta.tax = betadisper(d=adonis.scaled.li.bray, group=adonis.scaled.li$Lake_Type)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.493
  # F = 0.4470369

# Estuary vs. Inland
adonis.ei <- subset_samples(physeq = Ver.rel, Lake_Type != "Laurentian")
adonis.ei.bray <- phyloseq::distance(physeq = adonis.ei, method = "bray")
adonis.ei <- data.frame(sample_data(adonis.ei))
adonis(adonis.ei.bray ~ Lake_Type, data=adonis.ei)
  # p-value = 0.001
  # R2 = 0.06846
beta.tax = betadisper(d=adonis.ei.bray, group=adonis.ei$Lake_Type)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.812
  # F = 0.05272026 




##### Fraction #####
adonis(scaled.bray ~ Fraction, data=bcc.sampledf)
  ## p-value = 0.001
  ## R2 = 0.21318
beta.tax = betadisper(scaled.bray, bcc.sampledf$Fraction)
p <- permutest(beta.tax)
p$tab
  ## P-value = 0.001
  ## F = 57.06025

# Particle vs. Free
adonis.scaled.pf <- subset_samples(physeq = scaled, Fraction != "Sediment")
adonis.scaled.pf.bray <- phyloseq::distance(physeq = adonis.scaled.pf, method = "bray")
adonis.scaled.pf <- data.frame(sample_data(adonis.scaled.pf))
adonis(adonis.scaled.pf.bray ~ Fraction, data=adonis.scaled.pf)
  # p-value = 0.001
  # R2 = 0.14923
beta.tax = betadisper(d=adonis.scaled.pf.bray, group=adonis.scaled.pf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 98.37893

# Particle vs. Sediment
adonis.scaled.ps <- subset_samples(physeq = scaled, Fraction != "Free")
adonis.scaled.ps.bray <- phyloseq::distance(physeq = adonis.scaled.ps, method = "bray")
adonis.scaled.ps <- data.frame(sample_data(adonis.scaled.ps))
adonis(adonis.scaled.ps.bray ~ Fraction, data=adonis.scaled.ps)
  # p-value = 0.001
  # R2 = 0.12488
beta.tax = betadisper(d=adonis.scaled.ps.bray, group=adonis.scaled.ps$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 45.03515

# Free vs. Sediment
adonis.scaled.fs <- subset_samples(physeq = scaled, Fraction != "Particle")
adonis.scaled.fs.bray <- phyloseq::distance(physeq = adonis.scaled.fs, method = "bray")
adonis.scaled.fs <- data.frame(sample_data(adonis.scaled.fs))
adonis(adonis.scaled.fs.bray ~ Fraction, data=adonis.scaled.fs)
  # p-value = 0.001
  # R2 = 0.2272
beta.tax = betadisper(d=adonis.scaled.fs.bray, group=adonis.scaled.fs$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.085
  # F = 2.889795


##### Season #####
adonis(scaled.bray ~ Season, data=bcc.sampledf)
  ## p-value = 0.001
  ## R2 = 0.08031
beta.tax = betadisper(scaled.bray, bcc.sampledf$Season)
p <- permutest(beta.tax)
p$tab
  ## P-value = 0.026
  ## F = 3.831441

# Spring vs. Summer
adonis.scaled.ss <- subset_samples(physeq = scaled, Season != "Fall")
adonis.scaled.ss.bray <- phyloseq::distance(physeq = adonis.scaled.ss, method = "bray")
adonis.scaled.ss <- data.frame(sample_data(adonis.scaled.ss))
adonis(adonis.scaled.ss.bray ~ Season, data=adonis.scaled.ss)
  # p-value = 0.001
  # R2 = 0.07771
beta.tax = betadisper(d=adonis.scaled.ss.bray, group=adonis.scaled.ss$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 47.36667  

# Spring vs. Fall
adonis.scaled.sf <- subset_samples(physeq = scaled, Season != "Summer")
adonis.scaled.sf.bray <- phyloseq::distance(physeq = adonis.scaled.sf, method = "bray")
adonis.scaled.sf <- data.frame(sample_data(adonis.scaled.sf))
adonis(adonis.scaled.sf.bray ~ Season, data=adonis.scaled.sf)
  # p-value = 0.001
  # R2 = 0.0946
beta.tax = betadisper(d=adonis.scaled.sf.bray, group=adonis.scaled.sf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 26.21886  

# Summer vs. Fall
adonis.scaled.suf <- subset_samples(physeq = scaled, Season != "Spring")
adonis.scaled.suf.bray <- phyloseq::distance(physeq = adonis.scaled.suf, method = "bray")
adonis.scaled.suf <- data.frame(sample_data(adonis.scaled.suf))
adonis(adonis.scaled.suf.bray ~ Season, data=adonis.scaled.suf)
  # p-value = 0.001
  # R2 = 0.02709
beta.tax = betadisper(d=adonis.scaled.suf.bray, group=adonis.scaled.suf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 30.21236


##### Nested adonis #####
adonis(scaled.bray ~ Lake_Type + Depth + Fraction + Season, data = bcc.sampledf)
  ## Lake Type R2 = 0.10228
  ## Depth R2 = 0.11807
  ## Fraction R2 = 0.13296
  ## Season = 0.06093
  ## All p-values = 0.001

# if you rearrange the variables (and include sed as part of frac)....
  ## Fraction R2 = 0.21318
  ## Lake_Type R2 = 0.09883
  ## Season R2 = 0.06407
  ## Depth R2 = 0.03816
  ## All p-values = 0.001

```




### Whole Lake PERMANOVA
```{r bcc.lake.permanova}
########## LAURENTIAN ##########
sampledf <- data.frame(sample_data(scaled.lau))

### Depth
adonis(scaled.lau.bray ~ Depth, data=sampledf)
  # R2 = 0.03723
  # p-value = 0.243
beta.tax = betadisper(d=scaled.lau.bray, group=sampledf$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.827
  # F = 0.03704203

### Season
adonis(scaled.lau.bray ~ Season, data=sampledf)
  # R2 = 0.23951
  # p-value = 0.001
beta.tax = betadisper(d=scaled.lau.bray, group=sampledf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.135
  # F = 2.141275

# Spring vs. Summer
adonis.ss <- subset_samples(physeq = scaled.lau, Season != "Fall")
adonis.ss.bray <- phyloseq::distance(physeq = adonis.ss, method = "bray")
adonis.ss <- data.frame(sample_data(adonis.ss))
adonis(adonis.ss.bray ~ Season, data=adonis.ss)
  # R2 = 0.2255
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ss.bray, group=adonis.ss$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.121
  # F = 2.479235

# Spring vs. Fall
adonis.spf <- subset_samples(physeq = scaled.lau, Season != "Summer")
adonis.spf.bray <- phyloseq::distance(physeq = adonis.spf, method = "bray")
adonis.spf <- data.frame(sample_data(adonis.spf))
adonis(adonis.spf.bray ~ Season, data=adonis.spf)
  # R2 = 0.23554
  # p-value = 0.001
beta.tax = betadisper(d=adonis.spf.bray, group=adonis.spf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.073
  # F = 3.621429

# Summer vs. Fall
adonis.suf <- subset_samples(physeq = scaled.lau, Season != "Spring")
adonis.suf.bray <- phyloseq::distance(physeq = adonis.suf, method = "bray")
adonis.suf <- data.frame(sample_data(adonis.suf))
adonis(adonis.suf.bray ~ Season, data=adonis.suf)
  # R2 = 0.11285
  # p-value = 0.049
beta.tax = betadisper(d=adonis.suf.bray, group=adonis.suf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.903
  # F = 0.01387363

### Fraction
adonis(scaled.lau.bray ~ Fraction, data=sampledf)
  # R2 = 0.34359
  # p-value = 0.001
beta.tax = betadisper(d=scaled.lau.bray, group=sampledf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 52.05048

### Station
adonis(scaled.lau.bray ~ Station, data=sampledf)
  # R2 = 0.04338
  # p-value = 0.175
beta.tax = betadisper(d=scaled.lau.bray, group=sampledf$Station)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.142
  # F = 2.038993


##### Nested adonis #####
adonis(scaled.lau.bray ~ Fraction + Season + Station + Depth, data = sampledf)
  ## Fraction R2= 0.34359; p-value = 0.001
  ## Season R2= 0.24164; p-value = 0.001
  ## Station R2= 0.04492; p-value = 0.007
  ## Depth R2= 0.03424; p-value = 0.011
  ## Residuals = 0.33562


########## ESTUARY ##########
sampledf <- data.frame(sample_data(scaled.est))

### Depth
adonis(scaled.est.bray ~ Depth, data=sampledf)
  # R2 = 0.34738
  # p-value = 0.001
beta.tax = betadisper(d=scaled.est.bray, group=sampledf$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.29
  # F = 1.248019

# Water vs. Sediment
adonis(scaled.est.bray ~ Source, data=sampledf)
  # R2 = 0.32898
  # p-value = 0.001
beta.tax = betadisper(d=scaled.est.bray, group=sampledf$Source)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.153
  # F = 2.135097

# Surface vs. Bottom
adonis.tb <- subset_samples(physeq = scaled.est, Depth != "Sediment")
adonis.tb.bray <- phyloseq::distance(physeq = adonis.tb, method = "bray")
adonis.tb <- data.frame(sample_data(adonis.tb))
adonis(adonis.tb.bray ~ Depth, data=adonis.tb)
  # R2 = 0.03248
  # p-value = 0.186
beta.tax = betadisper(d=adonis.tb.bray, group=adonis.tb$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.373
  # F = 0.9356047 

# Surface vs. Sediment
adonis.ts <- subset_samples(physeq = scaled.est, Depth != "Bottom")
adonis.ts.bray <- phyloseq::distance(physeq = adonis.ts, method = "bray")
adonis.ts <- data.frame(sample_data(adonis.ts))
adonis(adonis.ts.bray ~ Depth, data=adonis.ts)
  # R2 = 0.44651
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ts.bray, group=adonis.ts$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.527
  # F = 0.4505285 

# Bottom vs. Sediment
adonis.bs <- subset_samples(physeq = scaled.est, Depth != "Surface")
adonis.bs.bray <- phyloseq::distance(physeq = adonis.bs, method = "bray")
adonis.bs <- data.frame(sample_data(adonis.bs))
adonis(adonis.bs.bray ~ Depth, data=adonis.bs)
  # R2 = 0.39941
  # p-value = 0.001
beta.tax = betadisper(d=adonis.bs.bray, group=adonis.bs$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.095
  # F = 2.882313

### Season
adonis(scaled.est.bray ~ Season, data=sampledf)
  # R2 = 0.17726
  # p-value = 0.001
beta.tax = betadisper(d=scaled.est.bray, group=sampledf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.795
  # F = 0.2208436

# Spring vs. Summer
adonis.ss <- subset_samples(physeq = scaled.est, Season != "Fall")
adonis.ss.bray <- phyloseq::distance(physeq = adonis.ss, method = "bray")
adonis.ss <- data.frame(sample_data(adonis.ss))
adonis(adonis.ss.bray ~ Season, data=adonis.ss)
  # R2 = 0.18043
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ss.bray, group=adonis.ss$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.835
  # F = 0.04943273

# Spring vs. Fall
adonis.spf <- subset_samples(physeq = scaled.est, Season != "Summer")
adonis.spf.bray <- phyloseq::distance(physeq = adonis.spf, method = "bray")
adonis.spf <- data.frame(sample_data(adonis.spf))
adonis(adonis.spf.bray ~ Season, data=adonis.spf)
  # R2 = 0.18644
  # p-value = 0.001
beta.tax = betadisper(d=adonis.spf.bray, group=adonis.spf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.502
  # F = 0.3994813

# Summer vs. Fall
adonis.suf <- subset_samples(physeq = scaled.est, Season != "Spring")
adonis.suf.bray <- phyloseq::distance(physeq = adonis.suf, method = "bray")
adonis.suf <- data.frame(sample_data(adonis.suf))
adonis(adonis.suf.bray ~ Season, data=adonis.suf)
  # R2 = 0.05743
  # p-value = 0.067
beta.tax = betadisper(d=adonis.suf.bray, group=adonis.suf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.688
  # F = 0.1952136

### Fraction
adonis(scaled.est.bray ~ Fraction, data=sampledf)
  # R2 = 0.44619
  # p-value = 0.001
beta.tax = betadisper(d=scaled.est.bray, group=sampledf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.109
  # F = 2.371368 

# Particle vs. Free
adonis.frac <- subset_samples(physeq = scaled.est, Fraction != "Sediment")
adonis.frac.bray <- phyloseq::distance(physeq = adonis.frac, method = "bray")
adonis.frac <- data.frame(sample_data(adonis.frac))
adonis(adonis.frac.bray ~ Fraction, data=adonis.frac)
  # R2 = 0.2069  
  # p-value = 0.001
beta.tax = betadisper(d=adonis.frac.bray, group=adonis.frac$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.05
  # F = 6.297787

# Particle vs. Sediment
adonis.ps <- subset_samples(physeq = scaled.est, Fraction != "Free")
adonis.ps.bray <- phyloseq::distance(physeq = adonis.ps, method = "bray")
adonis.ps <- data.frame(sample_data(adonis.ps))
adonis(adonis.ps.bray ~ Fraction, data=adonis.ps)
  # R2 = 0.40901
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ps.bray, group=adonis.ps$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.388
  # F = 0.8105961

# Free vs. Sediment
adonis.fs <- subset_samples(physeq = scaled.est, Fraction != "Particle")
adonis.fs.bray <- phyloseq::distance(physeq = adonis.fs, method = "bray")
adonis.fs <- data.frame(sample_data(adonis.fs))
adonis(adonis.fs.bray ~ Fraction, data=adonis.fs)
  # R2 = 0.53808
  # p-value = 0.001
beta.tax = betadisper(d=adonis.fs.bray, group=adonis.fs$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.32
  # F = 0.8945355

### Station
adonis(scaled.est.bray ~ Station, data=sampledf)
  # R2 = 0.06863 
  # p-value = 0.207
beta.tax = betadisper(d=scaled.est.bray, group=sampledf$Station)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.657
  # F = 0.5628271


##### Nested adonis #####
adonis(scaled.est.bray ~ Source + Fraction + Season + Station + Depth, data = sampledf)
  ## Source R2= 0.32898; p-value = 0.001
  ## Fraction R2= 0.11720; p-value = 0.001
  ## Season R2= 0.17726; p-value = 0.001
  ## Station R2= 0.05509; p-value = 0.001
  ## Depth R2=0.01840; p-value = 0.011
  ## Residuals = 0.32043




########## INLAND ##########
sampledf <- data.frame(sample_data(scaled.inl))

### Depth
adonis(scaled.inl.bray ~ Depth, data=sampledf)
  # R2 = 0.10041
  # p-value = 0.001
beta.tax = betadisper(d=scaled.inl.bray, group=sampledf$Depth)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 20.89009

### Season
adonis(scaled.inl.bray ~ Season, data=sampledf)
  # R2 = 0.09735
  # p-value = 0.001
beta.tax = betadisper(d=scaled.inl.bray, group=sampledf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 15.04692

# Spring vs. Summer
adonis.ss <- subset_samples(physeq = scaled.inl, Season != "Fall")
adonis.ss.bray <- phyloseq::distance(physeq = adonis.ss, method = "bray")
adonis.ss <- data.frame(sample_data(adonis.ss))
adonis(adonis.ss.bray ~ Season, data=adonis.ss)
  # R2 = 0.08529
  # p-value = 0.001
beta.tax = betadisper(d=adonis.ss.bray, group=adonis.ss$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 30.3471

# Spring vs. Fall
adonis.spf <- subset_samples(physeq = scaled.inl, Season != "Summer")
adonis.spf.bray <- phyloseq::distance(physeq = adonis.spf, method = "bray")
adonis.spf <- data.frame(sample_data(adonis.spf))
adonis(adonis.spf.bray ~ Season, data=adonis.spf)
  # R2 = 0.20982
  # p-value = 0.001
beta.tax = betadisper(d=adonis.spf.bray, group=adonis.spf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.023
  # F = 5.219433

# Summer vs. Fall
adonis.suf <- subset_samples(physeq = scaled.inl, Season != "Spring")
adonis.suf.bray <- phyloseq::distance(physeq = adonis.suf, method = "bray")
adonis.suf <- data.frame(sample_data(adonis.suf))
adonis(adonis.suf.bray ~ Season, data=adonis.suf)
  # R2 = 0.02688
  # p-value = 0.006
beta.tax = betadisper(d=adonis.suf.bray, group=adonis.suf$Season)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.057
  # F = 4.040812

### Fraction
adonis(scaled.inl.bray ~ Fraction, data=sampledf)
  # R2 = 0.17221
  # p-value = 0.001
beta.tax = betadisper(d=scaled.inl.bray, group=sampledf$Fraction)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.001
  # F = 26.48775

##### Nested adonis #####
adonis(scaled.inl.bray ~ Fraction + Season + Lake + Depth, data = sampledf)
  ## Fraction R2= 0.17221; p-value = 0.001
  ## Season R2= 0.09735; p-value = 0.001
  ## Lake R2 = 0.21003; p-value = 0.001
  ## Depth R2= 0.09506; p-value = 0.001
  ## Residuals = 0.42535
```




### Lake Procrustes Analyses (Verruco vs. Whole Community)
```{r}
########## Check Community w/ Verrucos Removed ##########

##### Laurentian #####
# Remove Verrucos
no.ver.all.lau <- subset_taxa(scaled.lau, Phylum != "Verrucomicrobia")

# Calculate bray-curtis dissimilarity
no.ver.all.lau.bray <- phyloseq::distance(physeq=no.ver.all.lau, method="bray")

# Perform PCoA ordination
no.ver.lau.pcoa <- ordinate(physeq = no.ver.all.lau, method = "PCoA", distance="bray")

# Perform Procrustes 
procrust.no.ver.lau <- procrustes(no.ver.lau.pcoa$vectors[,1:2], 
                                  Ver.lau.pcoa$vectors[,1:2], scale=F, symmetric=F)
  # Sum of squares = 2.065
pro.no.ver.lau <- protest(no.ver.lau.pcoa$vectors[,1:2], Ver.lau.pcoa$vectors[,1:2])
  # p-value = 0.001
  # m12^2 (sum of squares) = 0.3668
  # correlation = 0.7957


##### Estuary #####
# Remove Verrucos
no.ver.all.est <- subset_taxa(scaled.est, Phylum != "Verrucomicrobia")

# Calculate bray-curtis dissimilarity
no.ver.all.est.bray <- phyloseq::distance(physeq=no.ver.all.est, method="bray")

# Perform PCoA ordination
no.ver.est.pcoa <- ordinate(physeq = no.ver.all.est, method = "PCoA", distance="bray")

# Perform Procrustes 
procrust.no.ver.est <- procrustes(no.ver.est.pcoa$vectors[,1:2], 
                                  Ver.est.pcoa$vectors[,1:2], scale=F, symmetric=F)
  # Sum of squares = 0.8018
pro.no.ver.est <- protest(no.ver.est.pcoa$vectors[,1:2], Ver.est.pcoa$vectors[,1:2])
  # p-value = 0.001
  # m12^2 (sum of squares) = 0.0811
  # correlation = 0.9586


##### Inland #####
# Remove Verrucos
no.ver.all.inl <- subset_taxa(scaled.inl, Phylum != "Verrucomicrobia")

# Calculate bray-curtis dissimilarity
no.ver.all.inl.bray <- phyloseq::distance(physeq=no.ver.all.inl, method="bray")

# Perform PCoA ordination
no.ver.inl.pcoa <- ordinate(physeq = no.ver.all.inl, method = "PCoA", distance="bray")

# Perform Procrustes 
procrust.no.ver.inl <- procrustes(no.ver.inl.pcoa$vectors[,1:2], 
                                  Ver.inl.pcoa$vectors[,1:2], scale=F, symmetric=F)
  # Sum of squares = 6.328
pro.no.ver.inl <- protest(no.ver.inl.pcoa$vectors[,1:2], Ver.inl.pcoa$vectors[,1:2])
  # p-value = 0.001
  # m12^2 (sum of squares) = 0.4054
  # correlation = 0.7711

```





### DESeq
```{r}
# Phyloseq to DESeq2: http://joey711.github.io/phyloseq-extensions/DESeq2.html

deSEQ <- function(data, valuetest, cutoff = 0, alpha = 0.01){
  data_pruned <- prune_taxa(taxa_sums(data) > cutoff, data)
  de_data <- phyloseq_to_deseq2(data_pruned, valuetest)
  de_data2 <- DESeq(de_data, test="Wald", fitType="local")
  res_data <- results(de_data2, cooksCutoff = FALSE)
  sig_data <- res_data[which(res_data$padj < alpha), ]
  sigtab_sherm <- cbind(as(sig_data, "data.frame"), as(tax_table(data_pruned)[rownames(sig_data), ], "matrix"))
} 

### DESeq2 ###

# Subset out Verrucos from RAW COUNT phyloseq object
Vdeseq <- subset_taxa(dupmerge.subset, Phylum == "Verrucomicrobia")

# Subset out the Verruco OTUs that we've been using so far
# When we calculate Ver rel abund, we remove lots of low abundance OTUs
pick.Ver<- colnames(otu_table(Ver.rel))
Vdeseq.pick <- prune_taxa(names(taxa_sums(Vdeseq)) %in% pick.Ver, x=Vdeseq)
  # 208 OTUs

# Add 1 to every OTU count because DESeq doesn't work with lots of 0's
Ver1 <- otu_table(Vdeseq.pick) + 1

# Make new phyloseq object with prepared OTU table
Ver.samp <- sample_data(Vdeseq.pick)
Ver.tax <- tax_table(Vdeseq.pick)
Ver1 <- merge_phyloseq(Ver1, Ver.samp, Ver.tax)



##### Source #####
source <- deSEQ(data=Ver1, valuetest= ~Lake_Type+Season+Source)
  # I left out Depth & Fraction because those all take into account water vs. sediment

### Separate sediment & water samples
sed <- which(source$log2FoldChange < 0)
sed.otus <- rownames(source[sed,])
water <- which(source$log2FoldChange > 0)
water.otus <- rownames(source[water,])




##### Depth #####

# Now let's isolate Verrucos in water
Ver.water <- subset_samples(Ver1, Depth != "Sediment")
watercol <- deSEQ(data=Ver.water, valuetest= ~Lake_Type+Season+Depth, alpha=0.05)

### Separate sediment & water samples
water.bot <- which(watercol$log2FoldChange < 0)
water.bot.otus <- rownames(watercol[water.bot,])
water.top <- which(watercol$log2FoldChange > 0)
water.top.otus <- rownames(watercol[water.top,])


# Verrucos in Bottom vs. Sediment
Ver.bs <- subset_samples(Ver1, Depth != "Surface")
Ver.bs <- subset_samples(Ver.bs, Depth != "DCM")
Vbs <- deSEQ(data=Ver.bs, valuetest= ~Lake_Type+Season+Depth, alpha=0.05)

### Separate sediment & water samples
bs.bot <- which(Vbs$log2FoldChange < 0)
bs.bot.otus <- rownames(Vbs[bs.bot,])
bs.sed <- which(Vbs$log2FoldChange > 0)
bs.sed.otus <- rownames(Vbs[bs.sed,])



# Verrucos in Sediment vs. Surface
Ver.st <- subset_samples(Ver1, Depth != "Bottom")
Ver.st <- subset_samples(Ver.st, Depth != "DCM")
Vst <- deSEQ(data=Ver.st, valuetest= ~Lake_Type+Season+Depth, alpha=0.05)

### Separate sediment & water samples
st.sed <- which(Vst$log2FoldChange < 0)
st.sed.otus <- rownames(Vst[st.sed,])
st.top <- which(Vst$log2FoldChange > 0)
st.top.otus <- rownames(Vst[st.top,])


sed.otus1 <- intersect(water.bot.otus, bs.sed.otus)
  # OTUs that prefer bottom, also prefer sed more
sed.otus2 <- intersect(water.top.otus, st.sed.otus)
  # OTUs that prefer top, also prefer sed more

### OTUs that prefer a depth ###
sed.otus <- c(sed.otus1, sed.otus2)
bot.otus <- intersect(water.bot.otus, bs.bot.otus)
top.otus <- intersect(water.top.otus, st.top.otus)







##### Lake_Type #####

# Now let's isolate Verrucos in Estuary & Laurentian
V.el <- subset_samples(Ver1, Lake_Type != "Inland")
Vel <- deSEQ(data=V.el, valuetest= ~Depth+Season+Lake_Type, alpha=0.05)

### Separate Estuary & Laurentian samples
Vel.est <- which(Vel$log2FoldChange < 0)
Vel.est.otus <- rownames(Vel[Vel.est,])
Vel.lau <- which(Vel$log2FoldChange > 0)
Vel.lau.otus <- rownames(Vel[Vel.lau,])



# Now let's isolate Verrucos in Estuary & Inland
V.ei <- subset_samples(Ver1, Lake_Type != "Laurentian")
Vei <- deSEQ(data=V.ei, valuetest= ~Depth+Season+Lake_Type, alpha=0.05)

### Separate Estuary & Inland samples
Vei.est <- which(Vei$log2FoldChange < 0)
Vei.est.otus <- rownames(Vei[Vel.est,])
Vei.inl <- which(Vei$log2FoldChange > 0)
Vei.inl.otus <- rownames(Vei[Vei.inl,])


# Now let's isolate Verrucos in Laurentian & Inland
V.li <- subset_samples(Ver1, Lake_Type != "Estuary")
Vli <- deSEQ(data=V.li, valuetest= ~Depth+Season+Lake_Type, alpha=0.05)

### Separate Laurentian & Inland samples
Vli.inl <- which(Vli$log2FoldChange < 0)
Vli.inl.otus <- rownames(Vli[Vli.inl,])
Vli.lau <- which(Vel$log2FoldChange > 0)
Vli.lau.otus <- rownames(Vli[Vli.lau,])


### OTUs that prefer a Lake_Type ###
est.otus <- intersect(Vel.est.otus, Vei.est.otus)
inl.otus <- intersect(Vei.inl.otus, Vli.inl.otus)
lau.otus <- intersect(Vel.lau.otus, Vli.lau.otus)





##### Fraction #####
# Now let's isolate Verrucos in Free & Particle
V.frac <- subset_samples(Ver1, Fraction != "Sediment")
Vfrac <- deSEQ(data=V.frac, valuetest= ~Depth+Lake_Type+Season+Fraction, alpha=0.05)

### Separate Free and Particle samples
Vfrac.free <- which(Vfrac$log2FoldChange < 0)
free.otus <- rownames(Vfrac[Vfrac.free,])
Vfrac.part <- which(Vfrac$log2FoldChange > 0)
part.otus <- rownames(Vfrac[Vfrac.part,])






##### Season #####
# Now let's isolate Verrucos in Spring & Summer
V.ss <- subset_samples(Ver1, Season != "Fall")
Vss <- deSEQ(data=V.ss, valuetest= ~Depth+Lake_Type+Season, alpha=0.05)

### Separate Spring & Summer samples
Vss.sp <- which(Vss$log2FoldChange < 0)
Vss.sp.otus <- rownames(Vss[Vss.sp,])
Vss.su <- which(Vss$log2FoldChange > 0)
Vss.su.otus <- rownames(Vss[Vss.su,])




# Now let's isolate Verrucos in Spring & Fall
V.spf <- subset_samples(Ver1, Season != "Summer")
Vspf <- deSEQ(data=V.spf, valuetest= ~Depth+Lake_Type+Season, alpha=0.05)

### Separate Spring & Fall samples
Vspf.fa <- which(Vspf$log2FoldChange < 0)
Vspf.fa.otus <- rownames(Vspf[Vspf.fa,])
Vspf.sp <- which(Vspf$log2FoldChange > 0)
Vspf.sp.otus <- rownames(Vspf[Vspf.sp,])




# Now let's isolate Verrucos in Summer & Fall
V.suf <- subset_samples(Ver1, Season != "Spring")
Vsuf <- deSEQ(data=V.suf, valuetest= ~Depth+Lake_Type+Season, alpha=0.05)

### Separate Summer & Fall samples
Vsuf.fa <- which(Vsuf$log2FoldChange < 0)
Vsuf.fa.otus <- rownames(Vsuf[Vsuf.fa,])
Vsuf.su <- which(Vsuf$log2FoldChange > 0)
Vsuf.su.otus <- rownames(Vsuf[Vsuf.su,])




### OTUs that prefer a season ###
sp.otus <- intersect(Vss.sp.otus,Vspf.sp.otus)
su.otus <- intersect(Vss.su.otus,Vsuf.su.otus)
fa.otus <- intersect(Vspf.fa.otus,Vsuf.fa.otus)

```



### Create ecoIDs
```{r}
#http://stackoverflow.com/questions/10298662/find-elements-not-in-smaller-character-vector-list-but-in-big-list

# These are the Ver OTUs with which we were working
Ver.otus <- rownames(tax_table(Ver1))

### Create Lake_Type label
Lake_Type.label <- rownames(tax_table(Ver1))
# OTUs that prefer Estuary get "E"
Lake_Type.label[Lake_Type.label %in% est.otus] <- paste("E", Lake_Type.label[Lake_Type.label %in% est.otus])
# OTUs that prefer Inland get "I"
Lake_Type.label[Lake_Type.label %in% inl.otus] <- paste("I", Lake_Type.label[Lake_Type.label %in% inl.otus])
# OTUs that prefer Laurentian get "L"
Lake_Type.label[Lake_Type.label %in% lau.otus] <- paste("L", Lake_Type.label[Lake_Type.label %in% lau.otus])


### Create Depth label
Depth.label <- rownames(tax_table(Ver1))
# OTUs that prefer Bottom get "B"
Depth.label[Depth.label %in% bot.otus] <- paste("B", Depth.label[Depth.label %in% bot.otus])
# OTUs that prefer Sediment get "S"
Depth.label[Depth.label %in% sed.otus] <- paste("S", Depth.label[Depth.label %in% sed.otus])
# OTUs that prefer Top get "T"
Depth.label[Depth.label %in% top.otus] <- paste("T", Depth.label[Depth.label %in% top.otus])


### Create Fraction label
Fraction.label <- rownames(tax_table(Ver1))
# OTUs that prefer Free get "F"
Fraction.label[Fraction.label %in% free.otus] <- paste("F", Fraction.label[Fraction.label %in% free.otus])
# OTUs that prefer Particle get "P"
Fraction.label[Fraction.label %in% part.otus] <- paste("P", Fraction.label[Fraction.label %in% part.otus])


### Create Season label
Season.label <- rownames(tax_table(Ver1))
# OTUs that prefer Spring get "C_" (for chuntian (Chinese for Spring))
# There's an underscore because Season is the last ecoID label
Season.label[Season.label %in% sp.otus] <- paste("C_", Season.label[Season.label %in% sp.otus])
# OTUs that prefer Summer get "V_" (for verano (Spanish for Summer))
Season.label[Season.label %in% su.otus] <- paste("V_", Season.label[Season.label %in% su.otus])
# OTUs that prefer Fall get "A_" (for autumn)
Season.label[Season.label %in% fa.otus] <- paste("A_", Season.label[Season.label %in% fa.otus])


# Split ecoID characters to prepare to be put into a dataframe
Lake_Type.split <- data.frame(strsplit(Lake_Type.label, " "), stringsAsFactors=FALSE)
colnames(Lake_Type.split) <- Ver.otus
depth.split <- data.frame(strsplit(Depth.label, " "), stringsAsFactors=FALSE)
colnames(depth.split) <- Ver.otus
fraction.split <- data.frame(strsplit(Fraction.label, " "), stringsAsFactors=FALSE)
colnames(fraction.split) <- Ver.otus
season.split <- data.frame(strsplit(Season.label, " "), stringsAsFactors=FALSE)
colnames(season.split) <- Ver.otus

# Combine all the ecoIDs into one dataframe
Lake_Type.split[3,] <- depth.split[1,]
Lake_Type.split[4,] <- fraction.split[1,]
Lake_Type.split[5,] <- season.split[1,]
Lake_Type.split <- Lake_Type.split[-2,]


# Rename the OTUs with no preference in one of the ecological factors
nopref <- which(substr(Lake_Type.split[1,],1,1) == "O")
Lake_Type.split[1,nopref] <- 0
nopref <- which(substr(Lake_Type.split[2,],1,1) == "O")
Lake_Type.split[2,nopref] <- 0
nopref <- which(substr(Lake_Type.split[3,],1,1) == "O")
Lake_Type.split[3,nopref] <- 0
nopref <- which(substr(Lake_Type.split[4,],1,1) == "O")
Lake_Type.split[4,nopref] <- "0_"

### Combine all of the ecoIDs into the final dataframe
Lake_Type.split[5,] <- paste(Lake_Type.split[2,], Lake_Type.split[1,], Lake_Type.split[3,], Lake_Type.split[4,],
                         colnames(Lake_Type.split))

### Save our file!
write.csv(Lake_Type.split[5,], file="tree_files/Ecology_Otu_sig", row.names=FALSE, quote=FALSE)
  # To-Do outside of R:
        # Delete first row (OTU names)
        # Delete all spaces
```

### Create updated phyloseq object with EcoID
```{r}
### Create new phyloseq object with EcoIDs

eco.label<- read.csv("tree_files/Ecology_Otu_sig", header=F)
eco.label <- t(eco.label)
otu <- otu_table(Ver1)
samp <- sample_data(Ver1)

# Add ecoIDs to tax_table
tax <- data.frame(tax_table(Ver1))
tax$EcoID <- eco.label

# Split up ecoIDs to each separate preference
Lake_Type.split <- t(Lake_Type.split)
tax$Pref.Depth <- Lake_Type.split[,3]
tax$Pref.Lake_Type <- Lake_Type.split[,1]
tax$Pref.Fraction <- Lake_Type.split[,4]
tax$Pref.Season <- Lake_Type.split[,5]
tax <- as.matrix(tax)
tax <- tax_table(tax)

# Phyloseq object w/ ecoID info
eco.ver <- merge_phyloseq(otu, samp, tax)

# Add Verruco tree to phyloseq object
newick <- read.newick(file="tree_files/ver.tre")
newick_phy <- phy_tree(newick)

# Final phyloseq object!
Ver.tree<-merge_phyloseq(eco.ver,newick_phy)

```

### Create labels for IToL!
```{r}
### IToL Label Functions
color.id <- function(x) {
  ifelse(grepl("OPB35_soil_group",x),"#e41a1c",
  ifelse(grepl("Opitutae",x), "#377eb8",
  ifelse(grepl("Spartobacteria",x), "#4daf4a",
  ifelse(grepl("S-BQ2-57_soil_group",x), "#984ea3",
  ifelse(grepl("Verrucomicrobia_Incertae_Sedis",x), "#ff7f00",
  ifelse(grepl("Verrucomicrobiae",x), "#ffd92f",
  ifelse(grepl("unclassified",x), "#f1a3a9",
  ifelse(grepl("UA11",x), "#fff5eb",
         NA))))))))
}

depth.id <- function(x) {
  depth <- substr(x$EcoID,1,1)
  ifelse(grepl("T",depth), "1,-1,-1",
  ifelse(grepl("B",depth), "-1,1,-1",
  ifelse(grepl("S",depth), "-1,-1,1",
  ifelse(grepl("0",depth), "-1,-1,-1",
  NA))))
}

Lake_Type.id <- function(x) {
  Lake_Type <- substr(x$EcoID,2,2)
  ifelse(grepl("L",Lake_Type), "1,-1,-1",
  ifelse(grepl("E",Lake_Type), "-1,1,-1",
  ifelse(grepl("I",Lake_Type), "-1,-1,1",
  ifelse(grepl("0", Lake_Type), "-1,-1,-1",
  NA))))
}

fraction.id <- function(x) {
  fraction <- substr(x$EcoID,3,3)
  ifelse(grepl("P",fraction), "1,-1",
  ifelse(grepl("F",fraction), "-1,1",
  ifelse(grepl("0",fraction), "-1,-1",
  NA)))
}

season.id <- function(x) {
  season <- substr(x$EcoID,4,4)
  ifelse(grepl("C",season), "1,-1,-1",
  ifelse(grepl("V",season), "-1,1,-1",
  ifelse(grepl("A",season), "-1,-1,1",
  ifelse(grepl("0", season), "-1,-1,-1",
  NA))))
}

### Create IToL COLOR labels
all <- data.frame(tax_table(Ver.tree))
color.all <- data.frame(all$Species)
color.all$Class <- all$Class
color.all$color <- color.id(color.all$Class)
color.all$label <- paste(color.all$all.Species,"range",color.all$color,color.all$Class)
write.csv(color.all$label,file="sig.ver.color",row.names=FALSE,quote=FALSE)
  # To-Do outside of R:
        # Delete first row ("x")
        # Replace spaces with ","

### Create IToL ECOID Labels
ecoid.all <- data.frame(all$Species)
ecoid.all$EcoID <- all$EcoID
depth.itol <- depth.id(ecoid.all)
ecoid.all$depth.label <- depth.itol
Lake_Type.itol <- Lake_Type.id(ecoid.all)
ecoid.all$Lake_Type.label <- Lake_Type.itol
fraction.itol <- fraction.id(ecoid.all)
ecoid.all$fraction.label <- fraction.itol
season.itol <- season.id(ecoid.all)
ecoid.all$season.label <- season.itol
ecoid.all$itol.label <- paste(ecoid.all$all.Species, ecoid.all$depth.label, ecoid.all$Lake_Type.label,
                              ecoid.all$fraction.label, ecoid.all$season.label)
write.csv(ecoid.all$itol.label,"EcoID.IToL.label.sig", row.names=FALSE, quote=FALSE)
  # To-Do outside of R:
        # Delete first row ("x")
        # Replace spaces with ","
        # Copy and paste into ../make_tree/itol_files/eco.shape.sig.txt
```


### Subset only significant EcoID Verrucos
```{r}
# Subset out Verruco OTUs that have no preference
nosig <- which(substr(ecoid.all$EcoID,1,4)=="0000")
nosig.otus <- as.character(ecoid.all$all.Species[nosig])

# Subset out Verruco OTUs that have at least one preference
sig.otus <- Ver.otus[!Ver.otus %in% nosig.otus]
only.sig <- prune_taxa(sig.otus, Ver.tree)

# Verruco tree of only OTUs that have a preference
write.tree(phy_tree(only.sig), file="ver.sig.tre")

```





### Geiger
```{r}
# https://github.com/mwpennell/geiger-v2

# Read in tree of only Verrucos with a habitat preference
ver.sig.tre <- read.newick(file="tree_files/ver.sig.tre")

# Create dataframe with ecoID data
eco.label <- read.csv("tree_files/Ecology_Otu_sig", header=F)
eco.label <- t(eco.label)
eco.label <- data.frame(eco.label)
eco.label$OTU <- substr(eco.label[,1],6,14)
eco.label$Depth <- substr(eco.label[,1],1,1)
eco.label$Lake_Type <- substr(eco.label[,1],2,2)
eco.label$Fraction <- substr(eco.label[,1],3,3)
eco.label$Season <- substr(eco.label[,1],4,4)

# Remove non-significant Verruco OTUs
nosig <- setdiff(eco.label$OTU, ver.sig.tre$tip.label)
nosig.loc <- pmatch(nosig, eco.label$OTU)
eco.label <- eco.label[-nosig.loc,]


# Pull only OTUs with a Depth preference
eco.depth <- data.frame(eco.label$Depth, row.names=eco.label$OTU)
pref <- which(eco.depth != "0")
sig.depth <- data.frame(eco.depth[pref,1], row.names=row.names(eco.depth)[pref])
nopref <- which(eco.depth == "0")
nopref<- row.names(eco.depth)[nopref]
depth.tre <- drop.tip(ver.sig.tre, nopref)

# Test for phylogenetic signal in Depth affinity
optimal <- fitDiscrete(depth.tre, sig.depth, treeTransform="lambda")
phy.Lambda0 <- rescale(depth.tre, "lambda", 0)
zero <- fitDiscrete(phy.Lambda0, sig.depth)
d.lambda=2*(optimal$opt$lnL-zero$opt$lnL)
p.lambda <- pchisq(d.lambda, 1, lower.tail=F)
p.lambda
  # p-value = 0.1608328



# Pull only OTUs with a Lake Type preference
eco.lake <- data.frame(eco.label$Lake_Type, row.names=eco.label$OTU)
pref <- which(eco.lake != "0")
sig.lake <- data.frame(eco.lake[pref,1], row.names=row.names(eco.lake)[pref])
nopref <- which(eco.lake == "0")
nopref<- row.names(eco.lake)[nopref]
lake.tre <- drop.tip(ver.sig.tre, nopref)

# Test for phylogenetic signal in Lake Type affinity
optimal <- fitDiscrete(lake.tre, sig.lake, treeTransform="lambda")
phy.Lambda0 <- rescale(lake.tre, "lambda", 0)
zero <- fitDiscrete(phy.Lambda0, sig.lake)
d.lambda=2*(optimal$opt$lnL-zero$opt$lnL)
p.lambda <- pchisq(d.lambda, 1, lower.tail=F)
p.lambda
  # p-value = 0.02747234


# Pull out only OTUs with a Fraction preference
eco.frac <- data.frame(eco.label$Fraction, row.names=eco.label$OTU)
pref <- which(eco.frac != "0")
sig.frac <- data.frame(eco.frac[pref,1], row.names=row.names(eco.frac)[pref])
nopref <- which(eco.frac == "0")
nopref<- row.names(eco.frac)[nopref]
frac.tre <- drop.tip(ver.sig.tre, nopref)

# Test for phylogenetic signal in Fraction affinity
optimal <- fitDiscrete(frac.tre, sig.frac, treeTransform="lambda")
phy.Lambda0 <- rescale(frac.tre, "lambda", 0)
zero <- fitDiscrete(phy.Lambda0, sig.frac)
d.lambda=2*(optimal$opt$lnL-zero$opt$lnL)
p.lambda <- pchisq(d.lambda, 1, lower.tail=F)
p.lambda
  # p-value = 4.751642e-10



# Pull out only OTUs with a Season preference
eco.season <- data.frame(eco.label$Season, row.names=eco.label$OTU)
pref <- which(eco.season != "0")
sig.season <- data.frame(eco.season[pref,1], row.names=row.names(eco.season)[pref])
nopref <- which(eco.season == "0")
nopref<- row.names(eco.season)[nopref]
season.tre <- drop.tip(ver.sig.tre, nopref)

# Test for phylogenetic signal in Season affinity
optimal <- fitDiscrete(season.tre, sig.season, treeTransform="lambda")
phy.Lambda0 <- rescale(season.tre, "lambda", 0)
zero <- fitDiscrete(phy.Lambda0, sig.season)
d.lambda=2*(optimal$opt$lnL-zero$opt$lnL)
p.lambda <- pchisq(d.lambda, 1, lower.tail=F)
p.lambda
  # p-value = 9.164478e-05

##### Lake Type, Fraction, & Season have significant phylogenetic signals
##### Depth does not have significant phylogenetic signals

```


### Bootstrap Values
```{r}
#https://cran.r-project.org/web/packages/phangorn/vignettes/Trees.pdf

# Read in fasta file
# This file is all verrucos + 1 outgroup (planctomycetes)
# Any nonsignificant verruco sequences will be trimmed out once we combine the fasta file with the tree file
seqs <- read.phyDat("tree_files/combined.trim.contigs.good.unique.good.filter.unique.precluster.pick.an.unique_list.0.03.rep.cut3.pick.outgroup.fasta", format = "fasta", type = "DNA")

# Read in tree file
ver.sig.tre <- read.newick(file="tree_files/ver.sig.tre")

# Calculates maximum likelihood for tree
fit <- pml(ver.sig.tre, seqs)

### Time to choose the best model
# Test a bunch of different models
#mt <- modelTest(seqs, tree=ver.sig.tre, multicore=TRUE)
#mt[order(mt$AICc),]
# Choose the best model based on AICc
#bestmodel <- mt$Model[which.min(mt$AICc)]
#env <- attr(mt, "env")
# Below is the best model that you'll use
# GTR+G+I
#fitStart <- eval(get(bestmodel, env), env)

# Optimize model parameters
#fit.optim <- optim.pml(fitStart, rearrangement = "stochastic", optGamma=TRUE, optInv=TRUE, model="GTR")

# Apply bootstrap test
#bs.optim <- bootstrap.pml(fit.optim, bs=100, optNni=TRUE)
bs <- bootstrap.pml(fit, bs=100, optNni=TRUE)

# Unrooted tree (midpoint rooted) with bootstrap support values above 50
#bs.optim.tre <- plotBS(midpoint(fit.optim$tree), bs, p = 50, type="p")
bs.tre <- plotBS(midpoint(fit$tree), bs, p = 50, type="p")

# Consensus tree from bootstrap test
cnet <- consensusNet(bs)

### Which nodes have a bootstrap value of < 50
length(which(bs.tre$node.label < 50))
  # 57 nodes

### Export tree with bootstrap values as node labels
#write.tree(bs.tre, "tree_files/bootstrap.tre")

# Compare IToL tree with bootstrap tree
bs.tre <- read.newick(file="tree_files/bootstrap.tre")
length(intersect(ver.sig.tre$tip.label,bs.tre$tip.label))
  # Same tip labels on ver.sig.tre & treeBS

##### Rename bootstrap tree tips with full taxonomy #####
# Pull out only significant Verrucos
ver.sig <- merge_phyloseq(Ver, bs.tre)
tax.name <- data.frame(tax_table(ver.sig))
tax.name$Tip_Name <- NA

# Create tip name of class;order;family;genus
for (i in 1:125){
  class <- paste(tax.name[i,3])
  order <- paste(tax.name[i,4])
  family <- paste(tax.name[i,5])
  genus <- paste(tax.name[i,6])
  tax.name[i,8] <- paste(class, order, family, genus, sep=";")
}

# Write new tip names into csv file
# I have to manually edit out the unclassified
# Change ";" to "--- " (IToL doesn't recognize ";")
#write.csv(tax.name$Tip_Name, "tree_files/tip_name", row.names = F)

# Read in the final tip names
tip.name <- read.csv("tree_files/tip_name", header=F)
tip.name$OTU <- tax.name$Species

# Make bootstrapped tree with new tip names
name.tre <- bs.tre

# Match current tip names with new tip names
name.tre$tip.label <- tip.name$V1[match(name.tre$tip.label, tip.name$OTU)]

# Convert new tip labels from integer to character
name.tre$tip.label <- as.character(name.tre$tip.label)

# Save the new tree!
#write.tree(name.tre, "tree_files/bootstrap.tax.tre")
```


### Bioenv
```{r}
# Trim otu_table so that samples match metadata samples
meta.otus <- subset_samples(Ver.rel, SampleID != "Su13.ED.MM15.DN")
meta.otus <- subset_samples(meta.otus, SampleID != "Su13.BD.MM15.DN")
meta.otus <- subset_samples(meta.otus, SampleID != "Sp13.ED.MM15.SN")
meta.otus <- subset_samples(meta.otus, SampleID != "Sp13.ED.MM15.DD")
meta.otus <- subset_samples(meta.otus, SampleID != "Sp13.ED.MM110.DD")
meta.otus <- subset_samples(meta.otus, SampleID != "Sp13.BD.MM15.DD")
meta.otus <- subset_samples(meta.otus, SampleID != "Sp13.BD.MM110.DD")
meta.otus <- subset_samples(meta.otus, SampleID != "Fa13.BD.MM110.SD")
meta.otus <- subset_samples(meta.otus, SampleID != "Fa13.BD.MM110.SN")
meta.otus <- subset_samples(meta.otus, SampleID != "Fa13.BD.MM15.DN")
meta.otus <- subset_samples(meta.otus, SampleID != "Fa13.ED.MM15.DN")
meta.otus <- subset_samples(meta.otus, Station != "Buoy")
meta.otus <- subset_samples(meta.otus, Source != "Sediment")
meta.otus <- subset_samples(meta.otus, SampleID != "Z14.060.P")
meta.otus <- subset_samples(meta.otus, SampleID != "Z14.060.F")


# I'll be examining Laurentian, Estuary, and Inland Lake samples separately
# First separate the samples based on Lake Type
lau.otus <- data.frame(otu_table(subset_samples(meta.otus,Lake_Type=="Laurentian")))
est.otus <- data.frame(otu_table(subset_samples(meta.otus,Lake_Type=="Estuary")))
inl.otus <- data.frame(otu_table(subset_samples(meta.otus,Lake_Type=="Inland")))

# Now prune taxa that have 0 counts
lau.0 <- which(colSums(lau.otus) == 0)
lau.otus <- lau.otus[,-lau.0]
est.0 <- which(colSums(est.otus) == 0)
est.otus <- est.otus[,-est.0]
inl.0 <- which(colSums(inl.otus) == 0)
inl.otus <- inl.otus[,-inl.0]

# Read in metadata files
lau.env <- read.table("metadata/metadata_laurentian.csv", header=T, sep=",", row.names=1,
                      as.is=T)
est.env <- read.table("metadata/metadata_estuary.csv", header=T, sep=",", row.names=1,
                      as.is=T)
est.env <- est.env[,-27]
  # Remove DO %
inl.env <- read.table("metadata/metadata_inland.csv", header=T, sep=",", row.names=1,
                      as.is=T)

# Trim any metadata that isn't numeric
lau.env <- lau.env[,-1:-10]
est.env <- est.env[,-1:-10]
inl.env <- inl.env[,-1:-10]

# Laurentian metadata - Test for normality
shapiro.test(lau.env$Temperature..C)
  # p-value = 0.003358; not normal
shapiro.test(lau.env$SpCond...S.cm)
  # p-value = 0.000349; not normal
shapiro.test(lau.env$DO.Probe..mg.L.)
  # p-value = 0.0002237; not normal
shapiro.test(lau.env$Chl.Probe...g.L.)
  # p-value = 1.947e-06; not normal
shapiro.test(lau.env$Chl.Lab..ug.L.)
  # p-value = 2.712e-05; not normal
shapiro.test(lau.env$TP.ug.L)
  # p-value = 7.47e-08; not normal
shapiro.test(lau.env$PP.ug.L)
  # p-value = 8.309e-08; not normal
shapiro.test(lau.env$TDP.ug.L)
  # p-value = 7.005e-07
shapiro.test(lau.env$TDP.SRP)
  # p-value = 7.005e-07
shapiro.test(lau.env$POC.mg.L)
  # p-value = 0.01825; not normal
shapiro.test(lau.env$PON.mg.L)
  # p-value = 0.0217; not normal
shapiro.test(lau.env$DOC.mg.L)
  # p-value = 6.264e-06; not normal
shapiro.test(lau.env$SiO2.mg.L)
  # p-value = 0.00238; not normal
shapiro.test(lau.env$TSS.mg.L)
  # p-value = 8.456e-08; not normal
shapiro.test(lau.env$Fluorescence.mg.m3.)
  # p-value = 1.479e-06; not normal
shapiro.test(lau.env$PAR)
  # p-value = 3.161e-07; not normal

# Estuary metadata - Test for normality
shapiro.test(est.env$Temperature..C)
  # p-value = 0.0006905; not normal
shapiro.test(est.env$SpCond...S.cm.)
  # p-value = 0.0005477; not normal
shapiro.test(est.env$TDS..mg.L.)
  # p-value = 0.0005534; not normal
shapiro.test(est.env$pH)
  # p-value = 0.0005803; not normal
shapiro.test(est.env$ORP..mV.)
  # p-value = 9.753e-07; not normal
shapiro.test(est.env$Chl.Lab..ug.L.)
  # p-value = 6.355e-06; not normal
shapiro.test(est.env$BGA.cells.mL)
  # p-value = 9.826e-12; not normal
shapiro.test(est.env$Cl.mg.L)
  # p-value = 0.03225; not normal
shapiro.test(est.env$SO4.mg.L)
  # p-value = 4.367e-05; not normal
shapiro.test(est.env$NO3.mg.L)
  # p-value = 7.682e-05; not normal
shapiro.test(est.env$NH3.mg.L)
  # p-value = 1.03e-06; not normal
shapiro.test(est.env$TKN.mg.L)
  # p-value = 0.02124; not normal
shapiro.test(est.env$SRP.ug.L)
  # p-value = 1.462e-11; not normal
shapiro.test(est.env$TP.ug.L)
  # p-value = 4.798e-09; not normal
shapiro.test(est.env$Alk.mg.L)
  # p-value = 0.0001785; not normal
shapiro.test(est.env$DO.Lab.mg.L)
  # p-value = 3.206e-09; not normal
shapiro.test(est.env$DO..)
  # p-value = 4.353e-07; not normal
shapiro.test(est.env$Turb.NTU)
  # p-value = 0.01459; not normal

# Estuary metdata - Plot
plot(est.env$Temperature..C.)
plot(est.env$SpCond...S.cm.)
plot(est.env$TDS..mg.L.)
plot(est.env$pH)
plot(est.env$ORP..mV.)
plot(est.env$Chl.Lab..ug.L.)
plot(est.env$BGA.cells.mL)
  # Looks like a line
plot(est.env$Cl.mg.L)
plot(est.env$SO4.mg.L)
plot(est.env$NO3.mg.L)
plot(est.env$NH3.mg.L)
plot(est.env$TKN.mg.L)
plot(est.env$SRP.ug.L)
  # Is a line
plot(est.env$TP.ug.L)
plot(est.env$Alk.mg.L)
plot(est.env$DO.Lab.mg.L)
plot(est.env$DO..)
plot(est.env$Turb.NTU)





# Inland metadata - Test for normality
shapiro.test(sqrt(inl.env$Chl.Lab..ug.L.))
  # p-value = 1.441e-15; not normal
shapiro.test(sqrt(inl.env$NO3.mg.L))
  # p-value = <2.2e-16; not normal
shapiro.test(sqrt(inl.env$SRP.ug.L))
  # p-value = <2.2e-16; not normal
shapiro.test(inl.env$TP.ug.L)
  # p-value = <2.2e-16; not normal
shapiro.test(inl.env$TDP.ug.L)
  # p-value = <2.2e-16; not normal
shapiro.test(inl.env$NH4.ug.L)
  # p-value = <2.2e-16; not normal


# Inland metdata - Plot
plot(inl.env$Chl.Lab..ug.L.)
plot(inl.env$NO3.mg.L)
  # Looks like a straight line
plot(inl.env$SRP.ug.L)
  # Looks like a straight line
plot(inl.env$TP.ug.L)
  # Looks like a straight line
plot(inl.env$TDP.ug.L)
  # It IS a straight line
plot(inl.env$NH4.ug.L)
  # Looks like a straight line


##### Run Bioenv #####
bioenv.lau <- bioenv(lau.otus ~ Temperature..C. + DO.Probe..mg.L. +
                       Chl.Lab..ug.L. + TP.ug.L + PP.ug.L + TDP.ug.L +
                       POC.mg.L + PON.mg.L + DOC.mg.L + 
                       SiO2.mg.L + TSS.mg.L + Fluorescence.mg.m3. + PAR,
                     lau.env, method = "spearman", index = "bray",
                     trace = TRUE, partial = NULL)
  # Best parameter = DO.probe..mg.L
  # correlation = 0.4432778
bioenv.est <- bioenv(est.otus ~ Temperature..C. + SpCond...S.cm. +
                       TDS..mg.L. + pH + ORP..mV. + Chl.Lab..ug.L. +
                       BGA.cells.mL + Cl.mg.L + SO4.mg.L + NO3.mg.L +
                       NH3.mg.L + TKN.mg.L + SRP.ug.L + TP.ug.L +
                       Alk.mg.L + DO.probe.mg.L + Turb.NTU,
                     est.env, method = "spearman", index = "bray",
                     trace =TRUE, partial=NULL)
  # Best parameters = NH3.mg.L
  #                   SRP.ug.L
  #                   DO.probe.mg.L
  # correlation = 0.1246583
bioenv.inl <- bioenv(inl.otus ~ Chl.Lab..ug.L. + NO3.mg.L + SRP.ug.L +
                       TP.ug.L + TDP.ug.L + NH4.ug.L, inl.env,
                     method = "spearman", index = "bray", trace = TRUE,
                     partial = NULL)
  # Best parameters = NO3.mg.L
  #                   SRP.ug.L
  #                   TP.ug.L
  #                   NH4.ug.L
  # correlation = 0.4449871


##### P-value Calculations #####
# Perform random permutations of row names
# Laurentian
x <- 0
result.lau <- vector(mode="numeric", length = 100)
while (x < 100){
  lau.otus.rand <- lau.otus[sample(1:nrow(lau.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(lau.otus.rand ~ Temperature..C. + DO.Probe..mg.L. +
                       Chl.Lab..ug.L. + TP.ug.L + PP.ug.L + TDP.ug.L +
                       POC.mg.L + PON.mg.L + DOC.mg.L + 
                       SiO2.mg.L + TSS.mg.L + Fluorescence.mg.m3. + PAR, lau.env,
                       method = "spearman",index = "bray", trace = TRUE,
                       partial = NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.lau[x] = max(tmp)
  print(x)
}
hist(result.lau)
print(mean(result.lau))
print(max(result.lau))
print(quantile(result.lau,0.95))
print(quantile(result.lau,0.99)) 
print(quantile(result.lau,1))
  ## Yay, p-value < 0.01!

# Estuary
x <- 0
result.est <- vector(mode="numeric", length = 100)
while (x < 100){
  est.otus.rand <- est.otus[sample(1:nrow(est.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(est.otus.rand ~ Temperature..C. + SpCond...S.cm. +
                          TDS..mg.L. + pH + ORP..mV. + Chl.Lab..ug.L. +
                          BGA.cells.mL + Cl.mg.L + SO4.mg.L + NO3.mg.L +
                          NH3.mg.L + TKN.mg.L + SRP.ug.L + TP.ug.L +
                          Alk.mg.L + DO.probe.mg.L + Turb.NTU,
                        est.env, method = "spearman", index = "bray", 
                        trace =TRUE, partial=NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.est[x] = max(tmp)
  print(x)
}
hist(result.est)
print(mean(result.est))
print(max(result.est))
print(quantile(result.est,0.95))
print(quantile(result.est,0.99)) 
print(quantile(result.est,1))
  ### Estuary correlation is NOT significant


# Inland
x <- 0
result.inl <- vector(mode="numeric", length = 100)
while (x < 100){
  inl.otus.rand <- inl.otus[sample(1:nrow(inl.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(inl.otus.rand ~ Chl.Lab..ug.L. + NO3.mg.L +
                          SRP.ug.L + TP.ug.L + TDP.ug.L + NH4.ug.L,
                        inl.env, method = "spearman", index = "bray",
                        trace = TRUE, partial = NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.inl[x] = max(tmp)
  print(x)
}
hist(result.inl)
print(mean(result.inl))
print(max(result.inl))
print(quantile(result.inl,0.95))
print(quantile(result.inl,0.99))
print(quantile(result.inl,1))
  ###Yay, p-value < 0.01!




##### Fraction #####

# Subset out samples
lau <- subset_samples(meta.otus, Lake_Type=="Laurentian")
lau.part.otus <- data.frame(otu_table(subset_samples(lau, Fraction=="Particle")))
lau.free.otus <- data.frame(otu_table(subset_samples(lau, Fraction=="Free")))
est <- subset_samples(meta.otus, Lake_Type=="Estuary")
est.part.otus <- data.frame(otu_table(subset_samples(est, Fraction=="Particle")))
est.free.otus <- data.frame(otu_table(subset_samples(est, Fraction=="Free")))
inl <- subset_samples(meta.otus, Lake_Type=="Inland")
inl.part.otus <- data.frame(otu_table(subset_samples(inl, Fraction=="Particle")))
inl.free.otus <- data.frame(otu_table(subset_samples(inl, Fraction=="Free")))

# Now prune taxa that have 0 counts
lau.part.0 <- which(colSums(lau.part.otus) == 0)
lau.part.otus <- lau.part.otus[,-lau.part.0]
lau.free.0 <- which(colSums(lau.free.otus) == 0)
lau.free.otus <- lau.free.otus[,-lau.free.0]
est.part.0 <- which(colSums(est.part.otus) == 0)
est.part.otus <- est.part.otus[,-est.part.0]
est.free.0 <- which(colSums(est.free.otus) == 0)
est.free.otus <- est.free.otus[,-est.free.0]
inl.part.0 <- which(colSums(inl.part.otus) == 0)
inl.part.otus <- inl.part.otus[,-inl.part.0]
inl.free.0 <- which(colSums(inl.free.otus) == 0)
inl.free.otus <- inl.part.otus[,-inl.free.0]

# Read in metadata files
lau.part.env <- read.table("metadata/metadata.lau.part.csv", header=T, sep=",", 
                           row.names=1,as.is=T)
lau.free.env <- read.table("metadata/metadata.lau.free.csv", header=T, sep=",", 
                           row.names=1,as.is=T)
est.part.env <- read.table("metadata/metadata.est.part.csv", header=T, sep=",", 
                           row.names=1,as.is=T)
est.part.env <- est.part.env[,-27]
  # Remove DO %
est.free.env <- read.table("metadata/metadata.est.free.csv", header=T, sep=",",
                           row.names=1,as.is=T)
est.free.env <- est.free.env[,-27]
  # Remove DO %
inl.part.env <- read.table("metadata/metadata.inl.part.csv", header=T, sep=",",
                           row.names=1,as.is=T)
inl.free.env <- read.table("metadata/metadata.inl.free.csv", header=T, sep=",", 
                           row.names=1,as.is=T)

# Trim any metadata that isn't numeric
lau.part.env <- lau.part.env[,-1:-10]
lau.free.env <- lau.free.env[,-1:-10]
est.part.env <- est.part.env[,-1:-10]
est.free.env <- est.free.env[,-1:-10]
inl.part.env <- inl.part.env[,-1:-10]
inl.free.env <- inl.free.env[,-1:-10]


##### Run Frac Bioenv #####
bioenv.lau.part <- bioenv(lau.part.otus ~ Temperature..C. + DO.Probe..mg.L. +
                       Chl.Lab..ug.L. + TP.ug.L + PP.ug.L + TDP.ug.L +
                       POC.mg.L + PON.mg.L + DOC.mg.L + 
                       SiO2.mg.L + TSS.mg.L + Fluorescence.mg.m3. + PAR,
                     lau.part.env, method = "spearman", index = "bray",
                     trace = TRUE, partial = NULL)
  # Best parameters = Chl.Lab..ug.L.
  #                   TP.ug.L
  #                   PON.mg.L
  # correlation = 0.311058
bioenv.lau.free <- bioenv(lau.free.otus ~ Temperature..C. + DO.Probe..mg.L. +
                       Chl.Lab..ug.L. + TP.ug.L + PP.ug.L + TDP.ug.L +
                       POC.mg.L + PON.mg.L + DOC.mg.L + 
                       SiO2.mg.L + TSS.mg.L + Fluorescence.mg.m3. + PAR,
                     lau.free.env, method = "spearman", index = "bray",
                     trace = TRUE, partial = NULL)
  # Best parameters = DO.Probe..mg.L.
  #                   Fluorescence.mg.m3
  # correlation = 0.167519
bioenv.est.part <- bioenv(est.part.otus ~ Temperature..C. + SpCond...S.cm. +
                       TDS..mg.L. + pH + ORP..mV. + Chl.Lab..ug.L. +
                       BGA.cells.mL + Cl.mg.L + SO4.mg.L + NO3.mg.L +
                       NH3.mg.L + TKN.mg.L + SRP.ug.L + TP.ug.L +
                       Alk.mg.L + DO.probe.mg.L + Turb.NTU,
                     est.part.env, method = "spearman", index = "bray",
                     trace =TRUE, partial=NULL)
  # Best parameters = Chl.Lab..ug.L.
  # correlation = 0.07330661
bioenv.est.free <- bioenv(est.free.otus ~ Temperature..C. + SpCond...S.cm. +
                       TDS..mg.L. + pH + ORP..mV. + Chl.Lab..ug.L. +
                       BGA.cells.mL + Cl.mg.L + SO4.mg.L + NO3.mg.L +
                       NH3.mg.L + TKN.mg.L + SRP.ug.L + TP.ug.L +
                       Alk.mg.L + DO.probe.mg.L + Turb.NTU,
                     est.free.env, method = "spearman", index = "bray",
                     trace =TRUE, partial=NULL)
  # Best parameters = SpCond...S.cm.
  #                   NH3.mg.L
  # correlation = 0.1472449
bioenv.inl.part <- bioenv(inl.part.otus ~ Chl.Lab..ug.L. + NO3.mg.L + SRP.ug.L +
                       TP.ug.L + TDP.ug.L + NH4.ug.L, inl.part.env,
                     method = "spearman", index = "bray", trace = TRUE,
                     partial = NULL)
  # Best parameters = NO3.mg.L
  #                   SRP.ug.L
  #                   TP.ug.L
  #                   NH4.ug.L
  # correlation = 0.5861714
bioenv.inl.free <- bioenv(inl.free.otus ~ Chl.Lab..ug.L. + NO3.mg.L + SRP.ug.L +
                       TP.ug.L + TDP.ug.L + NH4.ug.L, inl.free.env,
                     method = "spearman", index = "bray", trace = TRUE,
                     partial = NULL)
  # Best parameters = NO3.mg.L
  #                   SRP.ug.L
  #                   TP.ug.L
  #                   NH4.ug.L
  # correlation = 0.5476402

##### P-value Frac Calculations #####
# Perform random permutations of row names
# Laurentian Particle
x <- 0
result.lau.part <- vector(mode="numeric", length = 100)
while (x < 100){
  lau.part.otus.rand <- lau.part.otus[sample(1:nrow(lau.part.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(lau.part.otus.rand ~ Temperature..C. + DO.Probe..mg.L. +
                       Chl.Lab..ug.L. + TP.ug.L + PP.ug.L + TDP.ug.L +
                       POC.mg.L + PON.mg.L + DOC.mg.L + 
                       SiO2.mg.L + TSS.mg.L + Fluorescence.mg.m3. + PAR, lau.part.env,
                       method = "spearman",index = "bray", trace = TRUE,
                       partial = NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.lau.part[x] = max(tmp)
  print(x)
}
hist(result.lau.part)
print(mean(result.lau.part))
print(max(result.lau.part))
print(quantile(result.lau.part,0.66))
  # p-value = 0.34

# Laurentian Free
x <- 0
result.lau.free <- vector(mode="numeric", length = 100)
while (x < 100){
  lau.free.otus.rand <- lau.free.otus[sample(1:nrow(lau.free.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(lau.free.otus.rand ~ Temperature..C. + DO.Probe..mg.L. +
                       Chl.Lab..ug.L. + TP.ug.L + PP.ug.L + TDP.ug.L +
                       POC.mg.L + PON.mg.L + DOC.mg.L + 
                       SiO2.mg.L + TSS.mg.L + Fluorescence.mg.m3. + PAR, lau.free.env,
                       method = "spearman",index = "bray", trace = TRUE,
                       partial = NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.lau.free[x] = max(tmp)
  print(x)
}
hist(result.free.lau)
print(mean(result.lau.free))
print(max(result.lau.free))
print(quantile(result.lau.free,0.95))
print(quantile(result.lau.free,0.55)) 
print(quantile(result.lau.free,1))
  # p-value = 0.45

# Estuary Particle
x <- 0
result.est.part <- vector(mode="numeric", length = 100)
while (x < 100){
  est.part.otus.rand <- est.part.otus[sample(1:nrow(est.part.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(est.part.otus.rand ~ Temperature..C. + SpCond...S.cm. +
                          TDS..mg.L. + pH + ORP..mV. + Chl.Lab..ug.L. +
                          BGA.cells.mL + Cl.mg.L + SO4.mg.L + NO3.mg.L +
                          NH3.mg.L + TKN.mg.L + SRP.ug.L + TP.ug.L +
                          Alk.mg.L + DO.probe.mg.L + Turb.NTU,
                        est.part.env, method = "spearman", index = "bray", 
                        trace =TRUE, partial=NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.est.part[x] = max(tmp)
  print(x)
}
hist(result.est.part)
print(mean(result.est.part))
print(max(result.est.part))
print(quantile(result.est.part,0.95))
print(quantile(result.est.part,0.00))
 # p-value= = 1

# Estuary Free
x <- 0
result.est.free <- vector(mode="numeric", length = 100)
while (x < 100){
  est.free.otus.rand <- est.free.otus[sample(1:nrow(est.free.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(est.free.otus.rand ~ Temperature..C. + SpCond...S.cm. +
                          TDS..mg.L. + pH + ORP..mV. + Chl.Lab..ug.L. +
                          BGA.cells.mL + Cl.mg.L + SO4.mg.L + NO3.mg.L +
                          NH3.mg.L + TKN.mg.L + SRP.ug.L + TP.ug.L +
                          Alk.mg.L + DO.probe.mg.L + Turb.NTU,
                        est.free.env, method = "spearman", index = "bray", 
                        trace =TRUE, partial=NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.est.free[x] = max(tmp)
  print(x)
}
hist(result.est.free)
print(mean(result.est.free))
print(max(result.est.free))
print(quantile(result.est.free,0.95))
print(quantile(result.est.free,0.22))
  # correlation = 0.78

# Inland Particle
x <- 0
result.inl.part <- vector(mode="numeric", length = 100)
while (x < 100){
  inl.part.otus.rand <- inl.part.otus[sample(1:nrow(inl.part.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(inl.part.otus.rand ~ Chl.Lab..ug.L. + NO3.mg.L +
                          SRP.ug.L + TP.ug.L + TDP.ug.L + NH4.ug.L,
                        inl.part.env, method = "spearman", index = "bray",
                        trace = TRUE, partial = NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.inl.part[x] = max(tmp)
  print(x)
}
hist(result.inl.part)
print(mean(result.inl.part))
print(max(result.inl.part))
print(quantile(result.inl.part,0.95))
print(quantile(result.inl.part,0.99))
print(quantile(result.inl.part,1))
  # p-value < 0.01

# Inland Free
x <- 0
result.inl.free <- vector(mode="numeric", length = 100)
while (x < 100){
  inl.free.otus.rand <- inl.free.otus[sample(1:nrow(inl.free.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(inl.free.otus.rand ~ Chl.Lab..ug.L. + NO3.mg.L +
                          SRP.ug.L + TP.ug.L + TDP.ug.L + NH4.ug.L,
                        inl.free.env, method = "spearman", index = "bray",
                        trace = TRUE, partial = NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.inl.free[x] = max(tmp)
  print(x)
}
hist(result.inl.free)
print(mean(result.inl.free))
print(max(result.inl.free))
print(quantile(result.inl.free,0.95))
print(quantile(result.inl.free,0.99))
print(quantile(result.inl.free,1))
  # p-value < 0.01




########## WHOLE COM BIOENV ##########
# Trim otu_table so that samples match metadata samples
scaled.meta.otus <- subset_samples(scaled, SampleID != "Su13.ED.MM15.DN")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Su13.BD.MM15.DN")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Sp13.ED.MM15.SN")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Sp13.ED.MM15.DD")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Sp13.ED.MM110.DD")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Sp13.BD.MM15.DD")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Sp13.BD.MM110.DD")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Fa13.BD.MM110.SD")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Fa13.BD.MM110.SN")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Fa13.BD.MM15.DN")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Fa13.ED.MM15.DN")
scaled.meta.otus <- subset_samples(scaled.meta.otus, Station != "Buoy")
scaled.meta.otus <- subset_samples(scaled.meta.otus, Source != "Sediment")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Z14.060.P")
scaled.meta.otus <- subset_samples(scaled.meta.otus, SampleID != "Z14.060.F")


# I'll be examining Laurentian, Estuary, and Inland Lake samples separately
# First separate the samples based on Lake Type
scaled.lau.otus <- data.frame(otu_table(subset_samples(scaled.meta.otus,Lake_Type=="Laurentian")))
scaled.est.otus <- data.frame(otu_table(subset_samples(scaled.meta.otus,Lake_Type=="Estuary")))
scaled.inl.otus <- data.frame(otu_table(subset_samples(scaled.meta.otus,Lake_Type=="Inland")))

# Now prune taxa that have 0 counts
scaled.lau.0 <- which(colSums(scaled.lau.otus) == 0)
scaled.lau.otus <- scaled.lau.otus[,-scaled.lau.0]
scaled.est.0 <- which(colSums(scaled.est.otus) == 0)
scaled.est.otus <- scaled.est.otus[,-scaled.est.0]
scaled.inl.0 <- which(colSums(scaled.inl.otus) == 0)
scaled.inl.otus <- scaled.inl.otus[,-scaled.inl.0]

# Read in metadata files
lau.env <- read.table("metadata/metadata_laurentian.csv", header=T, sep=",", row.names=1,
                      as.is=T)
est.env <- read.table("metadata/metadata_estuary.csv", header=T, sep=",", row.names=1,
                      as.is=T)
est.env <- est.env[,-27]
  # Remove DO %
inl.env <- read.table("metadata/metadata_inland.csv", header=T, sep=",", row.names=1,
                      as.is=T)

# Trim any metadata that isn't numeric
lau.env <- lau.env[,-1:-10]
est.env <- est.env[,-1:-10]
inl.env <- inl.env[,-1:-10]

##### Run Whole Com Bioenv #####
scaled.bioenv.lau <- bioenv(scaled.lau.otus ~ Temperature..C. +
                              DO.Probe..mg.L. + Chl.Lab..ug.L. + TP.ug.L +
                              PP.ug.L + TDP.ug.L + POC.mg.L + PON.mg.L +
                              DOC.mg.L +  SiO2.mg.L + TSS.mg.L +
                              Fluorescence.mg.m3. + PAR, lau.env,
                            method = "spearman", index = "bray",
                            trace = TRUE, partial = NULL)
  # Best parameters: PP.ug.L
  #                  TDP
  #                  PAR
  # correlation = 0.373295
scaled.bioenv.est <- bioenv(scaled.est.otus ~ Temperature..C. + 
                              SpCond...S.cm. + TDS..mg.L. + pH +
                              ORP..mV. + Chl.Lab..ug.L. + BGA.cells.mL +
                              Cl.mg.L + SO4.mg.L + NO3.mg.L + NH3.mg.L +
                              TKN.mg.L + SRP.ug.L + TP.ug.L + Alk.mg.L +
                              DO.probe.mg.L + Turb.NTU,
                            est.env, method = "spearman", index = "bray",
                            trace =TRUE, partial=NULL)
  # Best parameters = NH3.mg.L
  #                   SRP.ug.L
  #                   DO.probe.mg.L
  # correlation = 0.1786684
scaled.bioenv.inl <- bioenv(scaled.inl.otus ~ Chl.Lab..ug.L. + NO3.mg.L +
                              SRP.ug.L + TP.ug.L + TDP.ug.L + NH4.ug.L,
                            inl.env, method = "spearman", index = "bray",
                            trace = TRUE, partial = NULL)
  # Best parameters = NO3.mg.L
  #                   TP.ug.L
  #                   TDP.ug.L
  #                   NH4.ug.L
  # correlation = 0.5508089



##### WC P-value Calculations #####
# Perform random permutations of row names
# Laurentian
x <- 0
result.scaled.lau <- vector(mode="numeric", length = 100)
while (x < 100){
  lau.otus.rand <- scaled.lau.otus[sample(1:nrow(scaled.lau.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(lau.otus.rand ~ Temperature..C. +
                              DO.Probe..mg.L. + Chl.Lab..ug.L. + TP.ug.L +
                              PP.ug.L + TDP.ug.L + POC.mg.L + PON.mg.L +
                              DOC.mg.L +  SiO2.mg.L + TSS.mg.L +
                              Fluorescence.mg.m3. + PAR, lau.env,
                       method = "spearman",index = "bray", trace = TRUE,
                       partial = NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.lau[x] = max(tmp)
  print(x)
}
hist(result.scaled.lau)
print(mean(result.scaled.lau))
print(max(result.scaled.lau))
print(quantile(result.scaled.lau,0.95))
print(quantile(result.scaled.lau,0.99)) 
print(quantile(result.scaled.lau,1))
  # All results are 0 o.O
  ### Yay, p-value < 0.01!

# Estuary
x <- 0
result.scaled.est <- vector(mode="numeric", length = 100)
while (x < 100){
  est.otus.rand <- scaled.est.otus[sample(1:nrow(scaled.est.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(est.otus.rand ~ Temperature..C. + SpCond...S.cm. +
                          TDS..mg.L. + pH + ORP..mV. + Chl.Lab..ug.L. +
                          BGA.cells.mL + Cl.mg.L + SO4.mg.L + NO3.mg.L +
                          NH3.mg.L + TKN.mg.L + SRP.ug.L + TP.ug.L +
                          Alk.mg.L + DO.probe.mg.L + Turb.NTU,
                        est.env, method = "spearman", index = "bray", 
                        trace =TRUE, partial=NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.est[x] = max(tmp)
  print(x)
}
hist(result.scaled.est)
print(mean(result.scaled.est))
print(max(result.scaled.est))
print(quantile(result.scaled.est,0.95))
print(quantile(result.scaled.est,0.99)) 
print(quantile(result.scaled.est,1))
  ###Yay, p-value < 0.01!


# Inland
x <- 0
result.scaled.inl <- vector(mode="numeric", length = 100)
while (x < 100){
  inl.otus.rand <- scaled.inl.otus[sample(1:nrow(scaled.inl.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(inl.otus.rand ~ Chl.Lab..ug.L. + NO3.mg.L +
                          SRP.ug.L + TP.ug.L + TDP.ug.L + NH4.ug.L,
                        inl.env, method = "spearman", index = "bray",
                        trace = TRUE, partial = NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.inl[x] = max(tmp)
  print(x)
}
hist(result.scaled.inl)
print(mean(result.scaled.inl))
print(max(result.scaled.inl))
print(quantile(result.scaled.inl,0.95))
print(quantile(result.scaled.inl,0.99))
print(quantile(result.scaled.inl,1))
  ###Yay, p-value < 0.01!



                        

##### Fraction #####

# Subset out samples
scaled.lau <- subset_samples(scaled.meta.otus, Lake_Type=="Laurentian")
scaled.lau.part.otus <- data.frame(otu_table(subset_samples(scaled.lau, Fraction=="Particle")))
scaled.lau.free.otus <- data.frame(otu_table(subset_samples(scaled.lau, Fraction=="Free")))
scaled.est <- subset_samples(scaled.meta.otus, Lake_Type=="Estuary")
scaled.est.part.otus <- data.frame(otu_table(subset_samples(scaled.est, Fraction=="Particle")))
scaled.est.free.otus <- data.frame(otu_table(subset_samples(scaled.est, Fraction=="Free")))
scaled.inl <- subset_samples(scaled.meta.otus, Lake_Type=="Inland")
scaled.inl.part.otus <- data.frame(otu_table(subset_samples(scaled.inl, Fraction=="Particle")))
scaled.inl.free.otus <- data.frame(otu_table(subset_samples(scaled.inl, Fraction=="Free")))

# Now prune taxa that have 0 counts
scaled.lau.part.0 <- which(colSums(scaled.lau.part.otus) == 0)
scaled.lau.part.otus <- scaled.lau.part.otus[,-scaled.lau.part.0]
scaled.lau.free.0 <- which(colSums(scaled.lau.free.otus) == 0)
scaled.lau.free.otus <- scaled.lau.free.otus[,-scaled.lau.free.0]
scaled.est.part.0 <- which(colSums(scaled.est.part.otus) == 0)
scaled.est.part.otus <- scaled.est.part.otus[,-scaled.est.part.0]
scaled.est.free.0 <- which(colSums(scaled.est.free.otus) == 0)
scaled.est.free.otus <- scaled.est.free.otus[,-scaled.est.free.0]
scaled.inl.part.0 <- which(colSums(scaled.inl.part.otus) == 0)
scaled.inl.part.otus <- scaled.inl.part.otus[,-scaled.inl.part.0]
scaled.inl.free.0 <- which(colSums(scaled.inl.free.otus) == 0)
scaled.inl.free.otus <- scaled.inl.part.otus[,-scaled.inl.free.0]

# Read in metadata files
scaled.lau.part.env <- read.table("metadata/metadata.lau.part.csv", header=T, sep=",", 
                                  row.names=1, as.is=T)
scaled.lau.free.env <- read.table("metadata/metadata.lau.free.csv", header=T, sep=",", 
                                  row.names=1,as.is=T)
scaled.est.part.env <- read.table("metadata/metadata.est.part.csv", header=T, sep=",", 
                                  row.names=1, as.is=T)
scaled.est.part.env <- scaled.est.part.env[,-27]
  # Remove DO %
scaled.est.free.env <- read.table("metadata/metadata.est.free.csv", header=T, sep=",", 
                                  row.names=1, as.is=T)
scaled.est.free.env <- scaled.est.free.env[,-27]
  # Remove DO %
scaled.inl.part.env <- read.table("metadata/metadata.inl.part.csv", header=T, sep=",", 
                                  row.names=1, as.is=T)
scaled.inl.free.env <- read.table("metadata/metadata.inl.free.csv", header=T, sep=",", 
                                  row.names=1, as.is=T)

# Trim any metadata that isn't numeric
scaled.lau.part.env <- scaled.lau.part.env[,-1:-10]
scaled.lau.free.env <- scaled.lau.free.env[,-1:-10]
scaled.est.part.env <- scaled.est.part.env[,-1:-10]
scaled.est.free.env <- scaled.est.free.env[,-1:-10]
scaled.inl.part.env <- scaled.inl.part.env[,-1:-10]
scaled.inl.free.env <- scaled.inl.free.env[,-1:-10]


##### Run Frac Bioenv #####
bioenv.scaled.lau.part <- bioenv(scaled.lau.part.otus ~ Temperature..C. + DO.Probe..mg.L. +
                       Chl.Lab..ug.L. + TP.ug.L + PP.ug.L + TDP.ug.L +
                       POC.mg.L + PON.mg.L + DOC.mg.L + 
                       SiO2.mg.L + TSS.mg.L + Fluorescence.mg.m3. + PAR,
                     scaled.lau.part.env, method = "spearman", index = "bray",
                     trace = TRUE, partial = NULL)
  # Best parameters = DOC.mg.L
  #                   SIO2.mg.L
  # correlation = 0.3971576
bioenv.scaled.lau.free <- bioenv(scaled.lau.free.otus ~ Temperature..C. + DO.Probe..mg.L. +
                       Chl.Lab..ug.L. + TP.ug.L + PP.ug.L + TDP.ug.L +
                       POC.mg.L + PON.mg.L + DOC.mg.L + 
                       SiO2.mg.L + TSS.mg.L + Fluorescence.mg.m3. + PAR,
                     scaled.lau.free.env, method = "spearman", index = "bray",
                     trace = TRUE, partial = NULL)
  # Best parameters = DO.Probe..mg.L.
  #                   DOC.mg.L
  # correlation = 0.07188957
bioenv.scaled.est.part <- bioenv(scaled.est.part.otus ~ Temperature..C. + SpCond...S.cm. +
                       TDS..mg.L. + pH + ORP..mV. + Chl.Lab..ug.L. +
                       BGA.cells.mL + Cl.mg.L + SO4.mg.L + NO3.mg.L +
                       NH3.mg.L + TKN.mg.L + SRP.ug.L + TP.ug.L +
                       Alk.mg.L + DO.probe.mg.L + Turb.NTU,
                     scaled.est.part.env, method = "spearman", index = "bray",
                     trace =TRUE, partial=NULL)
  # Best parameters = Temperature..C.
  #                   NH3.mg.L
  # correlation = 0.04355959
bioenv.scaled.est.free <- bioenv(scaled.est.free.otus ~ Temperature..C. + SpCond...S.cm. +
                       TDS..mg.L. + pH + ORP..mV. + Chl.Lab..ug.L. +
                       BGA.cells.mL + Cl.mg.L + SO4.mg.L + NO3.mg.L +
                       NH3.mg.L + TKN.mg.L + SRP.ug.L + TP.ug.L +
                       Alk.mg.L + DO.probe.mg.L + Turb.NTU,
                     scaled.est.free.env, method = "spearman", index = "bray",
                     trace =TRUE, partial=NULL)
  # Best parameters = SpCond...S.cm.
  #                   NH3.mg.L
  # correlation = 0.08311599
bioenv.scaled.inl.part <- bioenv(scaled.inl.part.otus ~ Chl.Lab..ug.L. + NO3.mg.L + SRP.ug.L +
                       TP.ug.L + TDP.ug.L + NH4.ug.L, scaled.inl.part.env,
                     method = "spearman", index = "bray", trace = TRUE,
                     partial = NULL)
  # Best parameters = NO3.mg.L
  #                   TP.ug.L
  #                   TDP.ug.L
  #                   NH4.ug.L
  # correlation = 0.7564373
bioenv.scaled.inl.free <- bioenv(scaled.inl.free.otus ~ Chl.Lab..ug.L. + NO3.mg.L + SRP.ug.L +
                       TP.ug.L + TDP.ug.L + NH4.ug.L, scaled.inl.free.env,
                     method = "spearman", index = "bray", trace = TRUE,
                     partial = NULL)
  # Best parameters = NO3.mg.L
  #                   TP.ug.L
  #                   TDP.ug.L
  #                   NH4.ug.L
  # correlation = 0.755128

##### P-value Frac Calculations #####
# Perform random permutations of row names
# scaled.laurentian Particle
x <- 0
result.scaled.lau.part <- vector(mode="numeric", length = 100)
while (x < 100){
  scaled.lau.part.otus.rand <- scaled.lau.part.otus[sample(1:nrow(scaled.lau.part.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(scaled.lau.part.otus.rand ~ Temperature..C. + DO.Probe..mg.L. +
                       Chl.Lab..ug.L. + TP.ug.L + PP.ug.L + TDP.ug.L +
                       POC.mg.L + PON.mg.L + DOC.mg.L + 
                       SiO2.mg.L + TSS.mg.L + Fluorescence.mg.m3. + PAR, scaled.lau.part.env,
                       method = "spearman",index = "bray", trace = TRUE,
                       partial = NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.scaled.lau.part[x] = max(tmp)
  print(x)
}
hist(result.scaled.lau.part)
print(mean(result.scaled.lau.part))
print(max(result.scaled.lau.part))
print(quantile(result.scaled.lau.part,0.95))
print(quantile(result.scaled.lau.part,0.78))
  # correlation = 0.22

# scaled.laurentian Free
x <- 0
result.scaled.lau.free <- vector(mode="numeric", length = 100)
while (x < 100){
  scaled.lau.free.otus.rand <- scaled.lau.free.otus[sample(1:nrow(scaled.lau.free.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(scaled.lau.free.otus.rand ~ Temperature..C. + DO.Probe..mg.L. +
                       Chl.Lab..ug.L. + TP.ug.L + PP.ug.L + TDP.ug.L +
                       POC.mg.L + PON.mg.L + DOC.mg.L + 
                       SiO2.mg.L + TSS.mg.L + Fluorescence.mg.m3. + PAR, scaled.lau.free.env,
                       method = "spearman",index = "bray", trace = TRUE,
                       partial = NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.scaled.lau.free[x] = max(tmp)
  print(x)
}
hist(result.free.scaled.lau)
print(mean(result.scaled.lau.free))
print(max(result.scaled.lau.free))
print(quantile(result.scaled.lau.free,0.95))
print(quantile(result.scaled.lau.free,0.15))
  # p-value = 0.85

# scaled.estuary Particle
x <- 0
result.scaled.est.part <- vector(mode="numeric", length = 100)
while (x < 100){
  scaled.est.part.otus.rand <- scaled.est.part.otus[sample(1:nrow(scaled.est.part.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(scaled.est.part.otus.rand ~ Temperature..C. + SpCond...S.cm. +
                          TDS..mg.L. + pH + ORP..mV. + Chl.Lab..ug.L. +
                          BGA.cells.mL + Cl.mg.L + SO4.mg.L + NO3.mg.L +
                          NH3.mg.L + TKN.mg.L + SRP.ug.L + TP.ug.L +
                          Alk.mg.L + DO.probe.mg.L + Turb.NTU,
                        scaled.est.part.env, method = "spearman", index = "bray", 
                        trace =TRUE, partial=NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.scaled.est.part[x] = max(tmp)
  print(x)
}
hist(result.scaled.est.part)
print(mean(result.scaled.est.part))
print(max(result.scaled.est.part))
print(quantile(result.scaled.est.part,0.95))
print(quantile(result.scaled.est.part,0.00))
  # p-value = 1

# scaled.estuary Free
x <- 0
result.scaled.est.free <- vector(mode="numeric", length = 100)
while (x < 100){
  scaled.est.free.otus.rand <- scaled.est.free.otus[sample(1:nrow(scaled.est.free.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(scaled.est.free.otus.rand ~ Temperature..C. + SpCond...S.cm. +
                          TDS..mg.L. + pH + ORP..mV. + Chl.Lab..ug.L. +
                          BGA.cells.mL + Cl.mg.L + SO4.mg.L + NO3.mg.L +
                          NH3.mg.L + TKN.mg.L + SRP.ug.L + TP.ug.L +
                          Alk.mg.L + DO.probe.mg.L + Turb.NTU,
                        scaled.est.free.env, method = "spearman", index = "bray", 
                        trace =TRUE, partial=NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.scaled.est.free[x] = max(tmp)
  print(x)
}
hist(result.scaled.est.free)
print(mean(result.scaled.est.free))
print(max(result.scaled.est.free))
print(quantile(result.scaled.est.free,0.95))
print(quantile(result.scaled.est.free,0.03))
  # p-value = 0.97

# scaled.inland Particle
x <- 0
result.scaled.inl.part <- vector(mode="numeric", length = 100)
while (x < 100){
  scaled.inl.part.otus.rand <- scaled.inl.part.otus[sample(1:nrow(scaled.inl.part.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(scaled.inl.part.otus.rand ~ Chl.Lab..ug.L. + NO3.mg.L +
                          SRP.ug.L + TP.ug.L + TDP.ug.L + NH4.ug.L,
                        scaled.inl.part.env, method = "spearman", index = "bray",
                        trace = TRUE, partial = NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.scaled.inl.part[x] = max(tmp)
  print(x)
}
hist(result.scaled.inl.part)
print(mean(result.scaled.inl.part))
print(max(result.scaled.inl.part))
print(quantile(result.scaled.inl.part,0.95))
print(quantile(result.scaled.inl.part,0.99))
print(quantile(result.scaled.inl.part,1))
  # p-value < 0.01

# scaled.inland Free
x <- 0
result.scaled.inl.free <- vector(mode="numeric", length = 100)
while (x < 100){
  scaled.inl.free.otus.rand <- scaled.inl.free.otus[sample(1:nrow(scaled.inl.free.otus)),]
  x <- x + 1
  bioenv.rand <- bioenv(scaled.inl.free.otus.rand ~ Chl.Lab..ug.L. + NO3.mg.L +
                          SRP.ug.L + TP.ug.L + TDP.ug.L + NH4.ug.L,
                        scaled.inl.free.env, method = "spearman", index = "bray",
                        trace = TRUE, partial = NULL)
  tmp <- data.frame(summary(bioenv.rand)[2])
  result.scaled.inl.free[x] = max(tmp)
  print(x)
}
hist(result.scaled.inl.free)
print(mean(result.scaled.inl.free))
print(max(result.scaled.inl.free))
print(quantile(result.scaled.inl.free,0.95))
print(quantile(result.scaled.inl.free,0.99))
print(quantile(result.scaled.inl.free,1))
  # p-value < 0.01
```





### Extra Functions
```{r}
################# FUNCTION TO FIND NAS IN A DATAFRAME #################
nacols <- function(df) {
  colnames(df)[unlist(lapply(df, function(x) any(is.na(x))))]
}



# http://menugget.blogspot.com/2011/06/clarke-and-ainsworths-bioenv-and-bvstep.html#more
bio.env <- function(fix.mat, var.mat, 
fix.dist.method="bray", var.dist.method="euclidean",
scale.fix=FALSE, scale.var=TRUE,
output.best=10,
var.max=ncol(var.mat)
){
 if(dim(fix.mat)[1] != dim(var.mat)[1]){stop("fixed and variable matrices must have the same number of rows")}
 if(var.max > dim(var.mat)[2]){stop("var.max cannot be larger than the number of variables (columns) in var.mat")}
 
 require(vegan)
 
 combn.sum <- sum(factorial(ncol(var.mat))/(factorial(1:var.max)*factorial(ncol(var.mat)-1:var.max)))
 
 if(scale.fix){fix.mat<-scale(fix.mat)}else{fix.mat<-fix.mat}
 if(scale.var){var.mat<-scale(var.mat)}else{var.mat<-var.mat}
 fix.dist <- vegdist(fix.mat, method=fix.dist.method)
 RES_TOT <- c()
 best.i.comb <- c()
 iter <- 0
 for(i in 1:var.max){
  var.comb <- combn(1:ncol(var.mat), i, simplify=FALSE)
  RES <- data.frame(var.incl=rep(NA, length(var.comb)), n.var=i, rho=0)
  for(f in 1:length(var.comb)){
   iter <- iter+1
   var.dist <- vegdist(as.matrix(var.mat[,var.comb[[f]]]), method=var.dist.method)
   temp <- suppressWarnings(cor.test(fix.dist, var.dist, method="spearman"))
   RES$var.incl[f] <- paste(var.comb[[f]], collapse=",")
   RES$rho[f] <- temp$estimate
   if(iter %% 100 == 0){print(paste(round(iter/combn.sum*100, 3), "% finished"))}
  }
 
  order.rho <- order(RES$rho, decreasing=TRUE)
  best.i.comb <- c(best.i.comb, RES$var.incl[order.rho[1]])
  if(length(order.rho) > output.best){
   RES_TOT <- rbind(RES_TOT, RES[order.rho[1:output.best],])
  } else {
   RES_TOT <- rbind(RES_TOT, RES)
  }
 }
 rownames(RES_TOT)<-NULL
 
 if(dim(RES_TOT)[1] > output.best){
  order.by.best <- order(RES_TOT$rho, decreasing=TRUE)[1:output.best]
 } else {
  order.by.best <- order(RES_TOT$rho, decreasing=TRUE)
 }
 OBB <- RES_TOT[order.by.best,]
 rownames(OBB) <- NULL
 
 order.by.i.comb <- match(best.i.comb, RES_TOT$var.incl)
 OBC <- RES_TOT[order.by.i.comb,]
 rownames(OBC) <- NULL
 
 out <- list(
  order.by.best=OBB,
  order.by.i.comb=OBC,
  best.model.vars=paste(colnames(var.mat)[as.numeric(unlist(strsplit(OBB$var.incl[1], ",")))], collapse=",") ,
  best.model.rho=OBB$rho[1]
 )
 out
}







# This function was originally written by Ruben Props and further modified by Marian

# This function takes in a linear model output and a dataframe to do an analysis of 
# the residual and predicted values.
      # INPUT
      # 1. Linear model object from lm() function
      # 2. vector of observed y values (y-variable)
      # 3. Title in quotes for figure

      # OUTPUT
      # 3 plots:
      # Plot 1: QQPlot: Theoretical quantiles (x-axis) vs studentized residuals (y-axis) 
      # Plot 2:  Fitted values (x-axis) vs studentized residuals (y-axis) 
      # Plot 3:  Fitted values (x-axis) vs observed values (y-axis) 

plot_residuals <- function(lm_model, lm_observed_y, main_title){
  
  # set seed
  set.seed(777)
  
  # Make a 3 paneled plot
  par(mfrow=c(1,3), oma=c(0,0,0,0)) # c(bottom, left, top, right) 
  
  # 1st plot:  A qqplot; Theoretical quantiles (x-axis) vs studentized residuals (y-axis) 
  qqPlot(lm_model, col="blue", reps=10000, 
         ylab="Studentized residuals", 
         xlab="Theoretical quantiles (t-distribution)",
         cex=1.5, las=1)
  
  # 2nd plot:  Fitted values (x-axis) vs studentized residuals (y-axis) 
  plot(y=studres(lm_model), x=predict(lm_model), col="blue",
       las=1,ylab="Studentized residuals", xlab="Fitted Values", cex=1.5)
  # Draw a line at y=0
  lines(x=c(-10,60), y=c(0,0), lty=2)
  
  # If you studentized residuals is greater than 3, state that there's an outlier
  ifelse(sum(studres(lm_model) > 3) >= 1, 
         # Do this if the length of the studentized residuals is equal to or greater than 1
         print(paste("WARNING:You have", 
               length(studres(lm_model)[studres(lm_model) > 3]), 
               "high-leverage point(s)!")), 
         # Do this if the length of the studentized residuals is equal to or greater than 1
         print("There are no high leverage points in this model.")) 
  
  # Add a title to all the plots
  mtext(text = main_title, side = 3, line = 2, outer = FALSE)
  #  side:  1=bottom, 2=left, 3=top, 4=right
  
  # 3rd plot: Fitted values (x-axis) vs observed values (y-axis) 
  plot(y=lm_observed_y, x=predict(lm_model), col="blue",
       ylab="Observed values",
       xlab="Fitted Values", cex=1.5,
       las=1)
  # draw a 1:1 line
  abline(a = 0, b = 1, lty=2)
  
 }


```